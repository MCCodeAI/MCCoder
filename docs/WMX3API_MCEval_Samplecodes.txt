# Write python code to move Axis 0 to 180 with velocity 1000.
# Write python code to start an absolute position command of Axis 0 to position 180 with 1000 velocity.

    # Axes = [0]
    # Start an absolute position command of Axis 0 to position 180 with 1000 velocity.
    posCommand = Motion_PosCommand()
    posCommand.profile.type = ProfileType.Trapezoidal
    posCommand.axis = 0
    posCommand.target = 180
    posCommand.profile.velocity = 1000
    posCommand.profile.acc = 10000
    posCommand.profile.dec = 10000

    # Execute command to move from current position to specified absolute position.
    ret = Wmx3Lib_cm.motion.StartPos(posCommand)
    if ret!=0:
        print('StartPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until the axis moves to the target position and stops.
    Wmx3Lib_cm.motion.Wait(0)



#``



# Write python code to move Axis 1 by a 200 distance with velocity 2000.
# Write python code to Start a relative position command of Axis 1 by a 200 distance and 2000 velocity.
    # Axes = [1]

    # Start a relative position command of Axis 1 with 200 distance and 2000 velocity.
    # Create a command value of target as 200.
    posCommand = Motion_PosCommand()
    posCommand.profile.type = ProfileType.Trapezoidal
    posCommand.axis = 1
    posCommand.target = 200
    posCommand.profile.velocity = 2000
    posCommand.profile.acc = 10000
    posCommand.profile.dec = 10000

    # Execute command to move from current position to a specified distance relatively. e.g. 'Move 100..'
    ret = Wmx3Lib_cm.motion.StartMov(posCommand)
    if ret!=0:
        print('StartMov error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until the axis moves to the target position and stops.
    Wmx3Lib_cm.motion.Wait(1)


#``



# Write python code to Jog Axis 2 for 1.5s with 160 velocity, then start an absolute position command to position 10 with 1000 velocity.
# Jog Axis 2 for 1.5s with 160 velocity, then move to 10 with velocity 1000.
    # Axes = [2]

    jogCommand = Motion_JogCommand()
    jogCommand.profile.type = ProfileType.Trapezoidal
    jogCommand.axis = 2
    jogCommand.profile.velocity = 160
    jogCommand.profile.acc = 10000
    jogCommand.profile.dec = 10000

    # Rotate the motor at the specified speed.
    ret =Wmx3Lib_cm.motion.StartJog(jogCommand)
    if ret!=0:
        print('StartJog error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    #Jogging for 1.5 seconds
    sleep(1.5)
    
    Wmx3Lib_cm.motion.Stop(2)

    Wmx3Lib_cm.motion.Wait(2)
    
    # Create a command value of target as 10.
    posCommand = Motion_PosCommand()
    posCommand.profile.type = ProfileType.Trapezoidal
    posCommand.axis = 2
    posCommand.target = 10
    posCommand.profile.velocity = 1000
    posCommand.profile.acc = 10000
    posCommand.profile.dec = 10000

    # Execute command to move from current position to specified absolute position.
    ret = Wmx3Lib_cm.motion.StartPos(posCommand)
    if ret!=0:
        print('StartPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until the axis moves to the target position and stops.
    Wmx3Lib_cm.motion.Wait(2)



#``



# Write python code to move Axis 0 to position 180 with 1000 velocity, and then move Axis 0 by a 200 distance and 2000 velocity.
# Write python code to Start an absolute position command of Axis 0 to position 180 with 1000 velocity, and then start a relative position command of Axis 0 by a 200 distance and 2000 velocity.


    # Axes = [0]
    # Create a command value of target as 180.
    posCommand = Motion_PosCommand()
    posCommand.profile.type = ProfileType.Trapezoidal
    posCommand.axis = 0
    posCommand.target = 180
    posCommand.profile.velocity = 1000
    posCommand.profile.acc = 10000
    posCommand.profile.dec = 10000

    # Execute command to move from current position to specified absolute position.
    ret = Wmx3Lib_cm.motion.StartPos(posCommand)
    if ret!=0:
        print('StartPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until the axis moves to the target position and stops.
    Wmx3Lib_cm.motion.Wait(0)

    # Create a command value of target as 200.
    posCommand = Motion_PosCommand()
    posCommand.profile.type = ProfileType.Trapezoidal
    posCommand.axis = 0
    posCommand.target = 200
    posCommand.profile.velocity = 2000
    posCommand.profile.acc = 10000
    posCommand.profile.dec = 10000

    # Execute command to move from current position to a specified distance relatively. e.g. 'Move 100..'
    ret = Wmx3Lib_cm.motion.StartMov(posCommand)
    if ret!=0:
        print('StartMov error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until the axis moves to the target position and stops.
    Wmx3Lib_cm.motion.Wait(0)


#``



# Write python code to Start an absolute position path interpolation motion command of Axis 0 and 1 with velocity 1000. The 1st segment is a linear interpolation to position (-200, -200), the 2nd segment is a counterclockwise circular interpolation to position (-150, -200) with center point (0, 0), the 3rd segment is a linear interpolation to position (-180, -10), and the 4th segment is a clockwise circular interpolation to position (-10, -150) with center point (0, 0).
# clockwise: If 0, the arc will rotate in the counterclockwise direction. If 1, the arc will rotate in the clockwise direction.

    # Axes = [0, 1]

    adv = AdvancedMotion(Wmx3Lib)
    path = AdvMotion_PathIntplCommand()

    path.SetAxis(0, 0)
    path.SetAxis(1, 1)

    path.enableConstProfile = 1

    path.profile = Profile()
    path.profile.type = ProfileType.Trapezoidal
    path.profile.velocity = 1000
    path.profile.acc = 10000
    path.profile.dec = 10000

    path.numPoints = 4

    path.SetType(0, AdvMotion_PathIntplSegmentType.Linear)

    path.SetTarget(0, 0, -200)
    path.SetTarget(1, 0, -200)

    path.SetType(1, AdvMotion_PathIntplSegmentType.Circular)
    path.SetTarget(0, 1, -150)
    path.SetTarget(1, 1, -200)
    path.SetCenterPos(0, 1, 0)
    path.SetCenterPos(1, 1, 0)
    path.SetDirection(1, 1)  # 1 for counterclockwise    -1 clockwise

    path.SetType(2, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 2, -180)
    path.SetTarget(1, 2, -10)

    path.SetType(3, AdvMotion_PathIntplSegmentType.Circular)
    path.SetTarget(0, 3, -10)
    path.SetTarget(1, 3, -150)
    path.SetCenterPos(0, 3, 0)
    path.SetCenterPos(1, 3, 0)
    path.SetDirection(3, -1)   # 1 for counterclockwise    -1 clockwise

    ret = adv.advMotion.StartPathIntplPos(path)
    if ret!=0:
            print('StartPathIntplPos error code is ' + str(ret) + ': ' + adv.ErrorToString(ret))
            return

    # Wait for the motion to complete. Start a blocking wait command, returning only when Axis 0 and Axis 1 become idle.
    axisSel = AxisSelection()
    axisSel.axisCount = 2
    axisSel.SetAxis(0, 0)
    axisSel.SetAxis(1, 1)
    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axisSel)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return


#``



# Write python code to Set output bit 0.2 to be 1, sleep for 0.15 seconds, and then set it to be 0.
    # Axes = []

    # Set output bit 0.2 to be 1, 
    Wmx3Lib_Io = Io(Wmx3Lib)
    ret = Wmx3Lib_Io.SetOutBit(0x0, 0x02, 0x01)
    if ret!=0:
        print('SetOutBit error code is ' + str(ret) + ': ' + Wmx3Lib_Io.ErrorToString(ret))
        return
    
    sleep(0.15)

    # Set output bit 0.2 to be 0.
    ret = Wmx3Lib_Io.SetOutBit(0x0, 0x02, 0x00)
    if ret!=0:
        print('SetOutBit error code is ' + str(ret) + ': ' + Wmx3Lib_Io.ErrorToString(ret))
        return


#``



# Write python code to Start an absolute position linear interpolation motion command of Axis 0 and 1 to position (300, 100) with 1000 velocity.
    # Axes = [0, 1]

    # Create a command value of target as (300, 100).
    lin = Motion_LinearIntplCommand()
    lin.axisCount = 2 
    lin.SetAxis(0,0)
    lin.SetAxis(1,1) 

    lin.profile.type = ProfileType.Trapezoidal
    lin.profile.velocity = 1000
    lin.profile.acc = 10000
    lin.profile.dec = 10000

    lin.SetTarget(0,300)  #Set target of Axis 0 to be 300
    lin.SetTarget(1,100)  #Set target of Axis 1 to be 100

    # Start an absolute position linear interpolation motion command.
    ret =Wmx3Lib_cm.motion.StartLinearIntplPos(lin)
    if ret!=0:
            print('StartLinearIntplPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
            return
    
    # Wait for the motion to complete. Start a blocking wait command, returning only when Axis 0 and Axis 1 become idle.
    axisSel = AxisSelection()
    axisSel.axisCount = 2
    axisSel.SetAxis(0, 0)
    axisSel.SetAxis(1, 1)
    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axisSel)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    


#``



# Write python code to Start a relative position linear interpolation motion command of Axis 0 and 1 with  (200, -150) distance with 1000 velocity.
    # Axes = [0, 1]
    
    # Create a command value of relative distance of (200, -150).
    lin = Motion_LinearIntplCommand()
    lin.axisCount = 2 
    lin.SetAxis(0,0)
    lin.SetAxis(1,1) 

    lin.profile.type = ProfileType.Trapezoidal
    lin.profile.velocity = 1000
    lin.profile.acc = 10000
    lin.profile.dec = 10000

    lin.SetTarget(0,200)  #Set target of Axis 0 to be 300
    lin.SetTarget(1,-150)  #Set target of Axis 1 to be 100

    # Start an relative position linear interpolation motion command.
    ret =Wmx3Lib_cm.motion.StartLinearIntplMov(lin)
    if ret!=0:
            print('StartLinearIntplMov error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
            return
    
    # Wait for the motion to complete. Start a blocking wait command, returning only when Axis 0 and Axis 1 become idle.
    axisSel = AxisSelection()
    axisSel.axisCount = 2
    axisSel.SetAxis(0, 0)
    axisSel.SetAxis(1, 1)
    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axisSel)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    


#``



# Write python code to Start an absolute position linear interpolation motion command of Axis 0 and 1 to position (300, 100) with 1000 velocity, and then start a relative position linear interpolation motion command of Axis 0 and 1 with  (200, -150) distance with 1000 velocity.
    # Axes = [0, 1]

    # Create a command value of relative distance
    lin = Motion_LinearIntplCommand()
    lin.axisCount = 2 
    lin.SetAxis(0,0)
    lin.SetAxis(1,1) 

    lin.profile.type = ProfileType.Trapezoidal
    lin.profile.velocity = 1000
    lin.profile.acc = 10000
    lin.profile.dec = 10000

    lin.SetTarget(0,300)  #Set target of Axis 0 to be 300
    lin.SetTarget(1,100)  #Set target of Axis 1 to be 100

    # Start an absolute position linear interpolation motion command.
    ret =Wmx3Lib_cm.motion.StartLinearIntplPos(lin)
    if ret!=0:
            print('StartLinearIntplPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
            return
    Wmx3Lib_cm.motion.Wait(0) #need to wait the Axis 0 to be idle

    lin.SetTarget(0,200)  #Set target of Axis 0  
    lin.SetTarget(1,-150)  #Set target of Axis 1  

    # Start an relative position linear interpolation motion command.
    ret =Wmx3Lib_cm.motion.StartLinearIntplMov(lin)
    if ret!=0:
            print('StartLinearIntplMov error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
            return
    
    # Wait for the motion to complete. Start a blocking wait command, returning only when Axis 0 and Axis 1 become idle.
    axisSel = AxisSelection()
    axisSel.axisCount = 2
    axisSel.SetAxis(0, 0)
    axisSel.SetAxis(1, 1)
    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axisSel)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    


#``



# Write python code to Establish synchronous control between master axis 0 and a slave axis 1, then move Axis 0 to position 188 with velocity 1200.
    # Axes = [0, 1]

    # Establish the synchronization between Axis 0 and Axis 1, with Axis 0 designated as the master axis and Axis 1 as the slave axis.
    ret = Wmx3Lib_cm.sync.SetSyncMasterSlave(0, 1)
    if ret != 0:
        print('SetSyncMasterSlave error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Create a command with target position 1,000,000 and velocity 100,000.
    posCommand = Motion_PosCommand()
    posCommand.profile.type = ProfileType.Trapezoidal
    posCommand.axis = 0
    posCommand.target = 188
    posCommand.profile.velocity = 1200
    posCommand.profile.acc = 10000
    posCommand.profile.dec = 10000

    # Execute the command to move the master axis from its current position to a specified absolute position, with the slave axis moving in synchronization.
    ret = Wmx3Lib_cm.motion.StartPos(posCommand)
    if ret != 0:
        print('StartMov error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait for the positioning motion to complete. Start a blocking wait command, returning only when Axis 0 becomes idle.
    ret = Wmx3Lib_cm.motion.Wait(0)
    if ret != 0:
        print('Wait error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Release the synchronization between Axis 0 and Axis 1.
    ret = Wmx3Lib_cm.sync.ResolveSync(1)
    if ret != 0:
        print('ResolveSync error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return



#``



# Write python code to Start a cubic spline motion command of Axis 2 and 3 with the total time of 1000ms to complete, the 1st point to 9th point are (0,0),(10,0),(50,50),(100,100),(100,150),(0,150),(0,100),(50,50),(7,8).
    # Axes = [2, 3]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    # Allocate buffer memory for a spline execution channel with 100 points for Channel 0.
    ret = Wmx3Lib_adv.advMotion.CreateSplineBuffer(0, 100)
    if ret != 0:
        print('CreateSplineBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Set the spline command options, specifying Axis 0 and Axis 1, with a total time of 1,000 milliseconds to complete the spline motion.
    splineCommand = AdvMotion_TotalTimeSplineCommand()
    splineCommand.dimensionCount = 2
    splineCommand.SetAxis(0, 2)
    splineCommand.SetAxis(1, 3)
    splineCommand.totalTimeMilliseconds = 1000

    # Set the spline point data with 9 points.
    splinePoint = []

    ret, CmStatus = Wmx3Lib_cm.GetStatus()

    splinePoint.append(AdvMotion_SplinePoint())
    splinePoint[0].SetPos(0, 0)
    splinePoint[0].SetPos(1, 0)

    splinePoint.append(AdvMotion_SplinePoint())
    splinePoint[1].SetPos(0, 10)
    splinePoint[1].SetPos(1, 0)

    splinePoint.append(AdvMotion_SplinePoint())
    splinePoint[2].SetPos(0, 50)
    splinePoint[2].SetPos(1, 50)

    splinePoint.append(AdvMotion_SplinePoint())
    splinePoint[3].SetPos(0, 100)
    splinePoint[3].SetPos(1, 100)

    splinePoint.append(AdvMotion_SplinePoint())
    splinePoint[4].SetPos(0, 100)
    splinePoint[4].SetPos(1, 150)

    splinePoint.append(AdvMotion_SplinePoint())
    splinePoint[5].SetPos(0, 0)
    splinePoint[5].SetPos(1, 150)

    splinePoint.append(AdvMotion_SplinePoint())
    splinePoint[6].SetPos(0, 0)
    splinePoint[6].SetPos(1, 100)

    splinePoint.append(AdvMotion_SplinePoint())
    splinePoint[7].SetPos(0, 50)
    splinePoint[7].SetPos(1, 50)

    splinePoint.append(AdvMotion_SplinePoint())
    splinePoint[8].SetPos(0, 7)
    splinePoint[8].SetPos(1, 8)

    # Execute the spline command.
    ret = Wmx3Lib_adv.advMotion.StartCSplinePos_TotalTime(0, splineCommand, 9, splinePoint)
    if ret != 0:
        print('StartCSplinePos_TotalTime error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the spline motion to complete. Start a blocking wait command, returning only when Axis 0 and Axis 1 become idle.
    axisSel = AxisSelection()
    axisSel.axisCount = 2
    axisSel.SetAxis(0, 2)
    axisSel.SetAxis(1, 3)
    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axisSel)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Free buffer memory for the spline execution channel. (Normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreeSplineBuffer(0)
    if ret != 0:
        print('FreeSplineBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return



#``



# Write python code to Create and execute a cyclic buffer memory space for Axis 4, to pisition 100 within 200 cycles, then move a relative 0 distance within 600 cycles, then to pisition -100 within 200 cycles, then sleep 1.5s, and close the cyclic buffer.
    # Axes = [4]

    Wmx3Lib_cyc = CyclicBuffer(Wmx3Lib)

    # Create a new cyclic buffer memory space for Axis 4, with a size of 1,024 cycles.
    ret = Wmx3Lib_cyc.OpenCyclicBuffer(4, 1024)
    if ret != 0:
        print('OpenCyclicBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_cyc.ErrorToString(ret))
        return

    # Start the execution of the cyclic position command buffer for Axis 4.
    ret = Wmx3Lib_cyc.Execute(4)
    if ret != 0:
        print('Execute error code is ' + str(ret) + ': ' + Wmx3Lib_cyc.ErrorToString(ret))
        return

    # Dynamically add points to move from the current position to the absolute position of 100 within 200 cycles.
    cyclicBufferSingleAxisCommand = CyclicBufferSingleAxisCommand()
    cyclicBufferSingleAxisCommand.type = CyclicBufferCommandType.AbsolutePos
    cyclicBufferSingleAxisCommand.intervalCycles = 200
    cyclicBufferSingleAxisCommand.command = 100
    ret = Wmx3Lib_cyc.AddCommand(4, cyclicBufferSingleAxisCommand)
    if ret != 0:
        print('AddCommand error code is ' + str(ret) + ': ' + Wmx3Lib_cyc.ErrorToString(ret))
        return

    # The relative position is 0, which means there was no movement for 600 cycles from the previous position.
    cyclicBufferSingleAxisCommand.type = CyclicBufferCommandType.RelativePos
    cyclicBufferSingleAxisCommand.intervalCycles = 600
    cyclicBufferSingleAxisCommand.command = 0
    ret = Wmx3Lib_cyc.AddCommand(4, cyclicBufferSingleAxisCommand)
    if ret != 0:
        print('AddCommand error code is ' + str(ret) + ': ' + Wmx3Lib_cyc.ErrorToString(ret))
        return

    # Move from the current position to the absolute position of -100 within 200 cycles.
    cyclicBufferSingleAxisCommand.type = CyclicBufferCommandType.AbsolutePos
    cyclicBufferSingleAxisCommand.intervalCycles = 200
    cyclicBufferSingleAxisCommand.command = -100
    ret = Wmx3Lib_cyc.AddCommand(4, cyclicBufferSingleAxisCommand)
    if ret != 0:
        print('AddCommand error code is ' + str(ret) + ': ' + Wmx3Lib_cyc.ErrorToString(ret))
        return

    # Wait for Cyclic buffer executing to end
    while True:
        ret,cyc_Status=Wmx3Lib_cyc.GetStatus(4)
        if(cyc_Status.remainCount<=0):
            break
        sleep(0.1)

    # Wait for 1.5 seconds
    sleep(1.5)

    # Close the cyclic buffer memory space.
    ret = Wmx3Lib_cyc.CloseCyclicBuffer(4)
    if ret != 0:
        print('CloseCyclicBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_cyc.ErrorToString(ret))
        return



#``



# Write python code to Start the motion for a path interpolation with look ahead channel 0 for Axis 0 and 1, with velocity 500, the 1st to 4th points are (100, 0) with smoothRadius as 12.5, (100, 100) with smoothRadius as 25,(0, 100) with smoothRadius as 50, and(0, 0).
    # Axes = [0, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)

    sleep(0.1)

    # Allocate buffer memory for a path interpolation with look ahead channel with 1,000 points for Channel 0.
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplLookaheadBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Set the configuration for the path interpolation with lookahead channel, specifying Axis 0 and Axis 1, with composite velocity of 1,000, composite acceleration of 20,000, and sample distance of 100.
    conf = AdvMotion_PathIntplLookaheadConfiguration()
    conf.axisCount = 2
    conf.SetAxis(0, 0)
    conf.SetAxis(1, 1)
    conf.compositeVel = 500
    conf.compositeAcc = 10000
    conf.sampleDistance = 100
    conf.stopOnEmptyBuffer = True

    ret = Wmx3Lib_adv.advMotion.SetPathIntplLookaheadConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplLookaheadConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Add interpolation commands to the path interpolation with look ahead channel, with the main body being a square trajectory formed by four points, with a side length of 100. There are smooth radius of 12.5, 25, and 50 at the end of the first, second, and third segments, respectively.
    path = AdvMotion_PathIntplLookaheadCommand()
    path.numPoints = 4

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 100)
    point.linear.SetTarget(1, 0)
    point.linear.smoothRadius = 12.5
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 100)
    point.linear.SetTarget(1, 100)
    point.linear.smoothRadius = 25
    path.SetPoint(1, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 0)
    point.linear.SetTarget(1, 100)
    point.linear.smoothRadius = 50
    path.SetPoint(2, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 0)
    point.linear.SetTarget(1, 0)
    path.SetPoint(3, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplLookaheadCommand(0, path)
    if ret != 0:
        print('AddPathIntplLookaheadCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Start the motion for the path interpolation with look ahead channel.
    ret = Wmx3Lib_adv.advMotion.StartPathIntplLookahead(0)
    if ret != 0:
        print('StartPathIntplLookahead error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the motion to complete. Start a blocking wait command, returning only when Axis 0 and Axis 1 become idle.
    axisSel = AxisSelection()
    axisSel.axisCount = 2
    axisSel.SetAxis(0, 0)
    axisSel.SetAxis(1, 1)
    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axisSel)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Free buffer memory for a path interpolation with lookahead channel. 
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    if ret != 0:
        print('FreePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return




#``



# Write python code to Start a clockwise circular interpolation motion command of Axis 0 and 1 with center position (100, 200), arc length 360, and velocity 1000.
    # Axes = [0, 1]

    circularIntplCommand = Motion_CenterAndLengthCircularIntplCommand()

    # Execute Circular Interpolation of Axis 0 and 1 with center position (100, 200), arc length 360, velocity 1000.
    circularIntplCommand.SetAxis(0, 0)
    circularIntplCommand.SetAxis(1, 1)
    circularIntplCommand.SetCenterPos(0, 100)
    circularIntplCommand.SetCenterPos(1, 200)
    circularIntplCommand.clockwise = 1
    circularIntplCommand.arcLengthDegree = 360
    circularIntplCommand.profile.type = ProfileType.Trapezoidal
    circularIntplCommand.profile.velocity = 1000
    circularIntplCommand.profile.acc = 10000
    circularIntplCommand.profile.dec = 10000
    ret = Wmx3Lib_cm.motion.StartCircularIntplPos_CenterAndLength(circularIntplCommand)
    if ret != 0:
        print('StartCircularIntplPos_RadiusAndEnd error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait for the motion to complete. Start a blocking wait command, returning only when Axis 0 and Axis 1 become idle.
    axisSel = AxisSelection()
    axisSel.axisCount = 2
    axisSel.SetAxis(0, 0)
    axisSel.SetAxis(1, 1)
    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axisSel)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return



#``



# Write python code to Start a helical interpolation motion command of clockwise circular interpolation of Axis 4 and 5 with center position  (100, 120), rotation degree 720, and velocity 1060, while concurrently moving axis 8 as the linear axis to position 140.
    # Axes = [4, 5, 8]

    helicalCommand = Motion_HelicalIntplCommand()

    # Execute Helical Motion
    helicalCommand.SetAxis(0, 4)
    helicalCommand.SetAxis(1, 5)
    helicalCommand.zAxis = 8
    helicalCommand.SetCenterPos(0, 100)
    helicalCommand.SetCenterPos(1, 120)
    helicalCommand.zEndPos = 140
    helicalCommand.clockwise = 1
    helicalCommand.arcLengthDegree = 720
    helicalCommand.profile.type = ProfileType.Trapezoidal
    helicalCommand.profile.velocity = 1060
    helicalCommand.profile.acc = 10000
    helicalCommand.profile.dec = 10000
    ret = Wmx3Lib_cm.motion.StartHelicalIntplPos(helicalCommand)
    if ret != 0:
        print('StartHelicalIntplPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait for the motion to complete. Start a blocking wait command, returning only when Axis 4, 5 and 8 become idle.
    axisSel = AxisSelection()
    axisSel.axisCount = 3
    axisSel.SetAxis(0, 4)
    axisSel.SetAxis(1, 5)
    axisSel.SetAxis(2, 8)
    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axisSel)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
        

#``



# Write python code to Start a relative triggered position command of Axis 1 with 180 distance and velocity of 1000, and the triggered condition is the remaining distance for Axis 0 to the target position is 30 while it moves a relative 100 distance.
    # Axes = [0, 1]

    posCommand = Motion_PosCommand()
    tgrPosCommand = Motion_TriggerPosCommand()
    trigger = Trigger()

    # Move the motor to the specified position.
    posCommand.profile.type = ProfileType.Trapezoidal
    posCommand.axis = 0
    posCommand.target = 100
    posCommand.profile.velocity = 1000
    posCommand.profile.acc = 10000
    posCommand.profile.dec = 10000
    ret = Wmx3Lib_cm.motion.StartMov(posCommand)
    if ret != 0:
        print('StartMov error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Set trigger PosCommand.
    tgrPosCommand.profile.type = ProfileType.Trapezoidal
    tgrPosCommand.axis = 1
    tgrPosCommand.target = 180
    tgrPosCommand.profile.velocity = 1000
    tgrPosCommand.profile.acc = 10000
    tgrPosCommand.profile.dec = 10000

    # Create Trigger
    # Start when the remaining distance of 0 axis reaches 30 pulse.
    trigger.triggerAxis = 0
    trigger.triggerType = TriggerType.RemainingDistance
    trigger.triggerValue = 30
    tgrPosCommand.trigger = trigger
    ret = Wmx3Lib_cm.motion.StartMov_Trigger(tgrPosCommand)
    if ret != 0:
        print('StartMov_Trigger error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    Wmx3Lib_cm.motion.Wait(1)

    # Wait for the motion to complete. Start a blocking wait command, returning only when Axis 0 and Axis 1 become idle.
    axisSel = AxisSelection()
    axisSel.axisCount = 2
    axisSel.SetAxis(0, 0)
    axisSel.SetAxis(1, 1)
    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axisSel)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
        


#``



# Write python code to sleep 1.6s.
# Pause for 1.6 seconds
# Axes = []

    # Sleep 1.6s
    sleep(1.6)




#``



# Write python code to run an API buffer.
# Write python code to Record and execute an API buffer with two segments: Move Axis 0 to position 200 and Axis 1 to postion 100.

    # Axes = [0, 1]

    Wmx3Lib_buf = ApiBuffer(Wmx3Lib)
    #  Clear the buffer of the specified channel.
    Wmx3Lib_buf.Clear(0)
    # Create a buffer for the specified channel.
    Wmx3Lib_buf.CreateApiBuffer(0, 1024 * 1024 * 3)
    # Start recording for the specified channel.
    Wmx3Lib_buf.StartRecordBufferChannel(0)

    # Create a command value.
    posCommand = Motion_PosCommand()
    posCommand.profile.type = ProfileType.Trapezoidal
    posCommand.axis = 0
    posCommand.target = 200
    posCommand.profile.velocity = 1000
    posCommand.profile.acc = 10000
    posCommand.profile.dec = 10000

    # Execute command to move to a specified absolute position. 
    Wmx3Lib_cm.motion.StartPos(posCommand)

    Wmx3Lib_buf.Wait(0)

    posCommand.axis = 1
    posCommand.target = 100
    posCommand.profile.velocity = 1000
    posCommand.profile.acc = 10000
    posCommand.profile.dec = 10000

    # Execute command to move to a specified absolute position.
    Wmx3Lib_cm.motion.StartPos(posCommand)
    Wmx3Lib_buf.Wait(1)

    # End Recording.
    Wmx3Lib_buf.EndRecordBufferChannel()
    # Drive the motion accumulated in the buffer so far.
    Wmx3Lib_buf.Execute(0)

    # Wait for the motion to complete. Start a blocking wait command, returning only when Axis 0 and Axis 1 become idle.
    axisSel = AxisSelection()
    axisSel.axisCount = 2
    axisSel.SetAxis(0, 0)
    axisSel.SetAxis(1, 1)
    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axisSel)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Destroy API buffer resources.
    Wmx3Lib_buf.Halt(0)
    Wmx3Lib_buf.FreeApiBuffer(0)



#``



# Write python code to Set an event to trigger a relative position command of Axis 0 with 100 distance and 1000 velocity, when Output 1.0 = 0. Event id is 10.
    # Axes = [0]

    Wmx3Lib_EventCtl = EventControl(Wmx3Lib)
    eventIN_IO = IoEventInput()
    eventOut_Motion = CoreMotionEventOutput()
    # Event ID
    posEventID = 10
    # RemoveEvent
    Wmx3Lib_EventCtl.RemoveEvent(posEventID)

    eventIN_IO.type = IoEventInputType.NotIOBit
    eventIN_IO.ioBit.ioSourceType = IOSourceType.Output
    eventIN_IO.ioBit.bitAddress = 0
    eventIN_IO.ioBit.byteAddress = 1

    eventOut_Motion.type = CoreMotionEventOutputType.StartSingleMov
    eventOut_Motion.startSingleMov.axis = 0
    eventOut_Motion.startSingleMov.type = ProfileType.Trapezoidal
    eventOut_Motion.startSingleMov.target = 100
    eventOut_Motion.startSingleMov.velocity = 1000
    eventOut_Motion.startSingleMov.acc = 10000
    eventOut_Motion.startSingleMov.dec = 10000

    # Set input events, output events, and event addresses.
    ret,Event_ID = Wmx3Lib_EventCtl.SetEvent_ID(eventIN_IO, eventOut_Motion, posEventID)
    if ret != 0:
        print('SetEvent_ID error code is ' + str(ret))
        return
    # EnableEvent
    Wmx3Lib_EventCtl.EnableEvent(posEventID, 1)

    sleep(0.01)
    # Set Output 1.0 = 1 to trigger the motion
    Wmx3Lib_Io = Io(Wmx3Lib)
    ret = Wmx3Lib_Io.SetOutBit(0x01, 0x00, 0x01)
    if ret!=0:
        print('SetOutBit error code is ' + str(ret) + ': ' + Wmx3Lib_Io.ErrorToString(ret))
        return

    # Wait until the axis moves to the target position and stops.
    Wmx3Lib_cm.motion.Wait(0)




#``



# Write python code to Execute an absolute triggered position command.Start an absolute postion command of Axis 0 to position 124 with velocity 1000, when the remaining time is 0, triggers Axis 0 to move to the absolute position of 70 with velocity 2000.
    # Axes = [0]

    pos = Motion_PosCommand()
    trigPos = Motion_TriggerPosCommand()

    # Execute normal motion command
    pos.axis = 0
    pos.profile.type = ProfileType.Trapezoidal
    pos.profile.velocity = 1000
    pos.profile.acc = 10000
    pos.profile.dec = 10000
    pos.profile.endVelocity = 1000
    pos.target = 124

    ret = Wmx3Lib_cm.motion.StartPos(pos)
    if ret != 0:
        print('StartPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Execute trigger motion command
    trigPos.axis = 0
    trigPos.profile.type = ProfileType.Trapezoidal
    trigPos.profile.velocity = 2000
    trigPos.profile.acc = 10000
    trigPos.profile.dec = 10000
    trigPos.target = 70
    trigPos.trigger.triggerType = TriggerType.RemainingTime
    trigPos.trigger.triggerAxis = 0
    trigPos.trigger.triggerValue = 0

    ret = Wmx3Lib_cm.motion.StartPos_Trigger(trigPos)
    if ret != 0:
        print('StarttrigPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until the axis moves to the target position and stops.
    Wmx3Lib_cm.motion.Wait(0)



#``



# Write python code to Execute an absolute position linear interpolation motion command. Control Axis 0 and 1 to linearly interpolate to position (300, 100) at a velocity of 1000, with acceleration and deceleration of 10000. Set the maximum velocity of Axis 0 to 600.
    # Axes = [0, 1]

    lin = Motion_LinearIntplCommand()

    # Execute absolute position linear interpolation motion command
    lin.axisCount = 2
    lin.SetAxis(0, 0)
    lin.SetAxis(1, 1)

    lin.profile.type = ProfileType.Trapezoidal
    lin.profile.velocity = 1000
    lin.profile.acc = 10000
    lin.profile.dec = 10000

    lin.SetTarget(0, 300)
    lin.SetTarget(1, 100)

    lin.SetMaxVelocity(0, 600)

    ret = Wmx3Lib_cm.motion.StartLinearIntplPos(lin)
    if ret != 0:
        print('StartLinearIntplPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait for the motion to complete. Start a blocking wait command, returning only when Axis 0 and Axis 1 become idle.
    axisSel = AxisSelection()
    axisSel.axisCount = 2
    axisSel.SetAxis(0, 0)
    axisSel.SetAxis(1, 1)
    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axisSel)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return


#``



# Write python code to Execute an absolute position linear interpolation motion command. Control Axis 0 and Axis 1 to linearly interpolate to position (300, 100). Set the maximum velocity of Axis 0 to 600 and Axis 1 to 500, with a maximum acceleration and deceleration of Axis 0 to 4000 and Axis 1 to 3000.
    # Axes = [0, 1]

    lin = Motion_LinearIntplCommand()

    # Execute absolute position linear interpolation motion command
    lin.axisCount = 2
    lin.SetAxis(0, 0)
    lin.SetAxis(1, 1)

    lin.profile.type = ProfileType.Trapezoidal
    lin.profile.velocity = 1000
    lin.profile.acc = 10000
    lin.profile.dec = 10000

    lin.SetTarget(0, 300)
    lin.SetTarget(1, 100)

    lin.SetMaxVelocity(0, 600)
    lin.SetMaxVelocity(1, 500)

    lin.SetMaxAcc(0, 4000)
    lin.SetMaxAcc(1, 3000)

    lin.SetMaxDec(0, 4000)
    lin.SetMaxDec(1, 3000)

    ret = Wmx3Lib_cm.motion.StartLinearIntplPos(lin)
    if ret != 0:
        print('StartLinearIntplPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait for the motion to complete. Start a blocking wait command, returning only when Axis 0 and Axis 1 become idle.
    axisSel = AxisSelection()
    axisSel.axisCount = 2
    axisSel.SetAxis(0, 0)
    axisSel.SetAxis(1, 1)
    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axisSel)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return


#``



# Write python code to Execute an absolute position triggered linear interpolation motion command.Control Axis 0 and Axis 1 to linearly interpolate to (150, 30) at a velocity of 1000 with acceleration and deceleration of 10000. Wait for 1 millisecond, then execute the trigger linear interpolation motion command. When the completed distance of Axis 0 reaches 100, move Axis 0 and Axis 1 to (-100, -10).
    # Axes = [0, 1]

    lin = Motion_LinearIntplCommand()
    trig = Trigger()

    # Execute normal motion command
    lin.axisCount = 2
    lin.SetAxis(0, 0)
    lin.SetAxis(1, 1)

    lin.profile.type = ProfileType.Trapezoidal
    lin.profile.velocity = 1000
    lin.profile.acc = 10000
    lin.profile.dec = 10000

    lin.SetTarget(0, 150)
    lin.SetTarget(1, 30)

    ret = Wmx3Lib_cm.motion.StartLinearIntplPos(lin)
    if ret != 0:
        print('StartLinearIntplPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    sleep(0.001)

    lin.SetTarget(0, -100)
    lin.SetTarget(1, -10)

    trig.triggerAxis = 0
    trig.triggerType = TriggerType.CompletedDistance
    trig.triggerValue = 100

    ret = Wmx3Lib_cm.motion.StartLinearIntplPos_Trigger(lin, trig)
    if ret != 0:
        print('StartLinearIntplPos_Trigger error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait for the motion to complete. Start a blocking wait command, returning only when Axis 0 and Axis 1 become idle.
    axisSel = AxisSelection()
    axisSel.axisCount = 2
    axisSel.SetAxis(0, 0)
    axisSel.SetAxis(1, 1)
    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axisSel)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    


#``



# Write python code to Execute an absolute position triggered linear interpolation motion command.Control Axis 0 and Axis 1 to linearly interpolate to (130, 60) at a velocity of 1000 with acceleration and deceleration of 10000. Wait for 1 millisecond, then execute the trigger linear interpolation motion command. When the remaining distance of Axis 0 is 80, trigger Axis 0 and Axis 1 to (-70, -40).
    # Axes = [0, 1]

    lin = Motion_LinearIntplCommand()
    trig = Trigger()

    # Execute normal motion command
    lin.axisCount = 2
    lin.SetAxis(0, 0)
    lin.SetAxis(1, 1)

    lin.profile.type = ProfileType.Trapezoidal
    lin.profile.velocity = 1000
    lin.profile.acc = 10000
    lin.profile.dec = 10000

    lin.SetTarget(0, 130)
    lin.SetTarget(1, 60)

    ret = Wmx3Lib_cm.motion.StartLinearIntplPos(lin)
    if ret != 0:
        print('StartLinearIntplPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    sleep(0.001)

    lin.SetTarget(0, -70)
    lin.SetTarget(1, -40)

    trig.triggerAxis = 0
    trig.triggerType = TriggerType.RemainingDistance
    trig.triggerValue = 80

    ret = Wmx3Lib_cm.motion.StartLinearIntplPos_Trigger(lin, trig)
    if ret != 0:
        print('StartLinearIntplPos_Trigger error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return   

    # Wait for the motion to complete. Start a blocking wait command, returning only when Axis 0 and Axis 1 become idle.
    axisSel = AxisSelection()
    axisSel.axisCount = 2
    axisSel.SetAxis(0, 0)
    axisSel.SetAxis(1, 1)
    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axisSel)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    



#``



# Write python code to Execute an absolute position triggered circular interpolation motion command.Control Axis 0 and Axis 1 to perform a clockwise circular interpolation with a 50 radius to pisition (100, 0) at a velocity of 1000. Wait for 1 millisecond, then execute the trigger circular interpolation motion command. When the remaining distance of Axis 0 is 80, trigger Axis 0 and Axis 1 to perform a clockwise circular interpolation (200, 0).
    # Axes = [0, 1]

    cir = Motion_RadiusAndEndCircularIntplCommand()
    trig = Trigger()

    # Execute normal motion command
    cir.SetAxis(0, 0)
    cir.SetAxis(1, 1)

    cir.profile.type = ProfileType.Trapezoidal
    cir.profile.velocity = 1000
    cir.profile.acc = 10000
    cir.profile.dec = 10000

    cir.SetEndPos(0, 100)
    cir.SetEndPos(1, 0)

    cir.radius = 50
    cir.clockwise = 1

    ret = Wmx3Lib_cm.motion.StartCircularIntplPos_RadiusAndEnd(cir)
    if ret != 0:
        print('StartCircularIntplPos_RadiusAndEnd error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    sleep(0.001)

    cir.SetEndPos(0, 200)
    cir.SetEndPos(1, 0)

    trig.triggerAxis = 0
    trig.triggerType = TriggerType.RemainingDistance
    trig.triggerValue = 80

    ret = Wmx3Lib_cm.motion.StartCircularIntplPos_RadiusAndEnd_Trigger(cir, trig)
    if ret != 0:
        print('StartCircularIntplPos_RadiusAndEnd_Trigger error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait for the motion to complete. Start a blocking wait command, returning only when Axis 0 and Axis 1 become idle.
    axisSel = AxisSelection()
    axisSel.axisCount = 2
    axisSel.SetAxis(0, 0)
    axisSel.SetAxis(1, 1)
    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axisSel)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    


#``



# Write python code to Execute an absolute position triggered linear interpolation motion command.Control Axis 0 and Axis 1 to linearly interpolate to (100, 100) at a velocity of 1000 with acceleration and deceleration of 10000. Wait for 1 millisecond, then execute the trigger linear interpolation motion command. When the remaining distance is 30, trigger Axis 0 and Axis 1 to (200, 0). After previous interpolation completes, when the remaining distance is 30, trigger Axis 0 and Axis 1 to (200, 0).And using same trigger and condition to trigger Axis 0 and Axis 1 to (300, 100),(400, 0) and (500, 100).
    # Axes = [0, 1]

    lin = Motion_LinearIntplCommand()
    trig = Trigger()

    # Execute normal motion command
    lin.axisCount = 2
    lin.SetAxis(0, 0)
    lin.SetAxis(1, 1)

    lin.profile.type = ProfileType.Trapezoidal
    lin.profile.velocity = 1000
    lin.profile.acc = 10000
    lin.profile.dec = 10000

    lin.SetTarget(0, 100)
    lin.SetTarget(1, 100)

    ret = Wmx3Lib_cm.motion.StartLinearIntplPos(lin)
    if ret != 0:
        print('StartLinearIntplPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    sleep(0.001)

    lin.SetTarget(0, 200)
    lin.SetTarget(1, 0)

    trig.triggerAxis = 0
    trig.triggerType = TriggerType.RemainingDistance
    trig.triggerValue = 30

    ret = Wmx3Lib_cm.motion.StartLinearIntplPos_Trigger(lin, trig)
    if ret != 0:
        print('StartLinearIntplPos_Trigger error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until the first interpolation completes before setting trigger for third interpolation
    while True:
        # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
        ret, CmStatus = Wmx3Lib_cm.GetStatus()
        if (CmStatus.GetAxesStatus(0).commandReady == 1):
            break
        sleep(0.1)

    lin.SetTarget(0, 300)
    lin.SetTarget(1, 100)

    ret = Wmx3Lib_cm.motion.StartLinearIntplPos_Trigger(lin, trig)
    if ret != 0:
        print('StartLinearIntplPos_Trigger error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until the second interpolation completes before setting trigger for fourth interpolation
    while True:
        # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
        ret, CmStatus = Wmx3Lib_cm.GetStatus()
        if (CmStatus.GetAxesStatus(0).commandReady == 1):
            break
        sleep(0.1)

    lin.SetTarget(0, 400)
    lin.SetTarget(1, 0)

    ret = Wmx3Lib_cm.motion.StartLinearIntplPos_Trigger(lin, trig)
    if ret != 0:
        print('StartLinearIntplPos_Trigger error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until the third interpolation completes before setting trigger for fifth interpolation
    while True:
        # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
        ret, CmStatus = Wmx3Lib_cm.GetStatus()
        if (CmStatus.GetAxesStatus(0).commandReady == 1):
            break
        sleep(0.1)

    lin.SetTarget(0, 500)
    lin.SetTarget(1, 100)

    ret = Wmx3Lib_cm.motion.StartLinearIntplPos_Trigger(lin, trig)
    if ret != 0:
        print('StartLinearIntplPos_Trigger error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait for the motion to complete. Start a blocking wait command, returning only when Axis 0 and Axis 1 become idle.
    axisSel = AxisSelection()
    axisSel.axisCount = 2
    axisSel.SetAxis(0, 0)
    axisSel.SetAxis(1, 1)
    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axisSel)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    


#``



# Write python code to Execute a sequence of moving position command with blocking wait command.The moving distance of Axis 0 is 100, -100 and 100 with blocking wait.
    # Axes = [0]

    pos = Motion_PosCommand()

    # Set position command parameters
    pos.axis = 0
    pos.profile.type = ProfileType.Trapezoidal
    pos.profile.velocity = 1000
    pos.profile.acc = 10000
    pos.profile.dec = 10000

    # Execute motion to move axis forward 100
    pos.target = 100

    ret = Wmx3Lib_cm.motion.StartMov(pos)
    if ret != 0:
        print('StartMov error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until motion is finishedmoving 
    ret = Wmx3Lib_cm.motion.Wait(0)
    if ret != 0:
        print('Wait error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Execute motion to move axis backward 100
    pos.target = -100
    ret = Wmx3Lib_cm.motion.StartMov(pos)
    if ret != 0:
        print('StartMov error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until motion is finished
    ret = Wmx3Lib_cm.motion.Wait(0)
    if ret != 0:
        print('Wait error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Execute motion to move axis forward 100
    pos.target = 100
    ret = Wmx3Lib_cm.motion.StartMov(pos)
    if ret != 0:
        print('StartMov error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until motion is finished
    ret = Wmx3Lib_cm.motion.Wait(0)
    if ret != 0:
        print('Wait error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    
    

#``



# Write python code to Execute a sequence of motion commands using trigger motion functions and Wait functions.Move Axis 0 as 100 distance with 1000 velocity, and trigger it to move as -100 distance when the remaining time is 0, and then move as 200 distance, and -200 distance after waiting it to be overridable.
    # Axes = [0]

    pos = Motion_PosCommand()
    tpos = Motion_TriggerPosCommand()
    wait = Motion_WaitCondition()

    # Set position command parameters
    pos.axis = 0
    pos.profile.type = ProfileType.Trapezoidal;
    pos.profile.velocity = 1000
    pos.profile.acc = 10000
    pos.profile.dec = 10000

    # Set triggered position command parameters
    tpos.axis = 0
    tpos.profile.type = ProfileType.Trapezoidal
    tpos.profile.velocity = 1000
    tpos.profile.acc = 10000
    tpos.profile.dec = 10000
    tpos.trigger.triggerAxis = 0
    tpos.trigger.triggerType = TriggerType.RemainingTime
    tpos.trigger.triggerValue = 0

    # Set wait condition parameters, waiting Axis 0 to be overridable.
    wait.waitConditionType = Motion_WaitConditionType.MotionStartedOverrideReady
    wait.axisCount = 1
    wait.SetAxis(0, 0)

    # Execute motion to move axis forward 100
    pos.target = 100

    ret = Wmx3Lib_cm.motion.StartMov(pos)
    if ret != 0:
        print('StartMov error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Execute trigger motion to move axis backward 100 at the end of the previous motion
    tpos.target = -100

    ret = Wmx3Lib_cm.motion.StartMov_Trigger(tpos)
    if ret != 0:
        print('StartMov_Trigger error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until trigger motion executes
    ret = Wmx3Lib_cm.motion.Wait_WaitCondition(wait)
    if ret != 0:
        print('Wait_WaitCondition error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Execute trigger motion to move axis forward 200 at the end of the previous motion
    tpos.target = 200

    ret = Wmx3Lib_cm.motion.StartMov_Trigger(tpos)
    if ret != 0:
        print('StartMov_Trigger error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until trigger motion executes
    ret = Wmx3Lib_cm.motion.Wait_WaitCondition(wait)
    if ret != 0:
        print('Wait_WaitCondition error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Execute trigger motion to move axis backward 20000 at the end of the previous motion
    tpos.target = -200
    ret = Wmx3Lib_cm.motion.StartMov_Trigger(tpos)
    if ret != 0:
        print('StartMov_Trigger error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until motion is finished
    ret = Wmx3Lib_cm.motion.Wait(0)
    if ret != 0:
        print('Wait error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    


#``



# Write python code to Execute a sequence of motion commands using trigger motion functions and Wait functions. Move Axis 0 to position 180 with 20 velocity, and trigger the velocity override to 40, 60, 40, and 20 respectively when the completed time is 1s.
    # Axes = [0]

    pos = Motion_PosCommand()
    tpos = Motion_TriggerPosCommand()
    wait = Motion_WaitCondition()

    # Set position command parameters
    pos.axis = 0
    pos.profile.type = ProfileType.Trapezoidal
    pos.profile.acc = 1000
    pos.profile.dec = 1000
    pos.target = 180

    # Set triggered position command parameters
    tpos.axis = 0
    tpos.profile.type = ProfileType.Trapezoidal
    tpos.profile.acc = 1000
    tpos.profile.dec = 1000
    tpos.trigger.triggerAxis = 0
    tpos.trigger.triggerType = TriggerType.CompletedTime
    tpos.trigger.triggerValue = 1000
    tpos.target = 180

    # Set wait condition parameters
    wait.waitConditionType = Motion_WaitConditionType.MotionStartedOverrideReady
    wait.axisCount = 1
    wait.SetAxis(0, 0)

    # Execute motion to move axis forward 20
    pos.profile.velocity = 20

    ret = Wmx3Lib_cm.motion.StartPos(pos)
    if ret != 0:
        print('StartPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Execute trigger motion to change axis velocity
    tpos.profile.velocity = 40

    ret = Wmx3Lib_cm.motion.StartPos_Trigger(tpos)
    if ret != 0:
        print('StartPos_Trigger error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until trigger motion executes
    ret = Wmx3Lib_cm.motion.Wait_WaitCondition(wait)
    if ret != 0:
        print('Wait_WaitCondition error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Execute trigger motion to change axis velocity
    tpos.profile.velocity = 60

    ret = Wmx3Lib_cm.motion.StartPos_Trigger(tpos)
    if ret != 0:
        print('StartPos_Trigger error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until trigger motion executes
    ret = Wmx3Lib_cm.motion.Wait_WaitCondition(wait)
    if ret != 0:
        print('Wait_WaitCondition error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Execute trigger motion to change axis velocity
    tpos.profile.velocity = 40

    ret = Wmx3Lib_cm.motion.StartPos_Trigger(tpos)
    if ret != 0:
        print('StartPos_Trigger error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until trigger motion executes
    ret = Wmx3Lib_cm.motion.Wait_WaitCondition(wait)
    if ret != 0:
        print('Wait_WaitCondition error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Execute trigger motion to change axis velocity
    tpos.profile.velocity = 20
    ret = Wmx3Lib_cm.motion.StartPos_Trigger(tpos)
    if ret != 0:
        print('StartPos_Trigger error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until motion is finished
    ret = Wmx3Lib_cm.motion.Wait(0)
    if ret != 0:
        print('Wait error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    


#``



# Write python code to Execute a sequence of linear interpolation commands using trigger motion functions and Wait functions. Control Axis 0 and Axis 1 to linearly interpolate to (100, 0) at a velocity of 500，and then trigger Axis 0 and Axis 1 to linearly interpolate to (100, 100), (0, 100) and (0, 0) respectively when the remaining distance is 20.
    # Axes = [0, 1]

    lin = Motion_LinearIntplCommand()
    trig = Trigger()
    wait = Motion_WaitCondition()

    # Set interpolation command parameters
    lin.axisCount = 2
    lin.SetAxis(0, 0)
    lin.SetAxis(1, 1)

    lin.profile.type = ProfileType.Trapezoidal
    lin.profile.velocity = 500
    lin.profile.acc = 10000
    lin.profile.dec = 10000

    # Set trigger parameters (trigger at 2000 remaining distance)
    trig.triggerAxis = 0
    trig.triggerType = TriggerType.RemainingDistance
    trig.triggerValue = 20

    # Set wait condition parameters
    wait.waitConditionType = Motion_WaitConditionType.MotionStartedOverrideReady
    wait.axisCount = 1
    wait.SetAxis(0, 0)

    # Execute linear interpolation to position (100, 0)
    lin.SetTarget(0, 100)
    lin.SetTarget(1, 0)

    ret = Wmx3Lib_cm.motion.StartLinearIntplPos(lin)
    if ret != 0:
        print('StartLinearIntplPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Execute trigger linear interpolation to position (100, 100)
    sleep(0.001)
    lin.SetTarget(0, 100)
    lin.SetTarget(1, 100)

    ret = Wmx3Lib_cm.motion.StartLinearIntplPos_Trigger(lin, trig)
    if ret != 0:
        print('StartLinearIntplPos_Trigger error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until trigger motion executes
    ret = Wmx3Lib_cm.motion.Wait_WaitCondition(wait)
    if ret != 0:
        print('Wait_WaitCondition error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Execute trigger linear interpolation to position (0, 100)
    lin.SetTarget(0, 0)
    lin.SetTarget(1, 100)

    ret = Wmx3Lib_cm.motion.StartLinearIntplPos_Trigger(lin, trig)
    if ret != 0:
        print('StartLinearIntplPos_Trigger error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until trigger motion executes
    ret = Wmx3Lib_cm.motion.Wait_WaitCondition(wait)
    if ret != 0:
        print('Wait_WaitCondition error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Execute trigger linear interpolation to position (0, 0)
    lin.SetTarget(0, 0)
    lin.SetTarget(1, 0)

    ret = Wmx3Lib_cm.motion.StartLinearIntplPos_Trigger(lin, trig)
    if ret != 0:
        print('StartLinearIntplPos_Trigger error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait for the motion to complete. Start a blocking wait command, returning only when Axis 0 and Axis 1 become idle.
    axisSel = AxisSelection()
    axisSel.axisCount = 2
    axisSel.SetAxis(0, 0)
    axisSel.SetAxis(1, 1)
    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axisSel)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    


#``



# Write python code to Execute a simple PVT command of Axis 0 consisting of five points as a format of (Position, Velocity, Time): (0,0,0),(55,1000,100),(205,2000,200),(450,3000,300),(600,0,400)
    # Axes = [0]

    pvt = Motion_PVTCommand()
    pvtparameter = Motion_PVTPoint()

    pvt.axis = 0
    pvt.pointCount = 5

    # Define point data
    pvtparameter.pos = 0
    pvtparameter.velocity = 0
    pvtparameter.timeMilliseconds = 0
    pvt.SetPoints(0, pvtparameter)

    pvtparameter.pos = 55
    pvtparameter.velocity = 1000
    pvtparameter.timeMilliseconds = 100
    pvt.SetPoints(1, pvtparameter)

    pvtparameter.pos = 205
    pvtparameter.velocity = 2000
    pvtparameter.timeMilliseconds = 200
    pvt.SetPoints(2, pvtparameter)

    pvtparameter.pos = 450
    pvtparameter.velocity = 3000
    pvtparameter.timeMilliseconds = 300
    pvt.SetPoints(3, pvtparameter)

    pvtparameter.pos = 600
    pvtparameter.velocity = 0
    pvtparameter.timeMilliseconds = 400
    pvt.SetPoints(4, pvtparameter)

    # Start PVT motion
    ret = Wmx3Lib_cm.motion.StartPVT(pvt)
    if ret != 0:
        print('StartPVT error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until motion is finished
    ret = Wmx3Lib_cm.motion.Wait(0)
    if ret != 0:
        print('Wait error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    


#``



# Write python code to Execute a PVT interpolation command of Axis 0 and Axis 1 of 4 points as a format of (Position0, Velocity0, Time0, Position1, Velocity1, Time1): (0,0,0,0,0,0),(50,1000,100,100,2000,100),(100,2000,200,250,1000,200),(200,0,300,300,0,300)
    # Axes = [0, 1]

    pvti = Motion_PVTIntplCommand()

    pvtparameter0 = Motion_PVTPoint()
    pvtparameter1 = Motion_PVTPoint()

    pvti.axisCount = 2
    pvti.SetAxis(0, 0)
    pvti.SetAxis(1, 1)
    pvti.SetPointCount(0, 4)
    pvti.SetPointCount(1, 4)

    # Define point data
    pvtparameter0.pos = 0
    pvtparameter0.velocity = 0
    pvtparameter0.timeMilliseconds = 0
    pvtparameter1.pos = 0
    pvtparameter1.velocity = 0
    pvtparameter1.timeMilliseconds = 0
    pvti.SetPoints(0, 0, pvtparameter0)
    pvti.SetPoints(1, 0, pvtparameter1)

    pvtparameter0.pos = 50
    pvtparameter0.velocity = 1000
    pvtparameter0.timeMilliseconds = 100
    pvtparameter1.pos = 100
    pvtparameter1.velocity = 2000
    pvtparameter1.timeMilliseconds = 100
    pvti.SetPoints(0, 1, pvtparameter0)
    pvti.SetPoints(1, 1, pvtparameter1)

    pvtparameter0.pos = 100
    pvtparameter0.velocity = 2000
    pvtparameter0.timeMilliseconds = 200
    pvtparameter1.pos = 250
    pvtparameter1.velocity = 1000
    pvtparameter1.timeMilliseconds = 200
    pvti.SetPoints(0, 2, pvtparameter0)
    pvti.SetPoints(1, 2, pvtparameter1)

    pvtparameter0.pos = 200
    pvtparameter0.velocity = 0
    pvtparameter0.timeMilliseconds = 300
    pvtparameter1.pos = 300
    pvtparameter1.velocity = 0
    pvtparameter1.timeMilliseconds = 300
    pvti.SetPoints(0, 3, pvtparameter0)
    pvti.SetPoints(1, 3, pvtparameter1)


    ret = Wmx3Lib_cm.motion.StartPVT_Intpl(pvti)
    if ret != 0:
        print('StartPVT_Intpl error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    
    # Wait for the motion to complete. Start a blocking wait command, returning only when Axis 0 and Axis 1 become idle.
    axisSel = AxisSelection()
    axisSel.axisCount = 2
    axisSel.SetAxis(0, 0)
    axisSel.SetAxis(1, 1)
    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axisSel)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    

#``



# Write python code to Execute a PT (Position-Time) command of Axis 0 of 6 points: (0,0),(100,500),(160,1000),(200,1500),(260,2000),(300,2500)
    # Axes = [0]

    pt = Motion_PTCommand()
    ptparameter = Motion_PTPoint()

    pt.axis = 0
    pt.pointCount = 6

    # Define point data
    ptparameter.pos = 0
    ptparameter.timeMilliseconds = 0
    pt.SetPoints(0, ptparameter)

    ptparameter.pos = 100
    ptparameter.timeMilliseconds = 500
    pt.SetPoints(1, ptparameter)

    ptparameter.pos = 160
    ptparameter.timeMilliseconds = 1000
    pt.SetPoints(2, ptparameter)

    ptparameter.pos = 200
    ptparameter.timeMilliseconds = 1500
    pt.SetPoints(3, ptparameter)

    ptparameter.pos = 260
    ptparameter.timeMilliseconds = 2000
    pt.SetPoints(4, ptparameter)

    ptparameter.pos = 300
    ptparameter.timeMilliseconds = 2500
    pt.SetPoints(5, ptparameter)

    ret = Wmx3Lib_cm.motion.StartPT(pt)
    if ret != 0:
        print('StartPT error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until motion is finished
    ret = Wmx3Lib_cm.motion.Wait(0)
    if ret != 0:
        print('Wait error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    



#``



# Write python code to Execute a VT (Velocity-Time) command of Axis 0 of 6 points: (0,0),(100,500),(200,1000),(300,1500),(400,2000),(500,2500)
    # Axes = [0]

    vt = Motion_VTCommand()
    vtparameter = Motion_VTPoint()

    vt.axis = 0
    vt.pointCount = 6

    # Define point data
    vtparameter.velocity = 0
    vtparameter.timeMilliseconds = 0
    vt.SetPoints(0, vtparameter)

    vtparameter.velocity = 100
    vtparameter.timeMilliseconds = 500
    vt.SetPoints(1, vtparameter)

    vtparameter.velocity = 200
    vtparameter.timeMilliseconds = 1000
    vt.SetPoints(2, vtparameter)

    vtparameter.velocity = 300
    vtparameter.timeMilliseconds = 1500
    vt.SetPoints(3, vtparameter)

    vtparameter.velocity = 400
    vtparameter.timeMilliseconds = 2000
    vt.SetPoints(4, vtparameter)

    vtparameter.velocity = 500
    vtparameter.timeMilliseconds = 2500
    vt.SetPoints(5, vtparameter)

    ret = Wmx3Lib_cm.motion.StartVT(vt)
    if ret != 0:
        print('StartVT error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until motion is finished
    ret = Wmx3Lib_cm.motion.Wait(0)
    if ret != 0:
        print('Wait error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    


#``



# Write python code to Execute anw AT (Acceleration-Time) command of Axis 0 of 7 points: (0,0),(100,500),(100,1000),(-100,1500),(100,2000),(-100,2500),(-100,3000)
    # Axes = [0]

    at = Motion_ATCommand()
    atparameter = Motion_ATPoint()

    at.axis = 0
    at.pointCount = 7

    # Define point data
    atparameter.acc = 0
    atparameter.timeMilliseconds = 0
    at.SetPoints(0, atparameter)

    atparameter.acc = 100
    atparameter.timeMilliseconds = 500
    at.SetPoints(1, atparameter)

    atparameter.acc = 100
    atparameter.timeMilliseconds = 1000
    at.SetPoints(2, atparameter)

    atparameter.acc = -100
    atparameter.timeMilliseconds = 1500
    at.SetPoints(3, atparameter)

    atparameter.acc = 100
    atparameter.timeMilliseconds = 2000
    at.SetPoints(4, atparameter)

    atparameter.acc = -100
    atparameter.timeMilliseconds = 2500
    at.SetPoints(5, atparameter)

    atparameter.acc = -100
    atparameter.timeMilliseconds = 3000
    at.SetPoints(6, atparameter)

    ret = Wmx3Lib_cm.motion.StartAT(at)
    if ret != 0:
        print('StartAT error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until motion is finished
    ret = Wmx3Lib_cm.motion.Wait(0)
    if ret != 0:
        print('Wait error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    


#``



# Write python code to Execute a total time(1s) type cubic spline of Axis 0 and Axis 1 with 9 points: (0,0),(100,0),(50,50),(100,100),(100,150),(0,150),(0,100),(50,50),(0,0).
    # Axes = [0, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    ret = Wmx3Lib_adv.advMotion.FreeSplineBuffer(0)

    # Create the spline channel buffer
    ret = Wmx3Lib_adv.advMotion.CreateSplineBuffer(0, 100)
    if ret != 0:
        print('CreateSplineBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Set the spline command options
    spl = AdvMotion_TotalTimeSplineCommand()

    spl.dimensionCount = 2
    spl.SetAxis(0, 0)
    spl.SetAxis(1, 1)
    spl.totalTimeMilliseconds = 1000

    pt = []

    pt.append(AdvMotion_SplinePoint())
    pt[0].SetPos(0, 0)
    pt[0].SetPos(1, 0)

    pt.append(AdvMotion_SplinePoint())
    pt[1].SetPos(0, 100)
    pt[1].SetPos(1, 0)

    pt.append(AdvMotion_SplinePoint())
    pt[2].SetPos(0, 50)
    pt[2].SetPos(1, 50)

    pt.append(AdvMotion_SplinePoint())
    pt[3].SetPos(0, 100)
    pt[3].SetPos(1, 100)

    pt.append(AdvMotion_SplinePoint())
    pt[4].SetPos(0, 100)
    pt[4].SetPos(1, 150)

    pt.append(AdvMotion_SplinePoint())
    pt[5].SetPos(0, 0)
    pt[5].SetPos(1, 150)

    pt.append(AdvMotion_SplinePoint())
    pt[6].SetPos(0, 0)
    pt[6].SetPos(1, 100)

    pt.append(AdvMotion_SplinePoint())
    pt[7].SetPos(0, 50)
    pt[7].SetPos(1, 50)

    pt.append(AdvMotion_SplinePoint())
    pt[8].SetPos(0, 0)
    pt[8].SetPos(1, 0)

    # Execute the spline command
    ret = Wmx3Lib_adv.advMotion.StartCSplinePos_TotalTime(0, spl, 9, pt)
    if ret != 0:
        print('StartCSplinePos_TotalTime error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the spline motion to complete
    axes = AxisSelection()
    axes.axisCount = 2
    axes.SetAxis(0, 0)
    axes.SetAxis(1, 1)

    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axes)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Free the spline buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreeSplineBuffer(0)
    if ret != 0:
        print('FreeSplineBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return
    
    sleep(0.5)




#``



# Write python code to Execute a trapezoidal profile type cubic spline of Axis 0 and Axis 1 with 9 points and the velocity is 1000: (0,0),(100,0),(50,50),(100,100),(100,150),(0,150),(0,100),(50,50),(0,0).
    # Axes = [0, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)
    ret = Wmx3Lib_adv.advMotion.FreeSplineBuffer(0)
        
    # Create the spline channel buffer
    ret = Wmx3Lib_adv.advMotion.CreateSplineBuffer(0, 100)
    if ret != 0:
        print('CreateSplineBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    sleep(0.001)
    # Set the spline command options
    spl = AdvMotion_ProfileSplineCommand()
    spl.dimensionCount = 2
    spl.SetAxis(0, 0)
    spl.SetAxis(1, 1)
    spl.profile = Profile()
    spl.profile.type = ProfileType.Trapezoidal
    spl.profile.velocity = 1000
    spl.profile.acc = 10000
    spl.profile.dec = 10000

    pt = []

    pt.append(AdvMotion_SplinePoint())
    pt[0].SetPos(0, 0)
    pt[0].SetPos(1, 0)

    pt.append(AdvMotion_SplinePoint())
    pt[1].SetPos(0, 100)
    pt[1].SetPos(1, 0)

    pt.append(AdvMotion_SplinePoint())
    pt[2].SetPos(0, 50)
    pt[2].SetPos(1, 50)

    pt.append(AdvMotion_SplinePoint())
    pt[3].SetPos(0, 100)
    pt[3].SetPos(1, 100)

    pt.append(AdvMotion_SplinePoint())
    pt[4].SetPos(0, 100)
    pt[4].SetPos(1, 150)

    pt.append(AdvMotion_SplinePoint())
    pt[5].SetPos(0, 0)
    pt[5].SetPos(1, 150)

    pt.append(AdvMotion_SplinePoint())
    pt[6].SetPos(0, 0)
    pt[6].SetPos(1, 100)

    pt.append(AdvMotion_SplinePoint())
    pt[7].SetPos(0, 50)
    pt[7].SetPos(1, 50)

    pt.append(AdvMotion_SplinePoint())
    pt[8].SetPos(0, 0)
    pt[8].SetPos(1, 0)

    # Execute the spline command
    ret = Wmx3Lib_adv.advMotion.StartCSplinePos_Profile(0, spl, 9, pt)
    if ret != 0:
        print('StartCSplinePos_Profile error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the spline motion to complete
    axes = AxisSelection()
    axes.axisCount = 2
    axes.SetAxis(0, 0)
    axes.SetAxis(1, 1)

    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axes)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Free the spline buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreeSplineBuffer(0)
    if ret != 0:
        print('FreeSplineBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return
    
    sleep(0.5)


#``



# Write python code to Execute a velocity and acceleration limited cubic spline of Axis 0 and Axis 1 with 9 points and the velocity limit of Axis 0 and Axis 1 is 400 and 300, and the acceleration limit of Axis 0 and Axis 1 is 4000 and 3000, and the composite velocity and acceleration is 1000 and 10000: (0,0),(100,0),(50,50),(100,100),(100,150),(0,150),(0,100),(50,50),(0,0).
    # Axes = [0, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)
    ret = Wmx3Lib_adv.advMotion.FreeSplineBuffer(0)
        
    # Create the spline channel buffer
    ret = Wmx3Lib_adv.advMotion.CreateSplineBuffer(0, 200)
    if ret != 0:
        print('CreateSplineBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    sleep(0.001)
    # Set the spline command options
    spl = AdvMotion_VelAccLimitedSplineCommand()
    spl.dimensionCount = 2
    spl.SetAxis(0, 0)
    spl.SetAxis(1, 1)
    spl.SetVelLimit(0, 400)
    spl.SetVelLimit(1, 300)
    spl.SetAccLimit(0, 4000)
    spl.SetAccLimit(1, 3000)
    spl.compositeVel = 1000
    spl.compositeAcc = 10000
    # As with profile type splines, the sampleMultiplier parameter can be increased to improve the accuracy and granularity of the generated velocity and acceleration profile. The sampleMultiplier should be especially increased for point data with a relatively small number of points and a large distance between points. Increasing the sampleMultiplier will not change the shape of the spline trajectory.
    spl.sampleMultiplier = 20

    # Set the spline point data
    pt = []

    pt.append(AdvMotion_SplinePoint())
    pt[0].SetPos(0, 0)
    pt[0].SetPos(1, 0)

    pt.append(AdvMotion_SplinePoint())
    pt[1].SetPos(0, 100)
    pt[1].SetPos(1, 0)

    pt.append(AdvMotion_SplinePoint())
    pt[2].SetPos(0, 50)
    pt[2].SetPos(1, 50)

    pt.append(AdvMotion_SplinePoint())
    pt[3].SetPos(0, 100)
    pt[3].SetPos(1, 100)

    pt.append(AdvMotion_SplinePoint())
    pt[4].SetPos(0, 100)
    pt[4].SetPos(1, 150)

    pt.append(AdvMotion_SplinePoint())
    pt[5].SetPos(0, 0)
    pt[5].SetPos(1, 150)

    pt.append(AdvMotion_SplinePoint())
    pt[6].SetPos(0, 0)
    pt[6].SetPos(1, 100)

    pt.append(AdvMotion_SplinePoint())
    pt[7].SetPos(0, 50)
    pt[7].SetPos(1, 50)

    pt.append(AdvMotion_SplinePoint())
    pt[8].SetPos(0, 0)
    pt[8].SetPos(1, 0)

    # Execute the spline command
    ret = Wmx3Lib_adv.advMotion.StartCSplinePos_VelAccLimited(0, spl, 9, pt)

    if ret != 0:
        print('StartCSplinePos_PointTime error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the spline motion to complete
    axes = AxisSelection()
    axes.axisCount = 2
    axes.SetAxis(0, 0)
    axes.SetAxis(1, 1)
    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axes)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Free the spline buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreeSplineBuffer(0)
    if ret != 0:
        print('FreeSplineBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return
    
    sleep(0.5)



#``



# Write python code to Execute an absolute position path interpolation motion command of Axis 0 and 1 with velocity 1000. The 1st segment is a linear interpolation to position (100, 0), the 2nd segment is a clockwise circular interpolation to position (150, 50) with center point (100, 50), the 3rd segment is a linear interpolation to position (150, 100), the 4th segment is a clockwise circular interpolation to position (100, 150) with center point (100, 100), the 5th segment is a linear interpolation to position (0, 150), the 6th segment is a clockwise circular interpolation to position (-50, 100) with center point (0, 100), the 7th segment is a linear interpolation to position (-50, 50), the 8th segment is a clockwise circular interpolation to position (0, 0) with center point (0, 50).
    # Axes = [0, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplCommand()

    path.SetAxis(0, 0)
    path.SetAxis(1, 1)

    # Use single motion profile for entire path
    path.enableConstProfile = 1
    
    path.profile = Profile()
    path.profile.type = ProfileType.Trapezoidal
    path.profile.velocity = 1000
    path.profile.acc = 10000
    path.profile.dec = 10000

    # Define linear and circular segments
    path.numPoints = 8

    path.SetType(0, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 0, 100)
    path.SetTarget(1, 0, 0)

    path.SetType(1, AdvMotion_PathIntplSegmentType.Circular)
    path.SetTarget(0, 1, 150)
    path.SetTarget(1, 1, 50)
    path.SetCenterPos(0, 1, 100)
    path.SetCenterPos(1, 1, 50)
    path.SetDirection(1, 1)

    path.SetType(2, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 2, 150)
    path.SetTarget(1, 2, 100)

    path.SetType(3, AdvMotion_PathIntplSegmentType.Circular)
    path.SetTarget(0, 3, 100)
    path.SetTarget(1, 3, 150)
    path.SetCenterPos(0, 3, 100)
    path.SetCenterPos(1, 3, 100)
    path.SetDirection(3, 1)

    path.SetType(4, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 4, 0)
    path.SetTarget(1, 4, 150)

    path.SetType(5, AdvMotion_PathIntplSegmentType.Circular)
    path.SetTarget(0, 5, -50)
    path.SetTarget(1, 5, 100)
    path.SetCenterPos(0, 5, 0)
    path.SetCenterPos(1, 5, 100)
    path.SetDirection(5, 1)

    path.SetType(6, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 6, -50)
    path.SetTarget(1, 6, 50)

    path.SetType(7, AdvMotion_PathIntplSegmentType.Circular)
    path.SetTarget(0, 7, 0)
    path.SetTarget(1, 7, 0)
    path.SetCenterPos(0, 7, 0)
    path.SetCenterPos(1, 7, 50)
    path.SetDirection(7, 1)


    ret = Wmx3Lib_adv.advMotion.StartPathIntplPos(path)
    if ret != 0:
        print('StartPathIntplPos error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the spline motion to complete
    axes = AxisSelection()
    axes.axisCount = 2
    axes.SetAxis(0, 0)
    axes.SetAxis(1, 1)
    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axes)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return



#``



# Write python code to Execute an absolute position path interpolation motion command of Axis 0 and 1. The 1st segment is a linear interpolation to position (100, 0) with velocity 1000, the 2nd segment is a clockwise circular interpolation to position (150, 50) with center point (100, 50) with velocity 900, the 3rd segment is a linear interpolation to position (150, 100) with velocity 800, the 4th segment is a clockwise circular interpolation to position (100, 150) with center point (100, 100) with velocity 700, the 5th segment is a linear interpolation to position (0, 150) with velocity 600, the 6th segment is a clockwise circular interpolation to position (-50, 100) with center point (0, 100) with velocity 700, the 7th segment is a linear interpolation to position (-50, 50) with velocity 800, the 8th segment is a clockwise circular interpolation to position (0, 0) with center point (0, 50) with velocity 900. 
    # Axes = [0, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplCommand()

    path.SetAxis(0, 0)
    path.SetAxis(1, 1)

    # Specify motion profile for each segment
    path.enableConstProfile = 0

    # Define linear and circular segments
    path.numPoints = 8

    path.SetType(0, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 0, 100)
    path.SetTarget(1, 0, 0)

    profile = Profile()
    profile.type = ProfileType.Trapezoidal
    profile.velocity = 1000
    profile.acc = 10000
    profile.dec = 10000
    path.SetProfile(0, profile)

    path.SetType(1, AdvMotion_PathIntplSegmentType.Circular)
    path.SetTarget(0, 1, 150)
    path.SetTarget(1, 1, 50)
    path.SetCenterPos(0, 1, 100)
    path.SetCenterPos(1, 1, 50)
    path.SetDirection(1, 1)

    profile = Profile()
    profile.type = ProfileType.Trapezoidal
    profile.velocity = 900
    profile.acc = 10000
    profile.dec = 10000
    path.SetProfile(1, profile)

    path.SetType(2, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 2, 150)
    path.SetTarget(1, 2, 100)

    profile = Profile()
    profile.type = ProfileType.Trapezoidal
    profile.velocity = 800
    profile.acc = 10000
    profile.dec = 10000
    path.SetProfile(2, profile)

    path.SetType(3, AdvMotion_PathIntplSegmentType.Circular)
    path.SetTarget(0, 3, 100)
    path.SetTarget(1, 3, 150)
    path.SetCenterPos(0, 3, 100)
    path.SetCenterPos(1, 3, 100)
    path.SetDirection(3, 1)

    profile = Profile()
    profile.type = ProfileType.Trapezoidal
    profile.velocity = 700
    profile.acc = 10000
    profile.dec = 10000
    path.SetProfile(3, profile)

    path.SetType(4, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 4, 0)
    path.SetTarget(1, 4, 150)

    profile = Profile()
    profile.type = ProfileType.Trapezoidal
    profile.velocity = 600
    profile.acc = 10000
    profile.dec = 10000
    path.SetProfile(4, profile)

    path.SetType(5, AdvMotion_PathIntplSegmentType.Circular)
    path.SetTarget(0, 5, -50)
    path.SetTarget(1, 5, 100)
    path.SetCenterPos(0, 5, 0)
    path.SetCenterPos(1, 5, 100)
    path.SetDirection(5, 1)

    profile = Profile()
    profile.type = ProfileType.Trapezoidal
    profile.velocity = 700
    profile.acc = 10000
    profile.dec = 10000
    path.SetProfile(5, profile)

    path.SetType(6, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 6, -50)
    path.SetTarget(1, 6, 50)

    profile = Profile()
    profile.type = ProfileType.Trapezoidal
    profile.velocity = 800
    profile.acc = 10000
    profile.dec = 10000
    path.SetProfile(6, profile)

    path.SetType(7, AdvMotion_PathIntplSegmentType.Circular)
    path.SetTarget(0, 7, 0)
    path.SetTarget(1, 7, 0)
    path.SetCenterPos(0, 7, 0)
    path.SetCenterPos(1, 7, 50)
    path.SetDirection(5, 1)

    profile = Profile()
    profile.type = ProfileType.Trapezoidal
    profile.velocity = 900
    profile.acc = 10000
    profile.dec = 10000
    path.SetProfile(7, profile)

    ret = Wmx3Lib_adv.advMotion.StartPathIntplPos(path)
    if ret != 0:
        print('StartPathIntplPos error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the spline motion to complete
    axes = AxisSelection()
    axes.axisCount = 2
    axes.SetAxis(0, 0)
    axes.SetAxis(1, 1)
    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axes)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return




#``



# Write python code to Execute an absolute position path interpolation motion command of Axis 0 and 1 specifying the Motion Profile for Each Segment. The 1st segment is a linear interpolation to position (100, 0) with velocity and endvelocity 1000, the 2nd segment is a clockwise circular interpolation to position (150, 50) with center point (100, 50) with velocity and endvelocity 900, the 3rd segment is a linear interpolation to position (150, 100) with velocity and endvelocity 800, the 4th segment is a clockwise circular interpolation to position (100, 150) with center point (100, 100) with velocity and endvelocity 700, the 5th segment is a linear interpolation to position (0, 150) with velocity and endvelocity 600, the 6th segment is a clockwise circular interpolation to position (-50, 100) with center point (0, 100) with velocity and endvelocity 700, the 7th segment is a linear interpolation to position (-50, 50) with velocity and endvelocity 800, the 8th segment is a clockwise circular interpolation to position (0, 0) with center point (0, 50) with velocity 900. 
    # Axes = [0, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplCommand()

    path.SetAxis(0, 0)
    path.SetAxis(1, 1)

    # Specify motion profile for each segment
    path.enableConstProfile = 0

    # Define linear and circular segments
    path.numPoints = 8

    path.SetType(0, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 0, 100)
    path.SetTarget(1, 0, 0)

    profile = Profile()
    profile.type = ProfileType.Trapezoidal
    profile.velocity = 1000
    profile.acc = 10000
    profile.dec = 10000
    profile.endVelocity = 1000
    path.SetProfile(0, profile)

    path.SetType(1, AdvMotion_PathIntplSegmentType.Circular)
    path.SetTarget(0, 1, 150)
    path.SetTarget(1, 1, 50)
    path.SetCenterPos(0, 1, 100)
    path.SetCenterPos(1, 1, 50)
    path.SetDirection(1, 1)

    profile = Profile()
    profile.type = ProfileType.Trapezoidal
    profile.velocity = 900
    profile.acc = 10000
    profile.dec = 10000
    profile.endVelocity = 900
    path.SetProfile(1, profile)

    path.SetType(2, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 2, 150)
    path.SetTarget(1, 2, 100)

    profile = Profile()
    profile.type = ProfileType.Trapezoidal
    profile.velocity = 800
    profile.acc = 10000
    profile.dec = 10000
    profile.endVelocity = 800
    path.SetProfile(2, profile)

    path.SetType(3, AdvMotion_PathIntplSegmentType.Circular)
    path.SetTarget(0, 3, 100)
    path.SetTarget(1, 3, 150)
    path.SetCenterPos(0, 3, 100)
    path.SetCenterPos(1, 3, 100)
    path.SetDirection(3, 1)

    profile = Profile()
    profile.type = ProfileType.Trapezoidal
    profile.velocity = 700
    profile.acc = 10000
    profile.dec = 10000
    profile.endVelocity = 700
    path.SetProfile(3, profile)

    path.SetType(4, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 4, 0)
    path.SetTarget(1, 4, 150)

    profile = Profile()
    profile.type = ProfileType.Trapezoidal
    profile.velocity = 600
    profile.acc = 10000
    profile.dec = 10000
    profile.endVelocity = 600
    path.SetProfile(4, profile)

    path.SetType(5, AdvMotion_PathIntplSegmentType.Circular)
    path.SetTarget(0, 5, -50)
    path.SetTarget(1, 5, 100)
    path.SetCenterPos(0, 5, 0)
    path.SetCenterPos(1, 5, 100)
    path.SetDirection(5, 1)

    profile = Profile()
    profile.type = ProfileType.Trapezoidal
    profile.velocity = 700
    profile.acc = 10000
    profile.dec = 10000
    profile.endVelocity = 700
    path.SetProfile(5, profile)

    path.SetType(6, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 6, -50)
    path.SetTarget(1, 6, 50)

    profile = Profile()
    profile.type = ProfileType.Trapezoidal
    profile.velocity = 800
    profile.acc = 10000
    profile.dec = 10000
    profile.endVelocity = 800
    path.SetProfile(6, profile)

    path.SetType(7, AdvMotion_PathIntplSegmentType.Circular)
    path.SetTarget(0, 7, 0)
    path.SetTarget(1, 7, 0)
    path.SetCenterPos(0, 7, 0)
    path.SetCenterPos(1, 7, 50)
    path.SetDirection(5, 1)

    profile = Profile()
    profile.type = ProfileType.Trapezoidal
    profile.velocity = 900
    profile.acc = 10000
    profile.dec = 10000
    path.SetProfile(7, profile)

    ret = Wmx3Lib_adv.advMotion.StartPathIntplPos(path)
    if ret != 0:
        print('StartPathIntplPos error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the spline motion to complete
    axes = AxisSelection()
    axes.axisCount = 2
    axes.SetAxis(0, 0)
    axes.SetAxis(1, 1)
    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axes)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return




#``



# Write python code to Execute an absolute position path interpolation motion command of Axis 0 and 1 with auto smoothing and the velocity is 1000. The 1st segment is a linear interpolation to position (40, 100) with autoSmoothRadius 10, and the 2nd segment is a linear interpolation to position (80, 0) with autoSmoothRadius 20, and the 3rd segment is a linear interpolation to position (120, 100) with autoSmoothRadius 30, and the 4th segment is a linear interpolation to position (160, 0) with autoSmoothRadius 40, and the 5th segment is a linear interpolation to position (200, 100) with autoSmoothRadius 50, and the 6th segment is a linear interpolation to position (240, 0).
    # Axes = [0, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplCommand()

    path.SetAxis(0, 0)
    path.SetAxis(1, 1)

    # Use single motion profile for entire path
    path.enableConstProfile = 1
    profile = Profile()
    profile.type = ProfileType.Trapezoidal
    profile.velocity = 1000
    profile.acc = 10000
    profile.dec = 10000
    path.SetProfile(0, profile)

    # Auto smoothing
    path.enableAutoSmooth = 1

    # Define linear segments
    path.numPoints = 6

    path.SetType(0, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 0, 40)
    path.SetTarget(1, 0, 100)
    path.SetAutoSmoothRadius(0, 10)

    path.SetType(1, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 1, 80)
    path.SetTarget(1, 1, 0)
    path.SetAutoSmoothRadius(1, 20)

    path.SetType(2, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 2, 120)
    path.SetTarget(1, 2, 100)
    path.SetAutoSmoothRadius(2, 30)

    path.SetType(3, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 3, 160)
    path.SetTarget(1, 3, 0)
    path.SetAutoSmoothRadius(3, 40)

    path.SetType(4, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 4, 200)
    path.SetTarget(1, 4, 100)
    path.SetAutoSmoothRadius(4, 50)

    path.SetType(5, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 5, 240)
    path.SetTarget(1, 5, 0)

    ret = Wmx3Lib_adv.advMotion.StartPathIntplPos(path)
    if ret != 0:
        print('StartPathIntplPos error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the spline motion to complete
    axes = AxisSelection()
    axes.axisCount = 2
    axes.SetAxis(0, 0)
    axes.SetAxis(1, 1)
    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axes)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return



#``



# Write python code to Execute a 3D path interpolation of Axis 0, 1, and 2 with velocity 200. There are 21 segments. 1)Linear interpolation to (90,0,0); 2)Circular interpolation to (100,10,0) with center (97.071,10-7.071,0); 3)Linear interpolation to (100,90,0); 4)Circular interpolation to (90,100,0) with center (97.071,97.071,0); 5)Linear interpolation to (10,100,0); 6)Circular interpolation to (0,90,0) with center (10-7.071,97.071,0); 7)Linear interpolation to (0,0,0); 8)Linear interpolation to (90,0,0); 9)Circular interpolation to (100,0,-10) with center (97.071,0,-10+7.071); 10)Linear interpolation to (100,0,-90); 11)Circular interpolation to (90,0,-100) with center (97.071,0,-97.071); 12)Linear interpolation to (10,0,-100); 13)Circular interpolation to (0,0,-90) with center (10-7.071,0,-97.071); 14)Linear interpolation to (0,0,0); 15)Linear interpolation to (0,90,0);  16)Circular interpolation to (0,100,-10) with center (0,97.071,-10+7.071); 17)Linear interpolation to (0,100,-90); 18)Circular interpolation to (0,90,-100) with center (0,97.071,-97.071); 19)Linear interpolation to (0,10,-100); 20)Circular interpolation to (0,0,-90) with center (0,10-7.071,-97.071); 21)Linear interpolation to (0,0,0).
    # Axes = [0, 1, 2]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntpl3DCommand()

    path.SetAxis(0, 0)
    path.SetAxis(1, 1)
    path.SetAxis(2, 2)

    # Use single motion profile for entire path
    path.enableConstProfile = 1
    profile = Profile()
    profile.type = ProfileType.Trapezoidal
    profile.velocity = 200
    profile.acc = 2000
    profile.dec = 2000
    path.SetProfile(0, profile)

    # Define linear and circular segments
    path.numPoints = 21

    path.SetType(0, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 0, 90)
    path.SetTarget(1, 0, 0)
    path.SetTarget(2, 0, 0)

    path.SetType(1, AdvMotion_PathIntplSegmentType.Circular)
    path.SetTarget(0, 1, 100)
    path.SetTarget(1, 1, 10)
    path.SetTarget(2, 1, 0)
    path.SetCircleIntermediateTarget(0, 1, 97.071)
    path.SetCircleIntermediateTarget(1, 1, 10 - 7.071)
    path.SetCircleIntermediateTarget(2, 1, 0)

    path.SetType(2, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 2, 100)
    path.SetTarget(1, 2, 90)
    path.SetTarget(2, 2, 0)

    path.SetType(3, AdvMotion_PathIntplSegmentType.Circular)
    path.SetTarget(0, 3, 90)
    path.SetTarget(1, 3, 100)
    path.SetTarget(2, 3, 0)
    path.SetCircleIntermediateTarget(0, 3, 97.071)
    path.SetCircleIntermediateTarget(1, 3, 97.071)
    path.SetCircleIntermediateTarget(2, 3, 0)

    path.SetType(4, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 4, 10)
    path.SetTarget(1, 4, 100)
    path.SetTarget(2, 4, 0)

    path.SetType(5, AdvMotion_PathIntplSegmentType.Circular)
    path.SetTarget(0, 5, 0)
    path.SetTarget(1, 5, 90)
    path.SetTarget(2, 5, 0)
    path.SetCircleIntermediateTarget(0, 5, 10 - 7.071)
    path.SetCircleIntermediateTarget(1, 5, 97.071)
    path.SetCircleIntermediateTarget(2, 5, 0)

    path.SetType(6, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 6, 0)
    path.SetTarget(1, 6, 0)
    path.SetTarget(2, 6, 0)

    path.SetType(7, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 7, 90)
    path.SetTarget(1, 7, 0)
    path.SetTarget(2, 7, 0)

    path.SetType(8, AdvMotion_PathIntplSegmentType.Circular)
    path.SetTarget(0, 8, 100)
    path.SetTarget(1, 8, 0)
    path.SetTarget(2, 8, -10)
    path.SetCircleIntermediateTarget(0, 8, 97.071)
    path.SetCircleIntermediateTarget(1, 8, 0)
    path.SetCircleIntermediateTarget(2, 8, -(10 - 7.071))

    path.SetType(9, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 9, 100)
    path.SetTarget(1, 9, 0)
    path.SetTarget(2, 9, -90)

    path.SetType(10, AdvMotion_PathIntplSegmentType.Circular)
    path.SetTarget(0, 10, 90)
    path.SetTarget(1, 10, 0)
    path.SetTarget(2, 10, -100)
    path.SetCircleIntermediateTarget(0, 10, 97.071)
    path.SetCircleIntermediateTarget(1, 10, 0)
    path.SetCircleIntermediateTarget(2, 10, -97.071)

    path.SetType(11, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 11, 10)
    path.SetTarget(1, 11, 0)
    path.SetTarget(2, 11, -100)

    path.SetType(12, AdvMotion_PathIntplSegmentType.Circular)
    path.SetTarget(0, 12, 0)
    path.SetTarget(1, 12, 0)
    path.SetTarget(2, 12, -90)
    path.SetCircleIntermediateTarget(0, 12, 10 - 7.071)
    path.SetCircleIntermediateTarget(1, 12, 0)
    path.SetCircleIntermediateTarget(2, 12, -97.071)

    path.SetType(13, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 13, 0)
    path.SetTarget(1, 13, 0)
    path.SetTarget(2, 1, 0)

    path.SetType(14, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 14, 0)
    path.SetTarget(1, 14, 90)
    path.SetTarget(2, 14, 0)

    path.SetType(15, AdvMotion_PathIntplSegmentType.Circular)
    path.SetTarget(0, 15, 0)
    path.SetTarget(1, 15, 100)
    path.SetTarget(2, 15, -10)
    path.SetCircleIntermediateTarget(0, 15, 0)
    path.SetCircleIntermediateTarget(1, 15, 97.071)
    path.SetCircleIntermediateTarget(2, 15, -(10 - 7.071))

    path.SetType(16, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 16, 0)
    path.SetTarget(1, 16, 100)
    path.SetTarget(2, 16, -90)

    path.SetType(17, AdvMotion_PathIntplSegmentType.Circular)
    path.SetTarget(0, 17, 0)
    path.SetTarget(1, 17, 90)
    path.SetTarget(2, 17, -100)
    path.SetCircleIntermediateTarget(0, 17, 0)
    path.SetCircleIntermediateTarget(1, 17, 97.071)
    path.SetCircleIntermediateTarget(2, 17, -97.071)

    path.SetType(18, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 18, 0)
    path.SetTarget(1, 18, 10)
    path.SetTarget(2, 18, -100)

    path.SetType(19, AdvMotion_PathIntplSegmentType.Circular)
    path.SetTarget(0, 19, 0)
    path.SetTarget(1, 19, 0)
    path.SetTarget(2, 19, -90)
    path.SetCircleIntermediateTarget(0, 19, 0)
    path.SetCircleIntermediateTarget(1, 19, 10 - 7.071)
    path.SetCircleIntermediateTarget(2, 19, -97.071)

    path.SetType(20, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 20, 0)
    path.SetTarget(1, 20, 0)
    path.SetTarget(2, 20, 0)

    ret = Wmx3Lib_adv.advMotion.StartPathIntpl3DPos(path)
    if ret != 0:
        print('StartPathIntpl3DPos error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return
    

    # Wait for the spline motion to complete
    axes = AxisSelection()
    axes.axisCount = 3
    axes.SetAxis(0, 0)
    axes.SetAxis(1, 1)
    axes.SetAxis(2, 2)
    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axes)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return




#``



# Write python code to Execute a path interpolation with rotation sequence consisting of four linear interpolations of Axis 0 and 1 with a rotation Axis 2, and the velocity is 1000. Disable rotating the X and Y axes around the center of rotation. The center of rotation is (50,50). The positions of four linear interpolations are: (100,0),(100,100),(0,100),(0,0).
    # Axes = [0, 1, 2]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplWithRotationCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplWithRotationBuffer(0)
    # Create the path interpolation with rotation buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplWithRotationBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplWithRotationBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with rotation channel
    conf = AdvMotion_PathIntplWithRotationConfiguration()

    conf.SetAxis(0, 0)  # X axis
    conf.SetAxis(1, 1)  # Y axis
    conf.rotationalAxis = 2  # Rotational axis
    conf.SetCenterOfRotation(0, 50)  # X axis center of rotation position
    conf.SetCenterOfRotation(1, 50)  # Y axis center of rotation position

    # Rotational axis angle correction motion profile parameters
    conf.angleCorrectionProfile.type = ProfileType.Trapezoidal
    conf.angleCorrectionProfile.velocity = 900
    conf.angleCorrectionProfile.acc = 1800
    conf.angleCorrectionProfile.dec = 1800

    # Disable rotating the X and Y axes around the center of rotation when the rotational axis moves
    conf.disableXYRotationalMotion = 1

    ret = Wmx3Lib_adv.advMotion.SetPathIntplWithRotationConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplWithRotationConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Set Axis 2 to single-turn mode, single-turn encoder count 360. Single-turn mode is necessary for rotation axis in path interpolatioin with rotation function.
    ret=Wmx3Lib_cm.config.SetSingleTurn(2,True,360000)
    if ret != 0:
        print('SetSingleTurn error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Add the path interpolation with rotation commands
    path.numPoints = 4

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    profile = Profile()
    point.profile.type = ProfileType.Trapezoidal
    point.profile.velocity = 1000
    point.profile.acc = 2000
    point.profile.dec = 2000
    point.SetTarget(0, 100)
    point.SetTarget(1, 0)
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    profile = Profile()
    point.profile.type = ProfileType.Trapezoidal
    point.profile.velocity = 1000
    point.profile.acc = 2000
    point.profile.dec = 2000
    point.SetTarget(0, 100)
    point.SetTarget(1, 100)
    path.SetPoint(1, point)

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    profile = Profile()
    point.profile.type = ProfileType.Trapezoidal
    point.profile.velocity = 1000
    point.profile.acc = 2000
    point.profile.dec = 2000
    point.SetTarget(0, 0)
    point.SetTarget(1, 100)
    path.SetPoint(2, point)

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    profile = Profile()
    point.profile.type = ProfileType.Trapezoidal
    point.profile.velocity = 1000
    point.profile.acc = 2000
    point.profile.dec = 2000
    point.SetTarget(0, 0)
    point.SetTarget(1, 0)
    path.SetPoint(3, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplWithRotationCommand(0, path)
    if ret != 0:
        print('AddPathIntplWithRotationCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Execute path interpolation with rotation
    ret = Wmx3Lib_adv.advMotion.StartPathIntplWithRotation(0)

    if ret != 0:
        print('StartPathIntplWithRotation error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return
    Wmx3Lib_cm.motion.Wait(0)
    timeoutCounter = 0
    # Wait until the path interpolation with rotation is in Idle state
    pathStatus = AdvMotion_PathIntplWithRotationState()
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplWithRotationStatus(0)
    while True:
        if (pathStatus.state == AdvMotion_PathIntplWithRotationState.Idle):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplWithRotationStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplWithRotation Runuing timeout.!')
        return
    # Free the path interpolation with rotation buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplWithRotationBuffer(0)
    if ret != 0:
        print('FreePathIntplWithRotationBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    sleep(1)
    #Turn off Axis 2 single-turn mode.
    AxisParam=Config_AxisParam()
    ret,AxisParam =Wmx3Lib_cm.config.GetAxisParam()
    AxisParam.SetSingleTurnMode(2,False)

    ret,AxisParamError=Wmx3Lib_cm.config.SetAxisParam(AxisParam)
    if ret != 0:
        print('Close SingleTurnMode error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return



#``



# Write python code to Executes a path interpolation of Axis 0 and 1 with a rotation Axis 2, and the velocity is 100.  Sequence consisting of four linear interpolations and enable rotating the X and Y axes around the center of rotation. The center of rotation is (50,50). The positions of four linear interpolations are: (100,0),(100,100),(0,100),(0,0).
    # Axes = [0, 1, 2]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplWithRotationCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplWithRotationBuffer(0)
    # Create the path interpolation with rotation buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplWithRotationBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplWithRotationBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with rotation channel
    conf = AdvMotion_PathIntplWithRotationConfiguration()
    
    conf.SetAxis(0, 0)  # X axis
    conf.SetAxis(1, 1)  # Y axis
    conf.rotationalAxis = 2  # Rotational axis
    conf.SetCenterOfRotation(0, 50)  # X axis center of rotation position
    conf.SetCenterOfRotation(1, 50)  # Y axis center of rotation position

    # Rotational axis angle correction motion profile parameters
    conf.angleCorrectionProfile.type = ProfileType.Trapezoidal
    conf.angleCorrectionProfile.velocity = 200
    conf.angleCorrectionProfile.acc = 1800
    conf.angleCorrectionProfile.dec = 1800

    ret = Wmx3Lib_adv.advMotion.SetPathIntplWithRotationConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplWithRotationConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    #Set Axis 2 to single-turn mode, single-turn encoder count 360. Single-turn mode is necessary for rotation axis in path interpolatioin with rotation function.
    ret=Wmx3Lib_cm.config.SetSingleTurn(2,True,360000)
    if ret != 0:
        print('SetSingleTurn error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Add the path interpolation with rotation commands
    path.numPoints = 4

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    profile = Profile()
    point.profile.type = ProfileType.Trapezoidal
    point.profile.velocity = 100
    point.profile.acc = 2000
    point.profile.dec = 2000
    point.SetTarget(0, 100)
    point.SetTarget(1, 0)
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    profile = Profile()
    point.profile.type = ProfileType.Trapezoidal
    point.profile.velocity = 100
    point.profile.acc = 2000
    point.profile.dec = 2000
    point.SetTarget(0, 100)
    point.SetTarget(1, 100)
    path.SetPoint(1, point)

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    profile = Profile()
    point.profile.type = ProfileType.Trapezoidal
    point.profile.velocity = 100
    point.profile.acc = 2000
    point.profile.dec = 2000
    point.SetTarget(0, 0)
    point.SetTarget(1, 100)
    path.SetPoint(2, point)

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    profile = Profile()
    point.profile.type = ProfileType.Trapezoidal
    point.profile.velocity = 100
    point.profile.acc = 2000
    point.profile.dec = 2000
    point.SetTarget(0, 0)
    point.SetTarget(1, 0)
    path.SetPoint(3, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplWithRotationCommand(0, path)
    if ret != 0:
        print('AddPathIntplWithRotationCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Execute path interpolation with rotation
    ret = Wmx3Lib_adv.advMotion.StartPathIntplWithRotation(0)
    if ret != 0:
        print('StartPathIntplWithRotation error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    sleep(1)
    #Wmx3Lib_cm.motion.Wait(0)
    timeoutCounter = 0
    
    # Wait until the path interpolation with rotation is in Idle state
    pathStatus = AdvMotion_PathIntplWithRotationState()
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplWithRotationStatus(0)
    while True:
        if (pathStatus.state == AdvMotion_PathIntplWithRotationState.Idle):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplWithRotationStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplWithRotation Runuing timeout.!')
        return
    
    # Free the path interpolation with rotation buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplWithRotationBuffer(0)
    if ret != 0:
        print('FreePathIntplWithRotationBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    #Turn off Axis 2 single-turn mode.
    AxisParam=Config_AxisParam()
    ret,AxisParam =Wmx3Lib_cm.config.GetAxisParam()
    AxisParam.SetSingleTurnMode(2,False)

    ret,AxisParamError=Wmx3Lib_cm.config.SetAxisParam(AxisParam)
    if ret != 0:
        print('Close SingleTurnMode error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return



#``



# Write python code to Executes a path interpolation of Axis 0 and 1 with a rotation Axis 2 without stopping after executing each segment, and the velocity is 100. Sequence consisting of four linear interpolations and enable rotating the X and Y axes around the center of rotation. The center of rotation is (50,50). The positions of four linear interpolations are: (100,0),(100,100),(0,100),(0,0). Auto smoothing radius after 1st, 2nd and 3rd segment are 30, 20, 10.
    # Axes = [0, 1, 2]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplWithRotationCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplWithRotationBuffer(0)
    # Create the path interpolation with rotation buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplWithRotationBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplWithRotationBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with rotation channel
    conf = AdvMotion_PathIntplWithRotationConfiguration()

    conf.SetAxis(0, 0)  # X axis
    conf.SetAxis(1, 1)  # Y axis
    conf.rotationalAxis = 2  # Rotational axis
    conf.SetCenterOfRotation(0, 50)  # X axis center of rotation position
    conf.SetCenterOfRotation(1, 50)  # Y axis center of rotation position

    # Rotational axis angle correction motion profile parameters
    conf.angleCorrectionProfile.type = ProfileType.Trapezoidal
    conf.angleCorrectionProfile.velocity = 200
    conf.angleCorrectionProfile.acc = 1800
    conf.angleCorrectionProfile.dec = 1800

    # Enable auto smoothing
    conf.enableAutoSmooth = 1

    # Do not stop the motion along the path at very small angles between two segments
    conf.angleCorrectionMinimumAngle = 0.01

    # Enable constant profile
    conf.enableConstProfile = 1

    ret = Wmx3Lib_adv.advMotion.SetPathIntplWithRotationConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplWithRotationConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    #Set Axis 2 to single-turn mode, single-turn encoder count. Single-turn mode is necessary for rotation axis in path interpolatioin with rotation function.
    ret=Wmx3Lib_cm.config.SetSingleTurn(2,True,360000)
    if ret != 0:
        print('SetSingleTurn error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Add the path interpolation with rotation commands
    path.numPoints = 4

    # Only specify the profile for the first point as constant profile is enabled
    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    profile = Profile()
    point.profile.type = ProfileType.Trapezoidal
    point.profile.velocity = 100
    point.profile.acc = 2000
    point.profile.dec = 2000
    point.SetTarget(0, 100)
    point.SetTarget(1, 0)
    point.autoSmoothRadius = 30  # Auto smoothing radius after first segment
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    point.SetTarget(0, 100)
    point.SetTarget(1, 100)
    point.autoSmoothRadius = 20  # Auto smoothing radius after second segment
    path.SetPoint(1, point)

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    point.SetTarget(0, 0)
    point.SetTarget(1, 100)
    point.autoSmoothRadius = 10  # Auto smoothing radius after third segment
    path.SetPoint(2, point)

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    point.SetTarget(0, 0)
    point.SetTarget(1, 0)
    path.SetPoint(3, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplWithRotationCommand(0, path)
    if ret != 0:
        print('AddPathIntplWithRotationCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Execute path interpolation with rotation
    ret = Wmx3Lib_adv.advMotion.StartPathIntplWithRotation(0)

    if ret != 0:
        print('StartPathIntplWithRotation error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return
    Wmx3Lib_cm.motion.Wait(0)
    timeoutCounter = 0
    # Wait until the path interpolation with rotation is in Idle state
    pathStatus = AdvMotion_PathIntplWithRotationState()
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplWithRotationStatus(0)
    while True:
        if (pathStatus.state == AdvMotion_PathIntplWithRotationState.Idle):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplWithRotationStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplWithRotation Runuing timeout.!')
        return
    # Free the path interpolation with rotation buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplWithRotationBuffer(0)
    if ret != 0:
        print('FreePathIntplWithRotationBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    #Turn off Axis 2 single-turn mode.
    AxisParam=Config_AxisParam()
    ret,AxisParam =Wmx3Lib_cm.config.GetAxisParam()
    AxisParam.SetSingleTurnMode(2,False)

    ret,AxisParamError=Wmx3Lib_cm.config.SetAxisParam(AxisParam)
    if ret != 0:
        print('Close SingleTurnMode error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return



#``



# Write python code to Executes a path interpolation of Axis 0 and 1 with a rotation Axis 2 with stopping after executing each segment, and the velocity is 100. Sequence consisting of four linear interpolations and enable rotating the X and Y axes around the center of rotation. The center of rotation is (50,50). The positions of four linear interpolations are: (100,0),(100,100),(0,100),(0,0). Auto smoothing radius after 1st, 2nd and 3rd segment are 30, 20, 10.
    # Axes = [0, 1, 2]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplWithRotationCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplWithRotationBuffer(0)
    # Create the path interpolation with rotation buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplWithRotationBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplWithRotationBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with rotation channel
    conf = AdvMotion_PathIntplWithRotationConfiguration()

    conf.SetAxis(0, 0)  # X axis
    conf.SetAxis(1, 1)  # Y axis
    conf.rotationalAxis = 2  # Rotational axis
    conf.SetCenterOfRotation(0, 50)  # X axis center of rotation position
    conf.SetCenterOfRotation(1, 50)  # Y axis center of rotation position

    # Rotational axis angle correction motion profile parameters
    conf.angleCorrectionProfile.type = ProfileType.Trapezoidal
    conf.angleCorrectionProfile.velocity = 200
    conf.angleCorrectionProfile.acc = 1800
    conf.angleCorrectionProfile.dec = 1800

    # Enable auto smoothing
    conf.enableAutoSmooth = 1

    # Do not stop the motion along the path at very small angles between two segments
    conf.angleCorrectionMinimumAngle = 0.01

    ret = Wmx3Lib_adv.advMotion.SetPathIntplWithRotationConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplWithRotationConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    #Set Axis 2 to single-turn mode, single-turn encoder count 360. Single-turn mode is necessary for rotation axis in path interpolatioin with rotation function.
    ret=Wmx3Lib_cm.config.SetSingleTurn(2,True,360000)
    if ret != 0:
        print('SetSingleTurn error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Add the path interpolation with rotation commands
    path.numPoints = 4

    # Only specify the profile for the first point as constant profile is enabled
    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    profile = Profile()
    point.profile.type = ProfileType.Trapezoidal
    point.profile.velocity = 100
    point.profile.acc = 2000
    point.profile.dec = 2000
    point.SetTarget(0, 100)
    point.SetTarget(1, 0)
    point.autoSmoothRadius = 30  # Auto smoothing radius after first segment
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    profile = Profile()
    point.profile.type = ProfileType.Trapezoidal
    point.profile.velocity = 100
    point.profile.acc = 2000
    point.profile.dec = 2000
    point.SetTarget(0, 100)
    point.SetTarget(1, 100)
    point.autoSmoothRadius = 20  # Auto smoothing radius after second segment
    path.SetPoint(1, point)

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    profile = Profile()
    point.profile.type = ProfileType.Trapezoidal
    point.profile.velocity = 100
    point.profile.acc = 2000
    point.profile.dec = 2000
    point.SetTarget(0, 0)
    point.SetTarget(1, 100)
    point.autoSmoothRadius = 10  # Auto smoothing radius after third segment
    path.SetPoint(2, point)

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    profile = Profile()
    point.profile.type = ProfileType.Trapezoidal
    point.profile.velocity = 100
    point.profile.acc = 2000
    point.profile.dec = 2000
    point.SetTarget(0, 0)
    point.SetTarget(1, 0)
    path.SetPoint(3, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplWithRotationCommand(0, path)
    if ret != 0:
        print('AddPathIntplWithRotationCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Execute path interpolation with rotation
    ret = Wmx3Lib_adv.advMotion.StartPathIntplWithRotation(0)
    if ret != 0:
        print('StartPathIntplWithRotation error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return
    Wmx3Lib_cm.motion.Wait(0)
    timeoutCounter = 0
    # Wait until the path interpolation with rotation is in Idle state
    pathStatus = AdvMotion_PathIntplWithRotationState()
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplWithRotationStatus(0)
    while True:
        if (pathStatus.state == AdvMotion_PathIntplWithRotationState.Idle):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplWithRotationStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplWithRotation Runuing timeout.!')
        return
    # Free the path interpolation with rotation buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplWithRotationBuffer(0)
    if ret != 0:
        print('FreePathIntplWithRotationBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    #Turn off Axis 2 single-turn mode.
    AxisParam=Config_AxisParam()
    ret,AxisParam =Wmx3Lib_cm.config.GetAxisParam()
    AxisParam.SetSingleTurnMode(2,False)

    ret,AxisParamError=Wmx3Lib_cm.config.SetAxisParam(AxisParam)
    if ret != 0:
        print('Close SingleTurnMode error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return



#``



# Write python code to Executes a path interpolation of Axis 0 and 1 with a rotation Axis 2 and the velocity is 100. Sequence consisting of four linear interpolations and enable rotating the X and Y axes around the center of rotation. The center of rotation is (50,50). The positions of four linear interpolations are: (100,0),(100,100),(0,100),(0,0). First linearly interpolate to Point 2, then sleep 0.2s, and linearly interpolate to the last point, then sleep 0.2s, and linearly interpolate to Point 0.
    # Axes = [0, 1, 2]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplWithRotationCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplWithRotationBuffer(0)
    # Create the path interpolation with rotation buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplWithRotationBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplWithRotationBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with rotation channel
    conf = AdvMotion_PathIntplWithRotationConfiguration()

    conf.SetAxis(0, 0)  # X axis
    conf.SetAxis(1, 1)  # Y axis
    conf.rotationalAxis = 2  # Rotational axis
    conf.SetCenterOfRotation(0, 50)  # X axis center of rotation position
    conf.SetCenterOfRotation(1, 50)  # Y axis center of rotation position

    # Rotational axis angle correction motion profile parameters
    conf.angleCorrectionProfile.type = ProfileType.Trapezoidal
    conf.angleCorrectionProfile.velocity = 200
    conf.angleCorrectionProfile.acc = 1800
    conf.angleCorrectionProfile.dec = 1800

    ret = Wmx3Lib_adv.advMotion.SetPathIntplWithRotationConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplWithRotationConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    #Set Axis 2 to single-turn mode, single-turn encoder count 360. Single-turn mode is necessary for rotation axis in path interpolatioin with rotation function.
    ret=Wmx3Lib_cm.config.SetSingleTurn(2,True,360000)
    if ret != 0:
        print('SetSingleTurn error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Add the path interpolation with rotation commands
    path.numPoints = 4

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    profile = Profile()
    point.profile.type = ProfileType.Trapezoidal
    point.profile.velocity = 100
    point.profile.acc = 2000
    point.profile.dec = 2000
    point.SetTarget(0, 100)
    point.SetTarget(1, 0)
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    profile = Profile()
    point.profile.type = ProfileType.Trapezoidal
    point.profile.velocity = 100
    point.profile.acc = 2000
    point.profile.dec = 2000
    point.SetTarget(0, 100)
    point.SetTarget(1, 100)
    path.SetPoint(1, point)

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    profile = Profile()
    point.profile.type = ProfileType.Trapezoidal
    point.profile.velocity = 100
    point.profile.acc = 2000
    point.profile.dec = 2000
    point.SetTarget(0, 0)
    point.SetTarget(1, 100)
    path.SetPoint(2, point)

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    profile = Profile()
    point.profile.type = ProfileType.Trapezoidal
    point.profile.velocity = 100
    point.profile.acc = 2000
    point.profile.dec = 2000
    point.SetTarget(0, 0)
    point.SetTarget(1, 0)
    path.SetPoint(3, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplWithRotationCommand(0, path)
    if ret != 0:
        print('AddPathIntplWithRotationCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Execute path interpolation with rotation
    ret = Wmx3Lib_adv.advMotion.StartPathIntplWithRotation_Pos(0, 2)  # Move to point 2
    if ret != 0:
        print('StartPathIntplWithRotation_Pos error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for axis 0 to finish motion
    ret = Wmx3Lib_cm.motion.Wait(0)
    # Sleep for 200ms after motion finishes
    sleep(0.2)

    # Move to end of path
    ret = Wmx3Lib_adv.advMotion.StartPathIntplWithRotation(0)  # Move to the last point
    if ret != 0:
        print('StartPathIntplWithRotation error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for axis 0 to finish motion
    ret = Wmx3Lib_cm.motion.Wait(0)
    # Sleep for 200ms after motion finishes
    sleep(0.2)
    # Move to point 0 (start of path)
    ret = Wmx3Lib_adv.advMotion.StartPathIntplWithRotation_Pos(0, 0)  # Move to point 0
    if ret != 0:
        print('StartPathIntplWithRotation_Pos error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return
    Wmx3Lib_cm.motion.Wait(0)
    timeoutCounter = 0
    # Wait until the path interpolation with rotation is in Idle state
    pathStatus = AdvMotion_PathIntplWithRotationState()
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplWithRotationStatus(0)
    while True:
        if (pathStatus.state == AdvMotion_PathIntplWithRotationState.Idle):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplWithRotationStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplWithRotation Runuing timeout.!')
        return
    # Free the path interpolation with rotation buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplWithRotationBuffer(0)
    if ret != 0:
        print('FreePathIntplWithRotationBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    #Turn off Axis 2 single-turn mode.
    AxisParam=Config_AxisParam()
    ret,AxisParam =Wmx3Lib_cm.config.GetAxisParam()
    AxisParam.SetSingleTurnMode(2,False)

    ret,AxisParamError=Wmx3Lib_cm.config.SetAxisParam(AxisParam)
    if ret != 0:
        print('Close SingleTurnMode error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return
    


#``



# Write python code to Executes a path interpolation of Axis 0 and 1 with a rotation Axis 2 and the velocity is 100. Sequence consisting of four linear interpolations and enable rotating the X and Y axes around the center of rotation of (50,50). The positions of four linear interpolations are: (100,0),(100,100),(0,100),(0,0). The local center rotation of each segment is respectively (50,40),(60,50),(50,60) and (40,50).
    # Axes = [0, 1, 2]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplWithRotationCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplWithRotationBuffer(0)
    # Create the path interpolation with rotation buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplWithRotationBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplWithRotationBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with rotation channel
    conf = AdvMotion_PathIntplWithRotationConfiguration()

    conf.SetAxis(0, 0)  # X axis
    conf.SetAxis(1, 1)  # Y axis
    conf.rotationalAxis = 2  # Rotational axis
    conf.SetCenterOfRotation(0, 50)  # X axis center of rotation position
    conf.SetCenterOfRotation(1, 50)  # Y axis center of rotation position

    # Rotational axis angle correction motion profile parameters
    conf.angleCorrectionProfile.type = ProfileType.Trapezoidal
    conf.angleCorrectionProfile.velocity = 200
    conf.angleCorrectionProfile.acc = 1800
    conf.angleCorrectionProfile.dec = 1800

    # Enable local center of rotation
    conf.enableLocalCenterOfRotation = 1

    ret = Wmx3Lib_adv.advMotion.SetPathIntplWithRotationConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplWithRotationConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    #Set Axis 2 to single-turn mode, single-turn encoder count 360. Single-turn mode is necessary for rotation axis in path interpolatioin with rotation function.
    ret=Wmx3Lib_cm.config.SetSingleTurn(2,True,360000)
    if ret != 0:
        print('SetSingleTurn error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Add the path interpolation with rotation commands
    path.numPoints = 4

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    profile = Profile()
    point.profile.type = ProfileType.Trapezoidal
    point.profile.velocity = 100
    point.profile.acc = 2000
    point.profile.dec = 2000
    point.SetTarget(0, 100)
    point.SetTarget(1, 0)
    point.useLocalCenterOfRotation = 1
    point.localCenterOfRotationDirection = 1
    point.SetLocalCenterOfRotation(0, 50)
    point.SetLocalCenterOfRotation(1, 40)
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    profile = Profile()
    point.profile.type = ProfileType.Trapezoidal
    point.profile.velocity = 100
    point.profile.acc = 2000
    point.profile.dec = 2000
    point.SetTarget(0, 100)
    point.SetTarget(1, 100)
    point.useLocalCenterOfRotation = 1
    point.localCenterOfRotationDirection = 1
    point.SetLocalCenterOfRotation(0, 60)
    point.SetLocalCenterOfRotation(1, 50)
    path.SetPoint(1, point)

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    profile = Profile()
    point.profile.type = ProfileType.Trapezoidal
    point.profile.velocity = 100
    point.profile.acc = 2000
    point.profile.dec = 2000
    point.SetTarget(0, 0)
    point.SetTarget(1, 100)
    point.useLocalCenterOfRotation = 1
    point.localCenterOfRotationDirection = 1
    point.SetLocalCenterOfRotation(0, 50)
    point.SetLocalCenterOfRotation(1, 60)
    path.SetPoint(2, point)

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    profile = Profile()
    point.profile.type = ProfileType.Trapezoidal
    point.profile.velocity = 100
    point.profile.acc = 2000
    point.profile.dec = 2000
    point.SetTarget(0, 0)
    point.SetTarget(1, 0)
    point.useLocalCenterOfRotation = 1
    point.localCenterOfRotationDirection = 1
    point.SetLocalCenterOfRotation(0, 40)
    point.SetLocalCenterOfRotation(1, 50)
    path.SetPoint(3, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplWithRotationCommand(0, path)
    if ret != 0:
        print('AddPathIntplWithRotationCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Execute path interpolation with rotation
    ret = Wmx3Lib_adv.advMotion.StartPathIntplWithRotation(0)
    if ret != 0:
        print('StartPathIntplWithRotation error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return
    Wmx3Lib_cm.motion.Wait(0)
    timeoutCounter = 0
    # Wait until the path interpolation with rotation is in Idle state
    pathStatus = AdvMotion_PathIntplWithRotationState()
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplWithRotationStatus(0)
    while True:
        if (pathStatus.state == AdvMotion_PathIntplWithRotationState.Idle):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplWithRotationStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplWithRotation Runuing timeout.!')
        return
    # Free the path interpolation with rotation buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplWithRotationBuffer(0)
    if ret != 0:
        print('FreePathIntplWithRotationBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    #Turn off Axis 2 single-turn mode.
    AxisParam=Config_AxisParam()
    ret,AxisParam =Wmx3Lib_cm.config.GetAxisParam()
    AxisParam.SetSingleTurnMode(2,False)

    ret,AxisParamError=Wmx3Lib_cm.config.SetAxisParam(AxisParam)
    if ret != 0:
        print('Close SingleTurnMode error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return
    



#``



# Write python code to Executes a path interpolation of Axis 0 and 1 with a rotation Axis 2 and with a Z axis 3, the center of rotation is (75,75) and the velocity is 1000. There are 7 segments. 1)Linear interpolation to (100,0) and Z axis to 25; 2)Circular interpolation to (150,50) with center (100,50) and Z axis to 50; 3)Linear interpolation to (150,100) and Z axis to 75; 4)Circular interpolation to (100,150) with center (100,100) and Z axis to 100; 5)Linear interpolation to (50,150) and Z axis to 125; 6)Circular interpolation to (100,150) with center (50,100) and Z axis to 150; 7)Linear interpolation to (0,0) and Z axis to 175.
    # Axes = [0, 1, 2, 3]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplWithRotationCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplWithRotationBuffer(0)
    # Create the path interpolation with rotation buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplWithRotationBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplWithRotationBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with rotation channel
    conf = AdvMotion_PathIntplWithRotationConfiguration()

    conf.SetAxis(0, 0)  # X axis
    conf.SetAxis(1, 1)  # Y axis
    conf.rotationalAxis = 2  # Rotational axis
    conf.SetCenterOfRotation(0, 75)  # X axis center of rotation position
    conf.SetCenterOfRotation(1, 75)  # Y axis center of rotation position

    # Enable constant profile
    conf.enableConstProfile = 1

    # Prevent stop from occurring at very small angles
    conf.angleCorrectionMinimumAngle = 0.01

    # Enable Z axis
    conf.enableZAxis = 1
    conf.zAxis = 3

    # Rotational axis angle correction motion profile parameters
    conf.angleCorrectionProfile.type = ProfileType.Trapezoidal
    conf.angleCorrectionProfile.velocity = 900
    conf.angleCorrectionProfile.acc = 1800
    conf.angleCorrectionProfile.dec = 1800

    ret = Wmx3Lib_adv.advMotion.SetPathIntplWithRotationConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplWithRotationConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    #Set Axis 2 to single-turn mode, single-turn encoder count 360. Single-turn mode is necessary for rotation axis in path interpolatioin with rotation function.
    ret=Wmx3Lib_cm.config.SetSingleTurn(2,True,360000)
    if ret != 0:
        print('SetSingleTurn error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Add the path interpolation with rotation commands
    path.numPoints = 7

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    profile = Profile()
    point.profile.type = ProfileType.Trapezoidal
    point.profile.velocity = 1000
    point.profile.acc = 2000
    point.profile.dec = 2000
    point.SetTarget(0, 100)
    point.SetTarget(1, 0)
    point.zAxisTarget = 25
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Circular
    point.direction = 1
    point.SetCenterPos(0, 100)
    point.SetCenterPos(1, 50)
    point.SetTarget(0, 150)
    point.SetTarget(1, 50)
    point.zAxisTarget = 50
    path.SetPoint(1, point)

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    point.SetTarget(0, 150)
    point.SetTarget(1, 100)
    point.zAxisTarget = 75
    path.SetPoint(2, point)

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Circular
    point.direction = 1
    point.SetCenterPos(0, 100)
    point.SetCenterPos(1, 100)
    point.SetTarget(0, 150)
    point.SetTarget(1, 150)
    point.zAxisTarget = 100
    path.SetPoint(3, point)

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    point.SetTarget(0, 50)
    point.SetTarget(1, 150)
    point.zAxisTarget = 125
    path.SetPoint(4, point)

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Circular
    point.direction = 1
    point.SetCenterPos(0, 50)
    point.SetCenterPos(1, 100)
    point.SetTarget(0, 0)
    point.SetTarget(1, 100)
    point.zAxisTarget = 1500
    path.SetPoint(5, point)

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    point.SetTarget(0, 0)
    point.SetTarget(1, 0)
    point.zAxisTarget = 175
    path.SetPoint(6, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplWithRotationCommand(0, path)
    if ret != 0:
        print('AddPathIntplWithRotationCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Execute path interpolation with rotation
    ret = Wmx3Lib_adv.advMotion.StartPathIntplWithRotation(0)
    if ret != 0:
        print('StartPathIntplWithRotation error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return
    Wmx3Lib_cm.motion.Wait(0)
    timeoutCounter = 0
    # Wait until the path interpolation with rotation is in Idle state
    pathStatus = AdvMotion_PathIntplWithRotationState()
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplWithRotationStatus(0)
    while True:
        if (pathStatus.state == AdvMotion_PathIntplWithRotationState.Idle):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplWithRotationStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplWithRotation Runuing timeout.!')
        return
    # Free the path interpolation with rotation buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplWithRotationBuffer(0)
    if ret != 0:
        print('FreePathIntplWithRotationBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    #Turn off Axis 2 single-turn mode.
    AxisParam=Config_AxisParam()
    ret,AxisParam =Wmx3Lib_cm.config.GetAxisParam()
    AxisParam.SetSingleTurnMode(2,False)

    ret,AxisParamError=Wmx3Lib_cm.config.SetAxisParam(AxisParam)
    if ret != 0:
        print('Close SingleTurnMode error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return



#``



# Write python code to Execute path interpolation with look ahead of Axis 4 and Axis 1 with velocity 1000, consisting of four linear interpolations: (100,0),(100,100),(0,100),(0,0).
# Axes = [4, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplLookaheadCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    # Create the path interpolation with look ahead buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplLookaheadBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with look ahead channel
    conf = AdvMotion_PathIntplLookaheadConfiguration()

    conf.axisCount = 2
    conf.SetAxis(0, 4)
    conf.SetAxis(1, 1)
    conf.compositeVel = 1000
    conf.compositeAcc = 2000
    #  The commanded axes will automatically change to Idle operation state after all interpolation commands in the path have been executed.
    conf.stopOnEmptyBuffer = True

    ret = Wmx3Lib_adv.advMotion.SetPathIntplLookaheadConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplLookaheadConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Add the path interpolation with look ahead commands
    path.numPoints = 4

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 4)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 100)
    point.linear.SetTarget(1, 0)
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 4)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 100)
    point.linear.SetTarget(1, 100)
    path.SetPoint(1, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 4)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 0)
    point.linear.SetTarget(1, 100)
    path.SetPoint(2, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 4)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 0)
    point.linear.SetTarget(1, 0)
    path.SetPoint(3, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplLookaheadCommand(0, path)
    if ret != 0:
        print('AddPathIntplLookaheadCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Execute path interpolation with look ahead
    ret = Wmx3Lib_adv.advMotion.StartPathIntplLookahead(0)
    if ret != 0:
        print('StartPathIntplLookahead error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the path interpolation with look ahead to complete
    Wmx3Lib_cm.motion.Wait(4)
    timeoutCounter = 0
    # Wait until the path interpolation with look ahead is in Stopped state
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    while True:
        if (pathStatus.state != AdvMotion_PathIntplLookaheadState.Stopped):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplLookahead Running timeout.!')
        return
    # Free the path interpolation with look ahead buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    if ret != 0:
        print('FreePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return


#``



# Write python code to Execute path interpolation with look ahead of Axis 5 and Axis 1 with velocity 1000, consisting of four linear interpolations: (100,0),(100,100),(0,100),(0,0). First start executing it for 0.5s, then stop and sleep for 1s, and then resume it.
# Axes = [5, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplLookaheadCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(5)
    # Create the path interpolation with look ahead buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplLookaheadBuffer(5, 1000)
    if ret != 0:
        print('CreatePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with look ahead channel
    conf = AdvMotion_PathIntplLookaheadConfiguration()

    conf.axisCount = 2
    conf.SetAxis(0, 5)
    conf.SetAxis(1, 1)
    conf.compositeVel = 1000
    conf.compositeAcc = 2000
    #  The commanded axes will automatically change to Idle operation state after all interpolation commands in the path have been executed.
    conf.stopOnEmptyBuffer = True

    ret = Wmx3Lib_adv.advMotion.SetPathIntplLookaheadConfiguration(5, conf)
    if ret != 0:
        print('SetPathIntplLookaheadConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Add the path interpolation with look ahead commands
    path.numPoints = 4

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 5)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 100)
    point.linear.SetTarget(1, 0)
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 5)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 100)
    point.linear.SetTarget(1, 100)
    path.SetPoint(1, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 5)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 0)
    point.linear.SetTarget(1, 100)
    path.SetPoint(2, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 5)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 0)
    point.linear.SetTarget(1, 0)
    path.SetPoint(3, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplLookaheadCommand(5, path)
    if ret != 0:
        print('AddPathIntplLookaheadCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Execute path interpolation with look ahead
    ret = Wmx3Lib_adv.advMotion.StartPathIntplLookahead(5)
    if ret != 0:
        print('StartPathIntplLookahead error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    sleep(0.5)
    # Stop path interpolation with look ahead
    ret = Wmx3Lib_adv.advMotion.StopPathIntplLookahead(5)
    if ret != 0:
        print('StopPathIntplLookahead error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return
    
    sleep(1)
    # Execute path interpolation with look ahead (Resume execution)
    ret = Wmx3Lib_adv.advMotion.StartPathIntplLookahead(5)
    if ret != 0:
        print('StartPathIntplLookahead error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the path interpolation with look ahead to complete
    Wmx3Lib_cm.motion.Wait(5)
    timeoutCounter = 0
    # Wait until the path interpolation with look ahead is in Stopped state
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(5)
    while True:
        if (pathStatus.state != AdvMotion_PathIntplLookaheadState.Stopped):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(5)
    if (timeoutCounter > 500):
        print('PathIntplLookahead Running timeout.!')
        return
    
    # Free the path interpolation with look ahead buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(5)
    if ret != 0:
        print('FreePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return


#``



# Write python code to Execute path interpolation with look ahead of Axis 6 and Axis 1 with velocity 1000, consisting of four linear interpolations: (100,0),(100,100),(0,100),(0,0).
# Axes = [6, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplLookaheadCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    # Create the path interpolation with look ahead buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplLookaheadBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with look ahead channel
    conf = AdvMotion_PathIntplLookaheadConfiguration()

    conf.axisCount = 2
    conf.SetAxis(0, 6)
    conf.SetAxis(1, 1)
    conf.compositeVel = 1000
    conf.compositeAcc = 2000
    #  The commanded axes will automatically change to Idle operation state after all interpolation commands in the path have been executed.
    conf.stopOnEmptyBuffer = True
    # Sample the profile at every specified distance along the path, improving the granularity of the generated profile.
    conf.sampleDistance = 100

    ret = Wmx3Lib_adv.advMotion.SetPathIntplLookaheadConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplLookaheadConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Add the path interpolation with look ahead commands
    path.numPoints = 4

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 6)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 100)
    point.linear.SetTarget(1, 0)
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 6)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 100)
    point.linear.SetTarget(1, 100)
    path.SetPoint(1, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 6)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 0)
    point.linear.SetTarget(1, 100)
    path.SetPoint(2, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 6)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 0)
    point.linear.SetTarget(1, 0)
    path.SetPoint(3, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplLookaheadCommand(0, path)
    if ret != 0:
        print('AddPathIntplLookaheadCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Execute path interpolation with look ahead
    ret = Wmx3Lib_adv.advMotion.StartPathIntplLookahead(0)
    if ret != 0:
        print('StartPathIntplLookahead error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the path interpolation with look ahead to complete
    Wmx3Lib_cm.motion.Wait(6)
    timeoutCounter = 0
    # Wait until the path interpolation with look ahead is in Stopped state
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    while True:
        if (pathStatus.state != AdvMotion_PathIntplLookaheadState.Stopped):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplLookahead Running timeout.!')
        return
    # Free the path interpolation with look ahead buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    if ret != 0:
        print('FreePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return


#``



# Write python code to Execute path interpolation with look ahead of Axis 7 and Axis 1 with velocity 1000, with a sample distance 100, consisting of four linear interpolations: (100,0),(100,100),(0,100),(0,0), while the smoothRadius are 12.5, 25 and 50.
# Axes = [7, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplLookaheadCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    # Create the path interpolation with look ahead buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplLookaheadBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with look ahead channel
    conf = AdvMotion_PathIntplLookaheadConfiguration()

    conf.axisCount = 2
    conf.SetAxis(0, 7)
    conf.SetAxis(1, 1)
    conf.compositeVel = 1000
    conf.compositeAcc = 2000
    #  The commanded axes will automatically change to Idle operation state after all interpolation commands in the path have been executed.
    conf.stopOnEmptyBuffer = True
    # Sample the profile at every specified distance along the path, improving the granularity of the generated profile.
    conf.sampleDistance = 100

    ret = Wmx3Lib_adv.advMotion.SetPathIntplLookaheadConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplLookaheadConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Add the path interpolation with look ahead commands
    path.numPoints = 4

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 7)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 100)
    point.linear.SetTarget(1, 0)
    point.linear.smoothRadius = 12.5
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 7)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 100)
    point.linear.SetTarget(1, 100)
    point.linear.smoothRadius = 25
    path.SetPoint(1, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 7)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 0)
    point.linear.SetTarget(1, 100)
    point.linear.smoothRadius = 50
    path.SetPoint(2, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 7)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 0)
    point.linear.SetTarget(1, 0)
    path.SetPoint(3, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplLookaheadCommand(0, path)
    if ret != 0:
        print('AddPathIntplLookaheadCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Execute path interpolation with look ahead
    ret = Wmx3Lib_adv.advMotion.StartPathIntplLookahead(0)
    if ret != 0:
        print('StartPathIntplLookahead error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the path interpolation with look ahead to complete
    Wmx3Lib_cm.motion.Wait(7) # Wait Axis 7
    timeoutCounter = 0
    # Wait until the path interpolation with look ahead is in Stopped state
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    while True:
        if (pathStatus.state != AdvMotion_PathIntplLookaheadState.Stopped):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplLookahead Running timeout.!')
        return
    # Free the path interpolation with look ahead buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    if ret != 0:
        print('FreePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return


#``



# Write python code to Execute path interpolation with look ahead of Axis 5 and Axis 1 with velocity 1000, composite acceleration 2000, and the acceleration limit  for each axis is 1500, with a sample distance 100, consisting of four linear interpolations: (100,0),(100,100),(0,100),(0,0), while the smoothRadius are 12.5, 25 and 50.
# Axes = [5, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplLookaheadCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    # Create the path interpolation with look ahead buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplLookaheadBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with look ahead channel
    conf = AdvMotion_PathIntplLookaheadConfiguration()

    conf.axisCount = 2
    conf.SetAxis(0, 5)
    conf.SetAxis(1, 1)
    conf.compositeVel = 1000
    conf.compositeAcc = 2000
    #  The commanded axes will automatically change to Idle operation state after all interpolation commands in the path have been executed.
    conf.stopOnEmptyBuffer = True
    # Sample the profile at every specified distance along the path, improving the granularity of the generated profile.
    conf.sampleDistance = 100
    conf.SetAccLimit(0, 1500)
    conf.SetAccLimit(1, 1500)

    ret = Wmx3Lib_adv.advMotion.SetPathIntplLookaheadConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplLookaheadConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Add the path interpolation with look ahead commands
    path.numPoints = 4

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 5)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 100)
    point.linear.SetTarget(1, 0)
    point.linear.smoothRadius = 12.5
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 5)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 100)
    point.linear.SetTarget(1, 100)
    point.linear.smoothRadius = 25
    path.SetPoint(1, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 5)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 0)
    point.linear.SetTarget(1, 100)
    point.linear.smoothRadius = 50
    path.SetPoint(2, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 5)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 0)
    point.linear.SetTarget(1, 0)
    path.SetPoint(3, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplLookaheadCommand(0, path)
    if ret != 0:
        print('AddPathIntplLookaheadCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Execute path interpolation with look ahead
    ret = Wmx3Lib_adv.advMotion.StartPathIntplLookahead(0)
    if ret != 0:
        print('StartPathIntplLookahead error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the path interpolation with look ahead to complete
    Wmx3Lib_cm.motion.Wait(5)
    timeoutCounter = 0
    # Wait until the path interpolation with look ahead is in Stopped state
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    while True:
        if (pathStatus.state != AdvMotion_PathIntplLookaheadState.Stopped):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplLookahead Running timeout.!')
        return
    # Free the path interpolation with look ahead buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    if ret != 0:
        print('FreePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return


#``



# Write python code to Execute path interpolation with look ahead of Axis 6 and Axis 1 with velocity 1000, composite acceleration 2000, and the acceleration limit for each axis is 1500, and the velocity limit for Axis 6 and 1 is 700 and 500,  with a sample distance 100, consisting of four linear interpolations: (100,0),(100,100),(0,100),(0,0), while the smoothRadius are 12.5, 25 and 50.
# Axes = [6, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplLookaheadCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    # Create the path interpolation with look ahead buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplLookaheadBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with look ahead channel
    conf = AdvMotion_PathIntplLookaheadConfiguration()

    conf.axisCount = 2
    conf.SetAxis(0, 6)
    conf.SetAxis(1, 1)
    conf.compositeVel = 1000
    conf.compositeAcc = 2000
    #  The commanded axes will automatically change to Idle operation state after all interpolation commands in the path have been executed.
    conf.stopOnEmptyBuffer = True
    # Sample the profile at every specified distance along the path, improving the granularity of the generated profile.
    conf.sampleDistance = 100
    conf.SetAccLimit(0, 1500)
    conf.SetAccLimit(1, 1500)
    conf.SetVelocityLimit(0, 700)
    conf.SetVelocityLimit(1, 500)

    ret = Wmx3Lib_adv.advMotion.SetPathIntplLookaheadConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplLookaheadConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Add the path interpolation with look ahead commands
    path.numPoints = 4

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 6)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 100)
    point.linear.SetTarget(1, 0)
    point.linear.smoothRadius = 12.5
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 6)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 100)
    point.linear.SetTarget(1, 100)
    point.linear.smoothRadius = 25
    path.SetPoint(1, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 6)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 0)
    point.linear.SetTarget(1, 100)
    point.linear.smoothRadius = 50
    path.SetPoint(2, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 6)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 0)
    point.linear.SetTarget(1, 0)
    path.SetPoint(3, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplLookaheadCommand(0, path)
    if ret != 0:
        print('AddPathIntplLookaheadCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Execute path interpolation with look ahead
    ret = Wmx3Lib_adv.advMotion.StartPathIntplLookahead(0)
    if ret != 0:
        print('StartPathIntplLookahead error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the path interpolation with look ahead to complete
    Wmx3Lib_cm.motion.Wait(6)
    timeoutCounter = 0
    # Wait until the path interpolation with look ahead is in Stopped state
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    while True:
        if (pathStatus.state != AdvMotion_PathIntplLookaheadState.Stopped):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplLookahead Running timeout.!')
        return
    # Free the path interpolation with look ahead buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    if ret != 0:
        print('FreePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return


#``



# Write python code to Execute path interpolation with look ahead of Axis 7 and Axis 1 with velocity 1000, with a sample distance 50 and angle tolerance 11, consisting of 36 linear interpolations to comprise a counterclockwise circle which starts from (0,0) and the radius is 200.
# Axes = [7, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplLookaheadCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    
    # Create the path interpolation with look ahead buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplLookaheadBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with look ahead channel
    conf = AdvMotion_PathIntplLookaheadConfiguration()

    conf.axisCount = 2
    conf.SetAxis(0, 7)
    conf.SetAxis(1, 1)
    conf.compositeVel = 1000
    conf.compositeAcc = 4000
    conf.sampleDistance = 50
    conf.stopOnEmptyBuffer = True
    conf.setAngleTolerance = True
    conf.angleToleranceDegrees = 11

    ret = Wmx3Lib_adv.advMotion.SetPathIntplLookaheadConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplLookaheadConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Add the path interpolation with look ahead commands
    path.numPoints = 36

    import math

    PI = float(3.141592653589793238)

    for i in range(0, 36):
        Point = AdvMotion_PathIntplLookaheadCommandPoint()
        Point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
        Point.linear.axisCount = 2
        Point.linear.SetAxis(0, 7)
        Point.linear.SetAxis(1, 1)
        Point.linear.SetTarget(0, -200 + 200 * math.cos((i + 1) / 36.0 * (2 * PI)))
        Point.linear.SetTarget(1, 0 + 200 * math.sin((i + 1) / 36.0 * (2 * PI)))
        path.SetPoint(i, Point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplLookaheadCommand(0, path)
    if ret != 0:
        print('AddPathIntplLookaheadCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Execute path interpolation with look ahead
    ret = Wmx3Lib_adv.advMotion.StartPathIntplLookahead(0)
    if ret != 0:
        print('StartPathIntplLookahead error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the path interpolation with look ahead to complete
    Wmx3Lib_cm.motion.Wait(7)
    timeoutCounter = 0
    # Wait until the path interpolation with look ahead is in Stopped state
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    while True:
        if (pathStatus.state != AdvMotion_PathIntplLookaheadState.Stopped):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplLookahead Running timeout.!')
        return
    # Free the path interpolation with look ahead buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    if ret != 0:
        print('FreePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return


#``



# Write Python code to execute path interpolation with look ahead of Axis 8 and Axis 1 with velocity 1000, with a sample distance 50, the smoothRadius 20, consisting of 36 linear interpolations to comprise a counterclockwise circle which starts from (0,0) and the radius is 200.
# Axes = [8, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplLookaheadCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    
    # Create the path interpolation with look ahead buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplLookaheadBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with look ahead channel
    conf = AdvMotion_PathIntplLookaheadConfiguration()

    conf.axisCount = 2
    conf.SetAxis(0, 8)
    conf.SetAxis(1, 1)
    conf.compositeVel = 1000
    conf.compositeAcc = 4000
    conf.sampleDistance = 50
    conf.stopOnEmptyBuffer = True

    ret = Wmx3Lib_adv.advMotion.SetPathIntplLookaheadConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplLookaheadConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Add the path interpolation with look ahead commands
    path.numPoints = 36

    import math

    PI = float(3.141592653589793238)

    for i in range(0, 36):
        Point = AdvMotion_PathIntplLookaheadCommandPoint()
        Point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
        Point.linear.axisCount = 2
        Point.linear.SetAxis(0, 8)
        Point.linear.SetAxis(1, 1)
        Point.linear.SetTarget(0, -200 + 200 * math.cos((i + 1) / 36.0 * (2 * PI)))
        Point.linear.SetTarget(1, 0 + 200 * math.sin((i + 1) / 36.0 * (2 * PI)))
        Point.smoothRadius = 20
        path.SetPoint(i, Point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplLookaheadCommand(0, path)
    if ret != 0:
        print('AddPathIntplLookaheadCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Execute path interpolation with look ahead
    ret = Wmx3Lib_adv.advMotion.StartPathIntplLookahead(0)
    if ret != 0:
        print('StartPathIntplLookahead error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the path interpolation with look ahead to complete
    Wmx3Lib_cm.motion.Wait(8)
    timeoutCounter = 0
    # Wait until the path interpolation with look ahead is in Stopped state
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    while True:
        if (pathStatus.state != AdvMotion_PathIntplLookaheadState.Stopped):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplLookahead Running timeout.!')
        return
    # Free the path interpolation with look ahead buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    if ret != 0:
        print('FreePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return


#``



# Write Python code to execute path interpolation with look ahead of Axis 9 and Axis 1 with velocity 1000, with a sample distance 50, consisting of four circular interpolations defined as (throughPos0,throughPos1,endPos0,endPos1): (50,50,100,0),(50,-50,0,0),(-50,50,-100,0),(-50,-50,0,0).
# Axes = [9, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplLookaheadCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    # Create the path interpolation with look ahead buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplLookaheadBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with look ahead channel
    conf = AdvMotion_PathIntplLookaheadConfiguration()

    conf.axisCount = 2
    conf.SetAxis(0, 9)
    conf.SetAxis(1, 1)
    conf.compositeVel = 1000
    conf.compositeAcc = 4000
    conf.sampleDistance = 50
    conf.stopOnEmptyBuffer = True

    ret = Wmx3Lib_adv.advMotion.SetPathIntplLookaheadConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplLookaheadConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Add the path interpolation with look ahead commands
    path.numPoints = 4

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.ThroughAndEndCircular
    point.throughAndEndCircular.SetAxis(0, 9)
    point.throughAndEndCircular.SetAxis(1, 1)
    point.throughAndEndCircular.SetThroughPos(0, 50)
    point.throughAndEndCircular.SetThroughPos(1, 50)
    point.throughAndEndCircular.SetEndPos(0, 100)
    point.throughAndEndCircular.SetEndPos(1, 0)
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.ThroughAndEndCircular
    point.throughAndEndCircular.SetAxis(0, 9)
    point.throughAndEndCircular.SetAxis(1, 1)
    point.throughAndEndCircular.SetThroughPos(0, 50)
    point.throughAndEndCircular.SetThroughPos(1, -50)
    point.throughAndEndCircular.SetEndPos(0, 0)
    point.throughAndEndCircular.SetEndPos(1, 0)
    path.SetPoint(1, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.ThroughAndEndCircular
    point.throughAndEndCircular.SetAxis(0, 9)
    point.throughAndEndCircular.SetAxis(1, 1)
    point.throughAndEndCircular.SetThroughPos(0, -50)
    point.throughAndEndCircular.SetThroughPos(1, 50)
    point.throughAndEndCircular.SetEndPos(0, -100)
    point.throughAndEndCircular.SetEndPos(1, 0)
    path.SetPoint(2, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.ThroughAndEndCircular
    point.throughAndEndCircular.SetAxis(0, 9)
    point.throughAndEndCircular.SetAxis(1, 1)
    point.throughAndEndCircular.SetThroughPos(0, -50)
    point.throughAndEndCircular.SetThroughPos(1, -50)
    point.throughAndEndCircular.SetEndPos(0, 0)
    point.throughAndEndCircular.SetEndPos(1, 0)
    path.SetPoint(3, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplLookaheadCommand(0, path)
    if ret != 0:
        print('AddPathIntplLookaheadCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Execute path interpolation with look ahead
    ret = Wmx3Lib_adv.advMotion.StartPathIntplLookahead(0)
    if ret != 0:
        print('StartPathIntplLookahead error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the path interpolation with look ahead to complete
    Wmx3Lib_cm.motion.Wait(9)
    timeoutCounter = 0
    # Wait until the path interpolation with look ahead is in Stopped state
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    while True:
        if (pathStatus.state != AdvMotion_PathIntplLookaheadState.Stopped):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplLookahead Running timeout.!')
        return
    # Free the path interpolation with look ahead buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    if ret != 0:
        print('FreePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return


#``



# Write python code to Execute path interpolation with look ahead of Axis 2 and Axis 1 with velocity 1000, with a sample distance 50, and with the velocityLimit of axis 1 set to 500, consisting of four circular interpolations defined as (throughPos0,throughPos1,endPos0,endPos1): (50,50,100,0),(50,-50,0,0),(-50,50,-100,0),(-50,-50,0,0).
# Axes = [2, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplLookaheadCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    # Create the path interpolation with look ahead buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplLookaheadBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with look ahead channel
    conf = AdvMotion_PathIntplLookaheadConfiguration()

    conf.axisCount = 2
    conf.SetAxis(0, 2)
    conf.SetAxis(1, 1)
    conf.compositeVel = 1000
    conf.compositeAcc = 4000
    conf.sampleDistance = 50
    conf.stopOnEmptyBuffer = True
    conf.SetVelocityLimit(1, 500)

    ret = Wmx3Lib_adv.advMotion.SetPathIntplLookaheadConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplLookaheadConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Add the path interpolation with look ahead commands
    point = AdvMotion_PathIntplLookaheadCommand()
    path.numPoints = 4

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.ThroughAndEndCircular
    point.throughAndEndCircular.SetAxis(0, 2)
    point.throughAndEndCircular.SetAxis(1, 1)
    point.throughAndEndCircular.SetThroughPos(0, 50)
    point.throughAndEndCircular.SetThroughPos(1, 50)
    point.throughAndEndCircular.SetEndPos(0, 100)
    point.throughAndEndCircular.SetEndPos(1, 0)
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.ThroughAndEndCircular
    point.throughAndEndCircular.SetAxis(0, 2)
    point.throughAndEndCircular.SetAxis(1, 1)
    point.throughAndEndCircular.SetThroughPos(0, 50)
    point.throughAndEndCircular.SetThroughPos(1, -50)
    point.throughAndEndCircular.SetEndPos(0, 0)
    point.throughAndEndCircular.SetEndPos(1, 0)
    path.SetPoint(1, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.ThroughAndEndCircular
    point.throughAndEndCircular.SetAxis(0, 2)
    point.throughAndEndCircular.SetAxis(1, 1)
    point.throughAndEndCircular.SetThroughPos(0, -50)
    point.throughAndEndCircular.SetThroughPos(1, 50)
    point.throughAndEndCircular.SetEndPos(0, -100)
    point.throughAndEndCircular.SetEndPos(1, 0)
    path.SetPoint(2, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.ThroughAndEndCircular
    point.throughAndEndCircular.SetAxis(0, 2)
    point.throughAndEndCircular.SetAxis(1, 1)
    point.throughAndEndCircular.SetThroughPos(0, -50)
    point.throughAndEndCircular.SetThroughPos(1, -50)
    point.throughAndEndCircular.SetEndPos(0, 0)
    point.throughAndEndCircular.SetEndPos(1, 0)
    path.SetPoint(3, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplLookaheadCommand(0, path)
    if ret != 0:
        print('AddPathIntplLookaheadCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Execute path interpolation with look ahead
    ret = Wmx3Lib_adv.advMotion.StartPathIntplLookahead(0)
    if ret != 0:
        print('StartPathIntplLookahead error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the path interpolation with look ahead to complete
    Wmx3Lib_cm.motion.Wait(2)
    timeoutCounter = 0
    # Wait until the path interpolation with look ahead is in Stopped state
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    while True:
        if (pathStatus.state != AdvMotion_PathIntplLookaheadState.Stopped):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplLookahead Running timeout.!')
        return
    # Free the path interpolation with look ahead buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    if ret != 0:
        print('FreePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return


#``



# Write python code to Execute path interpolation with look ahead of Axis 9 and Axis 1 with velocity 1000, with a sample distance 2, consisting of two linear interpolations: (50,0),(50,50). After executing 0.1s, dynamically add two linear interpolations: (50,100),(100,100).
# Axes = [9, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplLookaheadCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    # Create the path interpolation with look ahead buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplLookaheadBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with look ahead channel
    conf = AdvMotion_PathIntplLookaheadConfiguration()

    conf.axisCount = 2
    conf.SetAxis(0, 9)
    conf.SetAxis(1, 1)
    conf.compositeVel = 1000
    conf.compositeAcc = 2000
    #  The commanded axes will automatically change to Idle operation state after all interpolation commands in the path have been executed.
    conf.stopOnEmptyBuffer = True
    # Sample the profile at every specified distance along the path, improving the granularity of the generated profile.
    conf.sampleDistance = 2

    ret = Wmx3Lib_adv.advMotion.SetPathIntplLookaheadConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplLookaheadConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Add the path interpolation with look ahead commands
    path.numPoints = 2

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 9)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 50)
    point.linear.SetTarget(1, 0)
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 9)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 50)
    point.linear.SetTarget(1, 50)
    path.SetPoint(1, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplLookaheadCommand(0, path)
    if ret != 0:
        print('AddPathIntplLookaheadCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Execute path interpolation with look ahead
    ret = Wmx3Lib_adv.advMotion.StartPathIntplLookahead(0)
    if ret != 0:
        print('StartPathIntplLookahead error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return
    
    sleep(0.1)

    point.linear.SetTarget(0, 50)
    point.linear.SetTarget(1, 100)
    path.SetPoint(0, point)
    point.linear.SetTarget(0, 100)
    point.linear.SetTarget(1, 100)
    path.SetPoint(1, point)       

    ret = Wmx3Lib_adv.advMotion.AddPathIntplLookaheadCommand(0, path)
    if ret != 0:
        print('AddPathIntplLookaheadCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the path interpolation with look ahead to complete
    Wmx3Lib_cm.motion.Wait(9)
    timeoutCounter = 0
    # Wait until the path interpolation with look ahead is in Stopped state
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    while True:
        if (pathStatus.state != AdvMotion_PathIntplLookaheadState.Stopped):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplLookahead Running timeout.!')
        return
    # Free the path interpolation with look ahead buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    if ret != 0:
        print('FreePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return


#``



# Write python code to Execute path interpolation with look ahead of Axis 8 and Axis 1 with velocity 1000, with a sample distance 100, consisting of four sequences: linear interpolations to (100,0), linear interpolations to (100,100), sleep 0.5s, linear interpolations to (0,0), while the smoothRadius is 30.
# Axes = [8, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplLookaheadCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    # Create the path interpolation with look ahead buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplLookaheadBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with look ahead channel
    conf = AdvMotion_PathIntplLookaheadConfiguration()

    conf.axisCount = 2
    conf.SetAxis(0, 8)
    conf.SetAxis(1, 1)
    conf.compositeVel = 1000
    conf.compositeAcc = 2000
    #  The commanded axes will automatically change to Idle operation state after all interpolation commands in the path have been executed.
    conf.stopOnEmptyBuffer = True
    # Sample the profile at every specified distance along the path, improving the granularity of the generated profile.
    conf.sampleDistance = 100

    ret = Wmx3Lib_adv.advMotion.SetPathIntplLookaheadConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplLookaheadConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Add the path interpolation with look ahead commands
    path.numPoints = 4

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 8)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 100)
    point.linear.SetTarget(1, 0)
    point.linear.smoothRadius = 30
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 8)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 100)
    point.linear.SetTarget(1, 100)
    point.linear.smoothRadius = 30
    path.SetPoint(1, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Sleep
    point.sleep.milliseconds = 500
    path.SetPoint(2, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 8)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 0)
    point.linear.SetTarget(1, 0)
    path.SetPoint(3, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplLookaheadCommand(0, path)
    if ret != 0:
        print('AddPathIntplLookaheadCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Execute path interpolation with look ahead
    ret = Wmx3Lib_adv.advMotion.StartPathIntplLookahead(0)
    if ret != 0:
        print('StartPathIntplLookahead error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the path interpolation with look ahead to complete
    Wmx3Lib_cm.motion.Wait(8)
    timeoutCounter = 0
    # Wait until the path interpolation with look ahead is in Stopped state
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    while True:
        if (pathStatus.state != AdvMotion_PathIntplLookaheadState.Stopped):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplLookahead Running timeout.!')
        return
    # Free the path interpolation with look ahead buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    if ret != 0:
        print('FreePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return


#``



# Write python code to Execute path interpolation with look ahead of Axis 7 and Axis 1 with velocity 1000, with a sample distance 100, consisting of eight sequences: linear interpolations to (100,0), linear interpolations to (100,100), linear interpolations to (60,100), set output 0.0 to 1, linear interpolations to (40,100),  set output 0.0 to 0, linear interpolations to (0,100), linear interpolations to (10,20), while the smoothRadius is 30.
# Axes = [7, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplLookaheadCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    # Create the path interpolation with look ahead buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplLookaheadBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with look ahead channel
    conf = AdvMotion_PathIntplLookaheadConfiguration()

    conf.axisCount = 2
    conf.SetAxis(0, 7)
    conf.SetAxis(1, 1)
    conf.compositeVel = 1000
    conf.compositeAcc = 2000
    #  The commanded axes will automatically change to Idle operation state after all interpolation commands in the path have been executed.
    conf.stopOnEmptyBuffer = True
    # Sample the profile at every specified distance along the path, improving the granularity of the generated profile.
    conf.sampleDistance = 100

    ret = Wmx3Lib_adv.advMotion.SetPathIntplLookaheadConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplLookaheadConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Add the path interpolation with look ahead commands
    path.numPoints = 8

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 7)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 100)
    point.linear.SetTarget(1, 0)
    point.linear.smoothRadius = 30
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 7)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 100)
    point.linear.SetTarget(1, 100)
    point.linear.smoothRadius = 30
    path.SetPoint(1, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 7)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 60)
    point.linear.SetTarget(1, 100)
    point.linear.smoothRadius = 30
    path.SetPoint(2, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.SetOutputBit
    point.setOutputBit.byteAddress = 0
    point.setOutputBit.bitAddress = 0
    point.setOutputBit.value = 1
    point.setOutputBit.type = AdvMotion_PathIntplOutputType.Immediate
    point.setOutputBit.source = AdvMotion_PathIntplOutputSource.IOOutput
    path.SetPoint(3, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 7)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 40)
    point.linear.SetTarget(1, 100)
    point.linear.smoothRadius = 30
    path.SetPoint(4, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.SetOutputBit
    point.setOutputBit.byteAddress = 0
    point.setOutputBit.bitAddress = 0
    point.setOutputBit.value = 0
    point.setOutputBit.type = AdvMotion_PathIntplOutputType.Immediate
    point.setOutputBit.source = AdvMotion_PathIntplOutputSource.IOOutput
    path.SetPoint(5, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 7)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 0)
    point.linear.SetTarget(1, 100)
    point.linear.smoothRadius = 30
    path.SetPoint(6, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 7)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 10)
    point.linear.SetTarget(1, 20)
    path.SetPoint(7, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplLookaheadCommand(0, path)
    if ret != 0:
        print('AddPathIntplLookaheadCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Execute path interpolation with look ahead
    ret = Wmx3Lib_adv.advMotion.StartPathIntplLookahead(0)
    if ret != 0:
        print('StartPathIntplLookahead error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the path interpolation with look ahead to complete
    Wmx3Lib_cm.motion.Wait(7)
    timeoutCounter = 0
    # Wait until the path interpolation with look ahead is in Stopped state
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    while True:
        if (pathStatus.state != AdvMotion_PathIntplLookaheadState.Stopped):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplLookahead Running timeout.!')
        return
    # Free the path interpolation with look ahead buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    if ret != 0:
        print('FreePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return


#``



# Write python code to Execute path interpolation with look ahead of Axis 6 and Axis 1 with velocity 1000, with a sample distance 100, consisting of two sequences: set output 0.0 to 1 when completed distance is 20, linear interpolations to (40,0).
# Axes = [6, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplLookaheadCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    # Create the path interpolation with look ahead buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplLookaheadBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with look ahead channel
    conf = AdvMotion_PathIntplLookaheadConfiguration()

    conf.axisCount = 2
    conf.SetAxis(0, 6)
    conf.SetAxis(1, 1)
    conf.compositeVel = 1000
    conf.compositeAcc = 2000
    conf.sampleDistance = 100
    conf.stopOnEmptyBuffer = True

    ret = Wmx3Lib_adv.advMotion.SetPathIntplLookaheadConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplLookaheadConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Add the path interpolation with look ahead commands
    path.numPoints = 2

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.SetOutputBit
    point.setOutputBit.byteAddress = 0
    point.setOutputBit.bitAddress = 0
    point.setOutputBit.value = 1
    point.setOutputBit.triggerValue = 20
    point.setOutputBit.type = AdvMotion_PathIntplOutputType.CompletedDist
    point.setOutputBit.source = AdvMotion_PathIntplOutputSource.IOOutput
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 6)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 40)
    point.linear.SetTarget(1, 0)
    path.SetPoint(1, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplLookaheadCommand(0, path)
    if ret != 0:
        print('AddPathIntplLookaheadCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Start path interpolation with look ahead
    ret = Wmx3Lib_adv.advMotion.StartPathIntplLookahead(0)
    if ret != 0:
        print('StartPathIntplLookahead error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the path interpolation with look ahead to complete
    Wmx3Lib_cm.motion.Wait(6)
    timeoutCounter = 0
    # Wait until the path interpolation with look ahead is in Stopped state
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    while True:
        if (pathStatus.state != AdvMotion_PathIntplLookaheadState.Stopped):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplLookahead Running timeout.!')
        return
    # Free the path interpolation with look ahead buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    if ret != 0:
        print('FreePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return


#``



# Write python code to Execute path interpolation with look ahead of Axis 5 and Axis 1 with velocity 1000, with a sample distance 100, consisting of three sequences: set output 0.0 to 1 when completed distance is 20, set output 0.0 to 1 when remaining distance is 10, linear interpolations to (40,0).
# Axes = [5, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplLookaheadCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    # Create the path interpolation with look ahead buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplLookaheadBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with look ahead channel
    conf = AdvMotion_PathIntplLookaheadConfiguration()

    conf.axisCount = 2
    conf.SetAxis(0, 5)
    conf.SetAxis(1, 1)
    conf.compositeVel = 1000
    conf.compositeAcc = 2000
    conf.sampleDistance = 100
    conf.stopOnEmptyBuffer = True

    ret = Wmx3Lib_adv.advMotion.SetPathIntplLookaheadConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplLookaheadConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Add the path interpolation with look ahead commands
    path.numPoints = 3

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.SetOutputBit
    point.setOutputBit.byteAddress = 0
    point.setOutputBit.bitAddress = 0
    point.setOutputBit.value = 1
    point.setOutputBit.triggerValue = 20
    point.setOutputBit.type = AdvMotion_PathIntplOutputType.CompletedDist
    point.setOutputBit.source = AdvMotion_PathIntplOutputSource.IOOutput
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.SetOutputBit
    point.setOutputBit.byteAddress = 0
    point.setOutputBit.bitAddress = 1
    point.setOutputBit.value = 1
    point.setOutputBit.triggerValue = 10
    point.setOutputBit.type = AdvMotion_PathIntplOutputType.RemainingDist
    point.setOutputBit.source = AdvMotion_PathIntplOutputSource.IOOutput
    path.SetPoint(1, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 5)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 40)
    point.linear.SetTarget(1, 0)
    path.SetPoint(2, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplLookaheadCommand(0, path)
    if ret != 0:
        print('AddPathIntplLookaheadCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Start path interpolation with look ahead
    ret = Wmx3Lib_adv.advMotion.StartPathIntplLookahead(0)
    if ret != 0:
        print('StartPathIntplLookahead error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the path interpolation with look ahead to complete
    Wmx3Lib_cm.motion.Wait(5)
    timeoutCounter = 0
    # Wait until the path interpolation with look ahead is in Stopped state
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    while True:
        if (pathStatus.state != AdvMotion_PathIntplLookaheadState.Stopped):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplLookahead Running timeout.!')
        return
    # Free the path interpolation with look ahead buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    if ret != 0:
        print('FreePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return


#``



# Write python code to Execute path interpolation with look ahead of Axis 4 and Axis 1 with velocity 1000, with a sample distance 100, consisting of three sequences: set output 0.0 to 1 when completed distance is 20, set output 0.0 to 1 when remaining distance is 10, linear interpolations to (40,0).
# Axes = [4, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplLookaheadCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    # Create the path interpolation with look ahead buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplLookaheadBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with look ahead channel
    conf = AdvMotion_PathIntplLookaheadConfiguration()

    conf.axisCount = 2
    conf.SetAxis(0, 4)
    conf.SetAxis(1, 1)
    conf.compositeVel = 1000
    conf.compositeAcc = 2000
    conf.sampleDistance = 100
    conf.stopOnEmptyBuffer = True

    ret = Wmx3Lib_adv.advMotion.SetPathIntplLookaheadConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplLookaheadConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Add the path interpolation with look ahead commands
    path.numPoints = 3

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.SetOutputBit
    point.setOutputBit.byteAddress = 0
    point.setOutputBit.bitAddress = 0
    point.setOutputBit.value = 1
    point.setOutputBit.triggerValue = 20
    point.setOutputBit.type = AdvMotion_PathIntplOutputType.CompletedDist
    point.setOutputBit.source = AdvMotion_PathIntplOutputSource.IOOutput
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.SetOutputBit
    point.setOutputBit.byteAddress = 0
    point.setOutputBit.bitAddress = 1
    point.setOutputBit.value = 1
    point.setOutputBit.triggerValue = 10
    point.setOutputBit.type = AdvMotion_PathIntplOutputType.RemainingDist
    point.setOutputBit.source = AdvMotion_PathIntplOutputSource.IOOutput
    path.SetPoint(1, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 4)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 40)
    point.linear.SetTarget(1, 0)
    path.SetPoint(2, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplLookaheadCommand(0, path)
    if ret != 0:
        print('AddPathIntplLookaheadCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Start path interpolation with look ahead
    ret = Wmx3Lib_adv.advMotion.StartPathIntplLookahead(0)
    if ret != 0:
        print('StartPathIntplLookahead error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the path interpolation with look ahead to complete
    Wmx3Lib_cm.motion.Wait(4)
    timeoutCounter = 0
    # Wait until the path interpolation with look ahead is in Stopped state
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    while True:
        if (pathStatus.state != AdvMotion_PathIntplLookaheadState.Stopped):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplLookahead Running timeout.!')
        return
    # Free the path interpolation with look ahead buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    if ret != 0:
        print('FreePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return


#``



# Write python code to Execute path interpolation with look ahead of Axis 3 and Axis 1 with velocity 1000, with a sample distance 10, consisting of four linear interpolations: (100,0) with velocity 900,(100,100) with velocity 700,(0,100) with velocity 500,(0,0) with velocity 300, while the smoothRadius is 30.
# Axes = [3, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplLookaheadCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    # Create the path interpolation with look ahead buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplLookaheadBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with look ahead channel
    conf = AdvMotion_PathIntplLookaheadConfiguration()

    conf.axisCount = 2
    conf.SetAxis(0, 3)
    conf.SetAxis(1, 1)
    conf.compositeVel = 1000
    conf.compositeAcc = 2000
    #  The commanded axes will automatically change to Idle operation state after all interpolation commands in the path have been executed.
    conf.stopOnEmptyBuffer = True
    # Sample the profile at every specified distance along the path, improving the granularity of the generated profile.
    conf.sampleDistance = 10

    ret = Wmx3Lib_adv.advMotion.SetPathIntplLookaheadConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplLookaheadConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Add the path interpolation with look ahead commands
    path.numPoints = 4

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 3)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 100)
    point.linear.SetTarget(1, 0)
    point.linear.smoothRadius = 30
    point.linear.setSegmentCompositeVel = 1
    point.linear.segmentCompositeVel = 900
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 3)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 100)
    point.linear.SetTarget(1, 100)
    point.linear.smoothRadius = 30
    point.linear.setSegmentCompositeVel = 1
    point.linear.segmentCompositeVel = 700
    path.SetPoint(1, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 3)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 0)
    point.linear.SetTarget(1, 100)
    point.linear.smoothRadius = 30
    point.linear.setSegmentCompositeVel = 1
    point.linear.segmentCompositeVel = 500
    path.SetPoint(2, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 3)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 0)
    point.linear.SetTarget(1, 0)
    point.linear.setSegmentCompositeVel = 1
    point.linear.segmentCompositeVel = 300
    path.SetPoint(3, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplLookaheadCommand(0, path)
    if ret != 0:
        print('AddPathIntplLookaheadCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Execute path interpolation with look ahead
    ret = Wmx3Lib_adv.advMotion.StartPathIntplLookahead(0)
    if ret != 0:
        print('StartPathIntplLookahead error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the path interpolation with look ahead to complete
    Wmx3Lib_cm.motion.Wait(3)
    timeoutCounter = 0
    # Wait until the path interpolation with look ahead is in Stopped state
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    while True:
        if (pathStatus.state != AdvMotion_PathIntplLookaheadState.Stopped):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplLookahead Runuing timeout.!')
        return
    # Free the path interpolation with look ahead buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    if ret != 0:
        print('FreePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return


#``



# Write python code to Execute path interpolation with look ahead of Axis 7, 1 and 2 with velocity 100, composite acceleration 1000, and the acceleration limit for Axis 7, 1 and 2 is 300, 600 and 900, with a sample distance 100, consisting of three linear interpolations: (40,60,70),(30,20,120),(0,0,0), while the smoothRadius is 5.
# Axes = [7, 1, 2]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplLookaheadCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    # Create the path interpolation with look ahead buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplLookaheadBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with look ahead channel
    conf = AdvMotion_PathIntplLookaheadConfiguration()

    conf.axisCount = 3
    conf.SetAxis(0, 7)
    conf.SetAxis(1, 1)
    conf.SetAxis(2, 2)
    conf.compositeVel = 100
    conf.compositeAcc = 1000
    conf.sampleDistance = 100
    conf.stopOnEmptyBuffer = True
    conf.SetAccLimit(0, 300)
    conf.SetAccLimit(1, 600)
    conf.SetAccLimit(2, 900)

    ret = Wmx3Lib_adv.advMotion.SetPathIntplLookaheadConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplLookaheadConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Add the path interpolation with look ahead commands
    path.numPoints = 3

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 3
    point.linear.SetAxis(0, 7)
    point.linear.SetAxis(1, 1)
    point.linear.SetAxis(2, 2)
    point.linear.SetTarget(0, 40)
    point.linear.SetTarget(1, 60)
    point.linear.SetTarget(2, 70)
    point.linear.smoothRadius = 5
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 3
    point.linear.SetAxis(0, 7)
    point.linear.SetAxis(1, 1)
    point.linear.SetAxis(2, 2)
    point.linear.SetTarget(0, 30)
    point.linear.SetTarget(1, 20)
    point.linear.SetTarget(2, 120)
    point.linear.smoothRadius = 5
    path.SetPoint(1, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 3
    point.linear.SetAxis(0, 7)
    point.linear.SetAxis(1, 1)
    point.linear.SetAxis(2, 2)
    point.linear.SetTarget(0, 0)
    point.linear.SetTarget(1, 0)
    point.linear.SetTarget(2, 0)
    path.SetPoint(2, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplLookaheadCommand(0, path)
    if ret != 0:
        print('AddPathIntplLookaheadCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Start path interpolation with look ahead
    ret = Wmx3Lib_adv.advMotion.StartPathIntplLookahead(0)
    if ret != 0:
        print('StartPathIntplLookahead error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the path interpolation with look ahead to complete
    Wmx3Lib_cm.motion.Wait(7)
    timeoutCounter = 0
    # Wait until the path interpolation with look ahead is in Stopped state
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    while True:
        if (pathStatus.state != AdvMotion_PathIntplLookaheadState.Stopped):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplLookahead Running timeout.!')
        return
    # Free the path interpolation with look ahead buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    if ret != 0:
        print('FreePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return


#``



# Write python code to Execute path interpolation with look ahead of Axis 8, 1 and 2 with velocity 1000, and Axis 3 as the auxiliary axis, consisting of two circular interpolations defined as (throughPos0,throughPos1,throughPos2,endPos0,endPos1,endPos2,auxiliaryTarget): (70.71,29.29,0,100,100,0,50),(29.29,70.71,0,0,0,0,100).
# Axes = [8, 1, 2, 3]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplLookaheadCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    # Create the path interpolation with look ahead buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplLookaheadBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with look ahead channel
    conf = AdvMotion_PathIntplLookaheadConfiguration()

    conf.axisCount = 4
    conf.SetAxis(0, 8)
    conf.SetAxis(1, 1)
    conf.SetAxis(2, 2)
    conf.SetAxis(3, 3)
    conf.compositeVel = 1000
    conf.compositeAcc = 4000
    conf.stopOnEmptyBuffer = True

    ret = Wmx3Lib_adv.advMotion.SetPathIntplLookaheadConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplLookaheadConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Add the path interpolation with look ahead commands
    path.numPoints = 2

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.ThroughAndEnd3DCircular
    point.throughAndEnd3DCircular.axisCount = 3
    point.throughAndEnd3DCircular.SetAxis(0, 8)
    point.throughAndEnd3DCircular.SetAxis(1, 1)
    point.throughAndEnd3DCircular.SetAxis(2, 2)
    point.throughAndEnd3DCircular.SetThroughPos(0, 70.71)
    point.throughAndEnd3DCircular.SetThroughPos(1, 29.29)
    point.throughAndEnd3DCircular.SetThroughPos(2, 0)
    point.throughAndEnd3DCircular.SetEndPos(0, 100)
    point.throughAndEnd3DCircular.SetEndPos(1, 100)
    point.throughAndEnd3DCircular.SetEndPos(2, 0)
    point.throughAndEnd3DCircular.auxiliaryAxisCount = 1
    point.throughAndEnd3DCircular.SetAuxiliaryAxis(0, 3)
    point.throughAndEnd3DCircular.SetAuxiliaryTarget(0, 50)
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.ThroughAndEnd3DCircular
    point.throughAndEnd3DCircular.axisCount = 3
    point.throughAndEnd3DCircular.SetAxis(0, 8)
    point.throughAndEnd3DCircular.SetAxis(1, 1)
    point.throughAndEnd3DCircular.SetAxis(2, 2)
    point.throughAndEnd3DCircular.SetThroughPos(0, 29.29)
    point.throughAndEnd3DCircular.SetThroughPos(1, 70.71)
    point.throughAndEnd3DCircular.SetThroughPos(2, 0)
    point.throughAndEnd3DCircular.SetEndPos(0, 0)
    point.throughAndEnd3DCircular.SetEndPos(1, 0)
    point.throughAndEnd3DCircular.SetEndPos(2, 0)
    point.throughAndEnd3DCircular.auxiliaryAxisCount = 1
    point.throughAndEnd3DCircular.SetAuxiliaryAxis(0, 3)
    point.throughAndEnd3DCircular.SetAuxiliaryTarget(0, 100)
    path.SetPoint(1, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplLookaheadCommand(0, path)
    if ret != 0:
        print('AddPathIntplLookaheadCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Start path interpolation with look ahead
    ret = Wmx3Lib_adv.advMotion.StartPathIntplLookahead(0)
    if ret != 0:
        print('StartPathIntplLookahead error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the path interpolation with look ahead to complete
    Wmx3Lib_cm.motion.Wait(8)
    timeoutCounter = 0
    # Wait until the path interpolation with look ahead is in Stopped state
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    while True:
        if (pathStatus.state != AdvMotion_PathIntplLookaheadState.Stopped):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplLookahead Running timeout.!')
        return
    # Free the path interpolation with look ahead buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    if ret != 0:
        print('FreePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return


#``



# Write Python code to establish a Normal type E-CAM (Electronic CAM) motion for master Axis 8 and slave Axis 9. Move Axis 8 to -200 with a velocity of 1000. Then set up an E-CAM table with the pairs (-100, 100), (-50, 150), (0, 100), (50, 50), and (100, 100) and start the E-CAM motion. Finally, move Axis 8 to 200.

    # Axes = [8, 9]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    # Start an absolute position command of Axis 8 to position -200 with 1000 velocity.
    # Create a command value.
    posCommand = Motion_PosCommand()
    posCommand.profile.type = ProfileType.Trapezoidal
    posCommand.axis = 8
    posCommand.target = -200
    posCommand.profile.velocity = 1000
    posCommand.profile.acc = 10000
    posCommand.profile.dec = 10000

    # Execute command to move to a specified absolute position. e.g. 'Move to Position -300..'
    ret = Wmx3Lib_cm.motion.StartPos(posCommand)
    if ret != 0:
        print('StartPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
    Wmx3Lib_cm.motion.Wait(8)

    # The following example illustrates a typical Normal type E-CAM table:
    #   Master Axis Position      Slave Axis Position
    #   -100                      100
    #   -50                       150
    #   0                         100
    #   50                        50
    #   100                       100

    ECAMdata = AdvSync_ECAMData()
    ECAMoption = AdvSync_ECAMOptions()

    ECAMoption.type = AdvSync_ECAMType.Normal
    # The master input is the command position of the master axis.
    ECAMoption.source.type = AdvSync_ECAMSourceType.MasterCommandPos
    # PyNone: When the E-CAM is activated, the slave axis synchronizes with the master axis immediately.
    ECAMoption.clutch.type = AdvSync_ECAMClutchType.PyNone
    # In the AdvSync.ECAMClutchType.SimpleCatchUp mode, it is used to track the speed of the master-slave curve in the E-CAM table.
    ECAMoption.clutch.simpleCatchUpVelocity = 1000
    # In the AdvSync.ECAMClutchType.SimpleCatchUp mode, it is used to catch up with the acceleration and deceleration of the master-slave curve in the E-CAM table.
    ECAMoption.clutch.simpleCatchUpAcc = 10000

    # Set the E-CAM table.
    ECAMdata.masterAxis = 8
    ECAMdata.slaveAxis = 9
    ECAMdata.numPoints = 5
    ECAMdata.options = ECAMoption

    ECAMdata.SetMasterPos(0, -100)
    ECAMdata.SetMasterPos(1, -50)
    ECAMdata.SetMasterPos(2, 0)
    ECAMdata.SetMasterPos(3, 50)
    ECAMdata.SetMasterPos(4, 100)

    ECAMdata.SetSlavePos(0, 100)
    ECAMdata.SetSlavePos(1, 150)
    ECAMdata.SetSlavePos(2, 100)
    ECAMdata.SetSlavePos(3, 50)
    ECAMdata.SetSlavePos(4, 100)

    # Start ECAM
    ret = Wmx3Lib_adv.advSync.StartECAM(0, ECAMdata)
    if ret != 0:
        print('StartECAM error code is ' + str(ret) + ': ' + Wmx3Lib.ErrorToString(ret))
        return

    # Create a command value with a target value of 200.
    posCommand = Motion_PosCommand()
    posCommand.profile.type = ProfileType.Trapezoidal
    posCommand.axis = 8
    posCommand.target = 200
    posCommand.profile.velocity = 1000
    posCommand.profile.acc = 10000
    posCommand.profile.dec = 10000

    # Execute command to move from current position to specified absolute position.
    ret = Wmx3Lib_cm.motion.StartPos(posCommand)
    if ret != 0:
        print('StartPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until the axis moves to the target position and stops.
    Wmx3Lib_cm.motion.Wait(8)

    # Stop ECAM is a necessary step! 
    ret = Wmx3Lib_adv.advSync.StopECAM(0)
    if ret != 0:
        print('StopECAM error code is ' + str(ret) + ': ' + Wmx3Lib.ErrorToString(ret))
        return


#``



# Write Python code to establish a Periodic type E-CAM (Electronic CAM) motion for master Axis 8 and slave Axis 9. Move Axis 8 to -400 with a velocity of 1000. Then set up an E-CAM table with the pairs (-100, 100), (-50, 150), (0, 100), (50, 50), and (100, 100) and start the E-CAM motion. Finally, move Axis 8 to 400.

    # Axes = [8, 9]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    # Start an absolute position command of Axis 8 to position -200 with 1000 velocity.
    # Create a command value.
    posCommand = Motion_PosCommand()
    posCommand.profile.type = ProfileType.Trapezoidal
    posCommand.axis = 8
    posCommand.target = -400
    posCommand.profile.velocity = 1000
    posCommand.profile.acc = 10000
    posCommand.profile.dec = 10000

    # Execute command to move to a specified absolute position. e.g. 'Move to Position -300..'
    ret = Wmx3Lib_cm.motion.StartPos(posCommand)
    if ret != 0:
        print('StartPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
    Wmx3Lib_cm.motion.Wait(8)

    # The following example illustrates a typical Normal type E-CAM table:
    #   Master Axis Position      Slave Axis Position
    #   -100                      100
    #   -50                       150
    #   0                         100
    #   50                        50
    #   100                       100

    ECAMdata = AdvSync_ECAMData()
    ECAMoption = AdvSync_ECAMOptions()

    # The master-slave position curve will be repeated when the master axis moves outside the range defined in the E-CAM table.
    ECAMoption.type = AdvSync_ECAMType.Periodic
    # The master input is the command position of the master axis.
    ECAMoption.source.type = AdvSync_ECAMSourceType.MasterCommandPos
    # PyNone: When the E-CAM is activated, the slave axis synchronizes with the master axis immediately.
    ECAMoption.clutch.type = AdvSync_ECAMClutchType.PyNone
    # In the AdvSync.ECAMClutchType.SimpleCatchUp mode, it is used to track the speed of the master-slave curve in the E-CAM table.
    ECAMoption.clutch.simpleCatchUpVelocity = 1000
    # In the AdvSync.ECAMClutchType.SimpleCatchUp mode, it is used to catch up with the acceleration and deceleration of the master-slave curve in the E-CAM table.
    ECAMoption.clutch.simpleCatchUpAcc = 10000

    # Set the E-CAM table.
    ECAMdata.masterAxis = 8
    ECAMdata.slaveAxis = 9
    ECAMdata.numPoints = 5
    ECAMdata.options = ECAMoption

    ECAMdata.SetMasterPos(0, -100)
    ECAMdata.SetMasterPos(1, -50)
    ECAMdata.SetMasterPos(2, 0)
    ECAMdata.SetMasterPos(3, 50)
    ECAMdata.SetMasterPos(4, 100)

    ECAMdata.SetSlavePos(0, 100)
    ECAMdata.SetSlavePos(1, 150)
    ECAMdata.SetSlavePos(2, 100)
    ECAMdata.SetSlavePos(3, 50)
    ECAMdata.SetSlavePos(4, 100)

    # Start ECAM
    ret = Wmx3Lib_adv.advSync.StartECAM(0, ECAMdata)
    if ret != 0:
        print('StartECAM error code is ' + str(ret) + ': ' + Wmx3Lib.ErrorToString(ret))
        return

    # Create a command value with a target value of 200.
    posCommand = Motion_PosCommand()
    posCommand.profile.type = ProfileType.Trapezoidal
    posCommand.axis = 8
    posCommand.target = 400
    posCommand.profile.velocity = 1000
    posCommand.profile.acc = 10000
    posCommand.profile.dec = 10000

    # Execute command to move from current position to specified absolute position.
    ret = Wmx3Lib_cm.motion.StartPos(posCommand)
    if ret != 0:
        print('StartPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until the axis moves to the target position and stops.
    Wmx3Lib_cm.motion.Wait(8)

    # Stop ECAM is a necessary step! 
    ret = Wmx3Lib_adv.advSync.StopECAM(0)
    if ret != 0:
        print('StopECAM error code is ' + str(ret) + ': ' + Wmx3Lib.ErrorToString(ret))
        return


#``



# Write Python code to establish a Periodic type E-CAM (Electronic CAM) motion for master Axis 8 and slave Axis 9. Move Axis 8 to -400 with a velocity of 1000. Then set up an E-CAM table with the pairs (-50, 150), (0, 100), (50, 50), (100, 100) and start the E-CAM motion. Finally, move Axis 8 to 400.

# Axes = [8, 9]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    # Start an absolute position command of Axis 8 to position -200 with 1000 velocity.
    # Create a command value.
    posCommand = Motion_PosCommand()
    posCommand.profile.type = ProfileType.Trapezoidal
    posCommand.axis = 8
    posCommand.target = -400
    posCommand.profile.velocity = 1000
    posCommand.profile.acc = 10000
    posCommand.profile.dec = 10000

    # Execute command to move to a specified absolute position. e.g. 'Move to Position -300..'
    ret = Wmx3Lib_cm.motion.StartPos(posCommand)
    if ret != 0:
        print('StartPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
    Wmx3Lib_cm.motion.Wait(8)

    # The following example illustrates a typical Periodic type E-CAM table:
    #   Master Axis Position      Slave Axis Position
    #   -50                       150
    #   0                         100
    #   50                        50
    #   100                       100

    ECAMdata = AdvSync_ECAMData()
    ECAMoption = AdvSync_ECAMOptions()

    # The master-slave position curve will be repeated when the master axis moves outside the range defined in the E-CAM table. When the Periodic type, if the slave command positions of the first and last points in the E-CAM table are not equal, there will be a sudden change in the slave command position at each interface where the first and last points meet.
    ECAMoption.type = AdvSync_ECAMType.Periodic
    # The master input is the command position of the master axis.
    ECAMoption.source.type = AdvSync_ECAMSourceType.MasterCommandPos
    # PyNone: When the E-CAM is activated, the slave axis synchronizes with the master axis immediately.
    ECAMoption.clutch.type = AdvSync_ECAMClutchType.PyNone
    # In the AdvSync.ECAMClutchType.SimpleCatchUp mode, it is used to track the speed of the master-slave curve in the E-CAM table.
    ECAMoption.clutch.simpleCatchUpVelocity = 1000
    # In the AdvSync.ECAMClutchType.SimpleCatchUp mode, it is used to catch up with the acceleration and deceleration of the master-slave curve in the E-CAM table.
    ECAMoption.clutch.simpleCatchUpAcc = 10000

    # Set the E-CAM table.
    ECAMdata.masterAxis = 8
    ECAMdata.slaveAxis = 9
    ECAMdata.numPoints = 4
    ECAMdata.options = ECAMoption

    ECAMdata.SetMasterPos(0, -50)
    ECAMdata.SetMasterPos(1, 0)
    ECAMdata.SetMasterPos(2, 50)
    ECAMdata.SetMasterPos(3, 100)

    ECAMdata.SetSlavePos(0, 150)
    ECAMdata.SetSlavePos(1, 100)
    ECAMdata.SetSlavePos(2, 50)
    ECAMdata.SetSlavePos(3, 100)

    # Start ECAM in channel 0
    ret = Wmx3Lib_adv.advSync.StartECAM(0, ECAMdata) 
    if ret != 0:
        print('StartECAM error code is ' + str(ret) + ': ' + Wmx3Lib.ErrorToString(ret))
        return

    # Create a command value with a target value of 200.
    posCommand = Motion_PosCommand()
    posCommand.profile.type = ProfileType.Trapezoidal
    posCommand.axis = 8
    posCommand.target = 400
    posCommand.profile.velocity = 1000
    posCommand.profile.acc = 10000
    posCommand.profile.dec = 10000

    # Execute command to move from current position to specified absolute position.
    ret = Wmx3Lib_cm.motion.StartPos(posCommand)
    if ret != 0:
        print('StartPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until the axis moves to the target position and stops.
    Wmx3Lib_cm.motion.Wait(8)

    # Stop ECAM is a necessary step! 
    ret = Wmx3Lib_adv.advSync.StopECAM(0)
    if ret != 0:
        print('StopECAM error code is ' + str(ret) + ': ' + Wmx3Lib.ErrorToString(ret))
        return


#``



# Write Python code to create a Periodic E-CAM table corresponding to the master axis 6's positions (50, 150, 250) and the slave axis 9's positions (100, 200, 100). The master axis is set to single-turn mode, with the encoder range being 0-360000. Then establishes the E-CAM table, and subsequently moves from the position of 0 to 300 at a speed of 1000.
# Axes = [6, 9]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    # Set Axis 6 to single-turn mode, single-turn encoder count 360000.
    ret = Wmx3Lib_cm.config.SetSingleTurn(6, True, 360000)
    if ret != 0:
        print('SetSingleTurn error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # The following example illustrates a typical Periodic type E-CAM table:
    #   Master Axis Position      Slave Axis Position
    #   50                        100
    #   150                       200
    #   250                       100

    ECAMdata = AdvSync_ECAMData()
    ECAMoption = AdvSync_ECAMOptions()

    # The master-slave position curve will be repeated when the master axis moves outside the range defined in the E-CAM table.
    ECAMoption.type = AdvSync_ECAMType.Periodic
    # The master input is the command position of the master axis.
    ECAMoption.source.type = AdvSync_ECAMSourceType.MasterCommandPos
    # PyNone: When the E-CAM is activated, the slave axis synchronizes with the master axis immediately.
    ECAMoption.clutch.type = AdvSync_ECAMClutchType.PyNone
    # In the AdvSync.ECAMClutchType.SimpleCatchUp mode, it is used to track the speed of the master-slave curve in the E-CAM table.
    ECAMoption.clutch.simpleCatchUpVelocity = 1000
    # In the AdvSync.ECAMClutchType.SimpleCatchUp mode, it is used to catch up with the acceleration and deceleration of the master-slave curve in the E-CAM table.
    ECAMoption.clutch.simpleCatchUpAcc = 10000

    # Set the E-CAM table.
    ECAMdata.masterAxis = 6
    ECAMdata.slaveAxis = 9
    ECAMdata.numPoints = 3
    ECAMdata.options = ECAMoption

    ECAMdata.SetMasterPos(0, 50)
    ECAMdata.SetMasterPos(1, 150)
    ECAMdata.SetMasterPos(2, 250)

    ECAMdata.SetSlavePos(0, 100)
    ECAMdata.SetSlavePos(1, 200)
    ECAMdata.SetSlavePos(2, 100)

    # Start ECAM
    ret = Wmx3Lib_adv.advSync.StartECAM(0, ECAMdata)
    if ret != 0:
        print('StartECAM error code is ' + str(ret) + ': ' + Wmx3Lib.ErrorToString(ret))
        return

    # Create a command value of target as 300.
    posCommand = Motion_PosCommand()
    posCommand.profile.type = ProfileType.Trapezoidal
    posCommand.axis = 6
    posCommand.target = 300
    posCommand.profile.velocity = 100
    posCommand.profile.acc = 1000
    posCommand.profile.dec = 1000

    # Execute command to move from current position to specified absolute position.
    ret = Wmx3Lib_cm.motion.StartPos(posCommand)
    if ret != 0:
        print('StartPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until the axis moves to the target position and stops.
    Wmx3Lib_cm.motion.Wait(6)

    # Turn off Axis 6 single-turn mode.
    AxisParam = Config_AxisParam()
    ret, AxisParam = Wmx3Lib_cm.config.GetAxisParam()
    AxisParam.SetSingleTurnMode(6, False)

    ret, AxisParamError = Wmx3Lib_cm.config.SetAxisParam(AxisParam)
    if ret != 0:
        print('Close SingleTurnMode error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Stop ECAM is a necessary step!
    ret = Wmx3Lib_adv.advSync.StopECAM(0)
    if ret != 0:
        print('StopECAM error code is ' + str(ret) + ': ' + Wmx3Lib.ErrorToString(ret))
        return


#``



# Write Python code to establish a Repeat type E-CAM (Electronic CAM) motion for master Axis 6 and slave Axis 8. Move Axis 6 to -200 with a velocity of 1000. Then set up an E-CAM table with the pairs (0, 25), (50, 75), (100, 50), (150, 100) and start the E-CAM motion. Finally, move Axis 6 to 300.
# Axes = [6, 8]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    # Create a command value with a target value of -200.
    posCommand = Motion_PosCommand()
    posCommand.profile.type = ProfileType.Trapezoidal
    posCommand.axis = 6
    posCommand.target = -200
    posCommand.profile.velocity = 1000
    posCommand.profile.acc = 1000
    posCommand.profile.dec = 1000

    # Execute command to move from current position to specified absolute position.
    ret = Wmx3Lib_cm.motion.StartPos(posCommand)
    if ret != 0:
        print('StartPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until the axis moves to the target position and stops.
    Wmx3Lib_cm.motion.Wait(6)

    # The following example illustrates a typical Repeat type E-CAM table:
    #   Master Axis Position      Slave Axis Position
    #   0                         25
    #   50                        75
    #   100                       50
    #   150                       100

    ECAMdata = AdvSync_ECAMData()
    ECAMoption = AdvSync_ECAMOptions()

    # The master-slave position curve will be repeated while preserving the slave axis position when the master axis moves outside or wraps around the range defined in the E-CAM table.
    ECAMoption.type = AdvSync_ECAMType.Repeat
    # The master input is the command position of the master axis.
    ECAMoption.source.type = AdvSync_ECAMSourceType.MasterCommandPos
    # PyNone: When the E-CAM is activated, the slave axis synchronizes with the master axis immediately.
    ECAMoption.clutch.type = AdvSync_ECAMClutchType.PyNone
    # In the AdvSync.ECAMClutchType.SimpleCatchUp mode, it is used to track the speed of the master-slave curve in the E-CAM table.
    ECAMoption.clutch.simpleCatchUpVelocity = 1000
    # In the AdvSync.ECAMClutchType.SimpleCatchUp mode, it is used to catch up with the acceleration and deceleration of the master-slave curve in the E-CAM table.
    ECAMoption.clutch.simpleCatchUpAcc = 10000

    # Set the E-CAM table.
    ECAMdata.masterAxis = 6
    ECAMdata.slaveAxis = 8
    ECAMdata.numPoints = 4
    ECAMdata.options = ECAMoption

    ECAMdata.SetMasterPos(0, 0)
    ECAMdata.SetMasterPos(1, 50)
    ECAMdata.SetMasterPos(2, 100)
    ECAMdata.SetMasterPos(3, 150)

    ECAMdata.SetSlavePos(0, 25)
    ECAMdata.SetSlavePos(1, 75)
    ECAMdata.SetSlavePos(2, 50)
    ECAMdata.SetSlavePos(3, 100)

    # Start ECAM
    ret = Wmx3Lib_adv.advSync.StartECAM(0, ECAMdata)
    if ret != 0:
        print('StartECAM error code is ' + str(ret) + ': ' + Wmx3Lib.ErrorToString(ret))
        return

    # Create a command value with a target value of 300.
    posCommand = Motion_PosCommand()
    posCommand.profile.type = ProfileType.Trapezoidal
    posCommand.axis = 6
    posCommand.target = 300
    posCommand.profile.velocity = 1000
    posCommand.profile.acc = 10000
    posCommand.profile.dec = 10000

    # Execute command to move from current position to specified absolute position.
    ret = Wmx3Lib_cm.motion.StartPos(posCommand)
    if ret != 0:
        print('StartPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until the axis moves to the target position and stops.
    Wmx3Lib_cm.motion.Wait(6)

    # Stop ECAM is a necessary step! 
    ret = Wmx3Lib_adv.advSync.StopECAM(0)
    if ret != 0:
        print('StopECAM error code is ' + str(ret) + ': ' + Wmx3Lib.ErrorToString(ret))
        return


#``



# Write Python code to establish a Repeat type E-CAM (Electronic CAM) motion for master Axis 6 and slave Axis 8. Set the master axis to single-turn mode with a range of 0-360 degree. Set up an E-CAM table with the pairs (0, 25), (50, 75), (100, 50), (150, 100) and start the E-CAM motion. and move from position 0 to 1500 at a speed of 1000.

    # Axes = [0, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    #Set Axis 0 to single-turn mode, single-turn encoder count 360000.
    ret=Wmx3Lib_cm.config.SetSingleTurn(0,True,360000)
    if ret != 0:
        print('SetSingleTurn error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # The following example illustrates a typical Repeat type E-CAM table:
    #   Master Axis Position      Slave Axis Position
    #   0                         25
    #   50                        75
    #   100                       50
    #   150                       100

    ECAMdata =AdvSync_ECAMData()
    ecopt =AdvSync_ECAMOptions()

    ecopt.type=AdvSync_ECAMType.Repeat
    ecopt.source.type=AdvSync_ECAMSourceType.MasterCommandPos
    #PyNone: When the E-CAM is activated, the slave axis synchronizes with the master axis immediately.
    ecopt.clutch.type=AdvSync_ECAMClutchType.PyNone
    #In the AdvSync.ECAMClutchType.SimpleCatchUp mode, it is used to track the speed of the master-slave curve in the E-CAM table.
    ecopt.clutch.simpleCatchUpVelocity=1000
    #In the AdvSync.ECAMClutchType.SimpleCatchUp mode, it is used to catch up with the acceleration and deceleration of the master-slave curve in the E-CAM table.
    ecopt.clutch.simpleCatchUpAcc=10000

    #Set the E-CAM table.
    ECAMdata.masterAxis=0
    ECAMdata.slaveAxis=1
    ECAMdata.numPoints=4
    ECAMdata.options=ecopt

    ECAMdata.SetMasterPos(0, 0)
    ECAMdata.SetMasterPos(1, 50)
    ECAMdata.SetMasterPos(2, 100)
    ECAMdata.SetMasterPos(3, 150)

    ECAMdata.SetSlavePos(0, 25)
    ECAMdata.SetSlavePos(1, 75)
    ECAMdata.SetSlavePos(2, 50)
    ECAMdata.SetSlavePos(3, 100)

    # Start ECAM
    ret=Wmx3Lib_adv.advSync.StartECAM(0,ECAMdata)
    if ret!=0:
        print('StartECAM error code is ' + str(ret) + ': ' + Wmx3Lib.ErrorToString(ret))
        return

    #Create a command value with a target value of 1500.
    posCommand = Motion_PosCommand()
    posCommand.profile.type = ProfileType.Trapezoidal
    posCommand.axis = 0
    posCommand.target = 1500
    posCommand.profile.velocity = 1000
    posCommand.profile.acc = 10000
    posCommand.profile.dec = 10000

    # Execute command to move from current position to specified absolute position.
    ret = Wmx3Lib_cm.motion.StartPos(posCommand)
    if ret!=0:
        print('StartPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until the axis moves to the target position and stops.
    Wmx3Lib_cm.motion.Wait(0)

    #Turn off Axis 0 single-turn mode.
    AxisParam=Config_AxisParam()
    ret,AxisParam =Wmx3Lib_cm.config.GetAxisParam()
    AxisParam.SetSingleTurnMode(0,False)

    ret,AxisParamError=Wmx3Lib_cm.config.SetAxisParam(AxisParam)
    if ret != 0:
        print('Close SingleTurnMode error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Stop ECAM is a necessary step! 
    ret = Wmx3Lib_adv.advSync.StopECAM(0)
    if ret != 0:
        print('StopECAM error code is ' + str(ret) + ': ' + Wmx3Lib.ErrorToString(ret))
        return


#``



# Write Python code to record and execute an API buffer with : Axis 4 moves to the target position of 150 at a speed of 100. When the RemainingTime is 3ms, it then moves to the target position of 250 at a speed of 2000. When the RemainingTime is again 3ms, it finally moves to the target position of 400 at a speed of 3000.

# Axes = [4]

    Wmx3Lib_buf = ApiBuffer(Wmx3Lib)
    #  Clear the buffer of the specified channel.
    Wmx3Lib_buf.Clear(0)
    # Create a buffer for the specified channel.
    Wmx3Lib_buf.CreateApiBuffer(0, 1024 * 1024 * 3)
    # Start recording for the specified channel.
    Wmx3Lib_buf.StartRecordBufferChannel(0)

    cond =ApiBufferCondition()

    # Add a position command to the API buffer.
    posCommand = Motion_PosCommand()
    posCommand.profile.type = ProfileType.Trapezoidal
    posCommand.axis = 4
    posCommand.target = 150
    posCommand.profile.velocity = 100
    posCommand.profile.endVelocity=100
    posCommand.profile.acc = 1000
    posCommand.profile.dec = 1000

    # Execute command to move to a specified absolute position.
    ret=Wmx3Lib_cm.motion.StartPos(posCommand)
    if ret != 0:
        print('StartPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    #Wait for position command to have 3ms remaining time
    cond.bufferConditionType=ApiBufferConditionType.RemainingTime
    cond.arg_remainingTime.axis=4
    cond.arg_remainingTime.timeMilliseconds=3
    Wmx3Lib_buf.Wait_ApiBufferCondition(cond)

    #Add a position command to the API buffer
    posCommand.axis = 4
    posCommand.target = 250
    posCommand.profile.velocity = 200
    posCommand.profile.endVelocity=2000
    posCommand.profile.acc = 10000
    posCommand.profile.dec = 10000

    # Execute command to move to a specified absolute position.
    ret =Wmx3Lib_cm.motion.StartPos(posCommand)
    if ret != 0:
        print('StartPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    #Wait for position command to have 3ms remaining time
    Wmx3Lib_buf.Wait_ApiBufferCondition(cond)

    #Add a position command to the API buffer
    posCommand.axis = 4
    posCommand.target = 400
    posCommand.profile.velocity = 3000
    posCommand.profile.endVelocity=0
    posCommand.profile.acc = 10000
    posCommand.profile.dec = 10000

    # Execute command to move to a specified absolute position.
    ret =Wmx3Lib_cm.motion.StartPos(posCommand)
    if ret != 0:
        print('StartPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # End Recording.
    Wmx3Lib_buf.EndRecordBufferChannel()
    # Drive the motion accumulated in the buffer so far.
    Wmx3Lib_buf.Execute(0)

    # Wait for the motion to complete. Start a blocking wait command, returning only when Axis 0 and Axis 1 become idle.

    ret = Wmx3Lib_cm.motion.Wait(4)
    if ret != 0:
        print('Wait error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Destroy API buffer resources.
    Wmx3Lib_buf.Halt(0)
    Wmx3Lib_buf.FreeApiBuffer(0)



#``



# Write Python code to record and execute an API buffer with :Move Axis 3 and 4 to a relative position of 50 at a speed of 1000. After executing, rewind the apibuffer once.
# Axes = [3, 4]

    Wmx3Lib_buf = ApiBuffer(Wmx3Lib)
    bufStatus = ApiBufferStatus()

    # Clear the buffer of the specified channel.
    Wmx3Lib_buf.Clear(0)
    # Create a buffer for the specified channel.
    Wmx3Lib_buf.CreateApiBuffer(0, 1024 * 1024 * 3)
    # Start recording for the specified channel.
    Wmx3Lib_buf.StartRecordBufferChannel(0)

    cond = ApiBufferCondition()

    # Add a position command to the API buffer.
    posCommand = Motion_PosCommand()
    posCommand.profile.type = ProfileType.Trapezoidal
    posCommand.axis = 3
    posCommand.target = 50
    posCommand.profile.velocity = 1000
    posCommand.profile.acc = 10000
    posCommand.profile.dec = 10000

    # Execute command to move to a specified relative position.
    ret = Wmx3Lib_cm.motion.StartMov(posCommand)
    if ret != 0:
        print('StartMov error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Add a position command to the API buffer
    posCommand.axis = 4
    # Execute command to move to a specified relative position.
    ret = Wmx3Lib_cm.motion.StartMov(posCommand)
    if ret != 0:
        print('StartMov error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Pause execution until both axes have finished motion
    Wmx3Lib_buf.Wait(3)
    Wmx3Lib_buf.Wait(4)

    # End Recording.
    Wmx3Lib_buf.EndRecordBufferChannel()
    # Drive the motion accumulated in the buffer so far.
    Wmx3Lib_buf.Execute(0)

    # Check the status periodically to see if execution has finished
    counter = 50
    while True:
        ret, bufStatus = Wmx3Lib_buf.GetStatus(0)
        sleep(0.01)
        counter = counter - 1
        if (bufStatus.remainingBlockCount <= 0 and counter <= 0):
            break

    # Rewind the buffer, and then execute it again
    Wmx3Lib_buf.Rewind(0)

    # Wait for the axis to complete motion
    Wmx3Lib_cm.motion.Wait(3)
    Wmx3Lib_cm.motion.Wait(4)

    # Destroy API buffer resources.
    Wmx3Lib_buf.Halt(0)
    Wmx3Lib_buf.FreeApiBuffer(0)


#``



# Write Python code to record and execute an API buffer with :Move Axis 3 to a relative position of 100 at a speed of 1000. Then it move to a relative position of -100. Auto Rewind is enabled. After executing, the api buffer will auto rewind and stop after 3s.
# Axes = [3]

    Wmx3Lib_buf = ApiBuffer(Wmx3Lib)
    opt=ApiBufferOptions()

    #  Clear the buffer of the specified channel.
    Wmx3Lib_buf.Clear(0)
    # Create a buffer for the specified channel.
    Wmx3Lib_buf.CreateApiBuffer(0, 1024 * 1024 * 3)
    # Start recording for the specified channel.
    Wmx3Lib_buf.StartRecordBufferChannel(0)

    cond =ApiBufferCondition()

    # Add a position command to the API buffer.
    posCommand = Motion_PosCommand()
    posCommand.profile.type = ProfileType.Trapezoidal
    posCommand.axis = 3
    posCommand.target = 100
    posCommand.profile.velocity = 1000
    posCommand.profile.acc = 10000
    posCommand.profile.dec = 10000

    # Execute command to move to a specified relative position.
    ret=Wmx3Lib_cm.motion.StartMov(posCommand)
    if ret != 0:
        print('StartMov error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    #Pause execution until both axes have finished motion
    Wmx3Lib_buf.Wait(3)

    #Add a position command to the API buffer
    posCommand.target =-100
    # Execute command to move to a specified relative position.
    ret=Wmx3Lib_cm.motion.StartMov(posCommand)
    if ret != 0:
        print('StartMov error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    #Pause execution until both axes have finished motion
    Wmx3Lib_buf.Wait(3)

    # End Recording.
    Wmx3Lib_buf.EndRecordBufferChannel()

    #Set the API buffer execution options
    opt.autoRewind=True
    Wmx3Lib_buf.SetOptions(0,opt)

    # Drive the motion accumulated in the buffer so far.
    Wmx3Lib_buf.Execute(0)

    #After a delay of 10 seconds, a stop function is called to forcibly halt the execution.
    sleep(3)

    # Destroy API buffer resources.
    Wmx3Lib_buf.Halt(0)
    Wmx3Lib_buf.FreeApiBuffer(0)



#``



# Write Python code to run an API buffer, if output 2.6 equals 1, move Axis 5 as a distance of 100, otherwise move as a distance of -100.
# Axes = [5]

    Wmx3Lib_buf = ApiBuffer(Wmx3Lib)
    cond = ApiBufferCondition()

    # Clear the buffer of the specified channel.
    Wmx3Lib_buf.Clear(0)
    # Create a buffer for the specified channel.
    Wmx3Lib_buf.CreateApiBuffer(0, 1024 * 1024 * 3)
    # Start recording for the specified channel.
    Wmx3Lib_buf.StartRecordBufferChannel(0)

    cond = ApiBufferCondition()
    opt = ApiBufferOptions()

    # Add a position command to the API buffer.
    posCommand = Motion_PosCommand()
    posCommand.profile.type = ProfileType.Trapezoidal
    posCommand.target = 100
    posCommand.profile.velocity = 1000
    posCommand.profile.acc = 10000
    posCommand.profile.dec = 10000

    # Set the IF branch
    cond.bufferConditionType = ApiBufferConditionType.IOOutput
    cond.arg_ioOutput.byteAddress = 2
    cond.arg_ioOutput.bitAddress = 6
    Wmx3Lib_buf.FlowIf(cond)

    # Add position command
    posCommand.axis = 5
    posCommand.target = 100

    # Execute command to move to a specified relative position.
    ret = Wmx3Lib_cm.motion.StartMov(posCommand)
    if ret != 0:
        print('StartMov error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Set the ELSE branch
    Wmx3Lib_buf.FlowElse()

    # Add position command
    posCommand.axis = 5
    posCommand.target = -100

    # Execute command to move to a specified relative position.
    ret = Wmx3Lib_cm.motion.StartMov(posCommand)
    if ret != 0:
        print('StartMov error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Set the END IF
    Wmx3Lib_buf.FlowEndIf()

    # End Recording.
    Wmx3Lib_buf.EndRecordBufferChannel()

    Wmx3Lib_buf.Execute(0)

    # Wait for the axis 5 motion to complete.
    Wmx3Lib_cm.motion.Wait(5)

    # Destroy API buffer resources.
    Wmx3Lib_buf.Halt(0)
    Wmx3Lib_buf.FreeApiBuffer(0)


#``



# Write Python code to run an API buffer to linearly interpolate Axis 5 and Axis 7 to (200, 0) at a speed of 1000. Set a condition when it begins deceleration, then linearly interpolate to (200, 200), (0, 200), and (0, 0), respectively.
# Axes = [5, 7]

    # Record and execute an API buffer with :
    Wmx3Lib_buf = ApiBuffer(Wmx3Lib)
    cond = ApiBufferCondition()

    # Clear the buffer of the specified channel.
    Wmx3Lib_buf.Clear(0)
    # Create a buffer for the specified channel.
    Wmx3Lib_buf.CreateApiBuffer(0, 1024 * 1024 * 5)
    # Start recording for the specified channel.
    Wmx3Lib_buf.StartRecordBufferChannel(0)

    cond = ApiBufferCondition()
    lin = Motion_LinearIntplCommand()

    # First linear interpolation (0, 0) -> (200, 0)
    lin.axisCount = 2
    lin.SetAxis(0, 5)
    lin.SetAxis(1, 7)
    lin.profile.type = ProfileType.Trapezoidal
    lin.profile.velocity = 1000
    lin.profile.acc = 10000
    lin.profile.dec = 10000
    lin.SetTarget(0, 200)
    lin.SetTarget(1, 0)

    # Execute interpolation command to move to a specified absolute position.
    ret = Wmx3Lib_cm.motion.StartLinearIntplPos(lin)
    if ret != 0:
        print('StartLinearIntplPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until the first linear interpolation starts deceleration
    cond.bufferConditionType = ApiBufferConditionType.DecelerationStarted
    cond.arg_decelerationStarted.axis = 5
    Wmx3Lib_buf.Wait_ApiBufferCondition(cond)

    # Second linear interpolation (200, 0) -> (200, 200)
    lin.SetTarget(0, 200)
    lin.SetTarget(1, 200)
    # Execute interpolation command to move to a specified absolute position.
    ret = Wmx3Lib_cm.motion.StartLinearIntplPos(lin)
    if ret != 0:
        print('StartLinearIntplPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until the second linear interpolation starts deceleration
    cond.bufferConditionType = ApiBufferConditionType.DecelerationStarted
    cond.arg_decelerationStarted.axis = 5
    Wmx3Lib_buf.Wait_ApiBufferCondition(cond)

    # Third linear interpolation (200, 200) -> (0, 200)
    lin.SetTarget(0, 0)
    lin.SetTarget(1, 200)
    # Execute interpolation command to move to a specified absolute position.
    ret = Wmx3Lib_cm.motion.StartLinearIntplPos(lin)
    if ret != 0:
        print('StartLinearIntplPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until the third linear interpolation starts deceleration
    cond.bufferConditionType = ApiBufferConditionType.DecelerationStarted
    cond.arg_decelerationStarted.axis = 5
    Wmx3Lib_buf.Wait_ApiBufferCondition(cond)

    # Fourth linear interpolation (0, 200) -> (0, 0)
    lin.SetTarget(0, 0)
    lin.SetTarget(1, 0)
    # Execute interpolation command to move to a specified absolute position.
    ret = Wmx3Lib_cm.motion.StartLinearIntplPos(lin)
    if ret != 0:
        print('StartLinearIntplPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # End Recording.
    Wmx3Lib_buf.EndRecordBufferChannel()

    # Drive the motion accumulated in the buffer so far.
    Wmx3Lib_buf.Execute(0)

    # Wait for the spline motion to complete
    axes = AxisSelection()
    axes.axisCount = 2
    axes.SetAxis(0, 5)
    axes.SetAxis(1, 7)
    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axes)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Destroy API buffer resources.
    Wmx3Lib_buf.Halt(0)
    Wmx3Lib_buf.FreeApiBuffer(0)


#``



# Write Python code to set the pitch error compensation table for Axis 9 with the following data points: (0, 10), (100, -10), (200, 15), (300, -15). Then, Axis 9 moves from 0 to the absolute position 300 at a speed of 1000.
# Axes = [9]

    # <log ---------------------------------------------------------------------------

    # Stop log just in case logging is on.
    ret = WMX3Log.StopLog(0)
    sleep(0.01)

    # Log the command position after applying compensation offsets. This is necessary to compare if compensation works as expected.
    cmLogIn_0.axisOptions.compCommandPos = 1

    ret = WMX3Log.SetCustomLog(0, cmLogIn_0)
    if ret != 0:
        print('SetCustomLog error code is ' + str(ret) + ': ' + WMX3Log.ErrorToString(ret))
        return
    sleep(0.1)

    # Start log
    ret = WMX3Log.StartLog(0)
    if ret != 0:
        print('StartLog error code is ' + str(ret) + ': ' + WMX3Log.ErrorToString(ret))
        return
    sleep(0.01)
    # log> ---------------------------------------------------------------------------

    # Set the pitch error compensation table for Axis 9 with the following data points: (0, 10), (100, -10), (200, 15), (300, -15). Then, Axis 9 moves from 0 to the absolute position 300 at a speed of 1000.
    Wmx3Lib_comp = Compensation(Wmx3Lib)
    piterror = PitchErrorCompensationData()
    # 1: Enable pitch error compensation  0: Disable pitch error compensation
    piterror.enable = 1
    # The distance between pitch points, in user units.
    piterror.pitchInterval = 100
    # The number of pitch points
    piterror.pitchCount = 4
    # The index of the pitch origin.
    piterror.pitchOriginIndex = 0
    # The command position at the pitch origin, in user units.
    piterror.pitchOriginPosition = 0
    # Add a pitch error compensation table.
    piterror.SetPitchCompensationValue(0, 10)
    piterror.SetPitchCompensationValue(1, -10)
    piterror.SetPitchCompensationValue(2, 15)
    piterror.SetPitchCompensationValue(3, -15)

    # Set the pitch compensation function for Axis 9.
    ret = Wmx3Lib_comp.SetPitchErrorCompensation(9, piterror)
    if ret != 0:
        print('SetPitchErrorCompensation error code is ' + str(ret) + ': ' + Wmx3Lib_comp.ErrorToString(ret))
        return

    # Create a command value of target as 300.
    posCommand = Motion_PosCommand()
    posCommand.profile.type = ProfileType.Trapezoidal
    posCommand.axis = 9
    posCommand.target = 300
    posCommand.profile.velocity = 1000
    posCommand.profile.acc = 10000
    posCommand.profile.dec = 10000

    # Execute command to move from current position to specified absolute position.
    ret = Wmx3Lib_cm.motion.StartPos(posCommand)
    if ret != 0:
        print('StartPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until the axis moves to the target position and stops.
    Wmx3Lib_cm.motion.Wait(9)


#``



# Write Python code to set the pitch error compensation table for Axis 0 with the following data points: (0, 10), (100, -10), (200, 15), (300, -15).The edgeDropoffDistance parameter is set to 50.Then, Axis 0 moves from -100 to the absolute position 300 at a speed of 100.
   # Axes = [0]

    # <log ---------------------------------------------------------------------------

    # Stop log just in case logging is on.
    ret = WMX3Log.StopLog(0)
    sleep(0.01)

    # Log the command position after applying compensation offsets. This is necessary to compare if compensation works as expected.
    cmLogIn_0.axisOptions.compCommandPos = 1

    ret = WMX3Log.SetCustomLog(0, cmLogIn_0)
    if ret != 0:
        print('SetCustomLog error code is ' + str(ret) + ': ' + WMX3Log.ErrorToString(ret))
        return
    sleep(0.1)

    # Start log
    ret = WMX3Log.StartLog(0)
    if ret != 0:
        print('StartLog error code is ' + str(ret) + ': ' + WMX3Log.ErrorToString(ret))
        return
    sleep(0.01)
    # log> ---------------------------------------------------------------------------

    #Set the pitch error compensation table for Axis 0 with the following data points: (0, 10), (100, -10), (200, 15), (300, -15).The edgeDropoffDistance parameter is set to 50.Then, Axis 0 moves from -100 to the absolute position 300 at a speed of 100.
    # Create a command value of target as -100.
    posCommand = Motion_PosCommand()
    posCommand.profile.type = ProfileType.Trapezoidal
    posCommand.axis = 0
    posCommand.target = -100
    posCommand.profile.velocity = 1000
    posCommand.profile.acc = 10000
    posCommand.profile.dec = 10000

    # Execute command to move from current position to specified absolute position.
    ret = Wmx3Lib_cm.motion.StartPos(posCommand)
    if ret!=0:
        print('StartPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until the axis moves to the target position and stops.
    Wmx3Lib_cm.motion.Wait(0)

    Wmx3Lib_comp=Compensation(Wmx3Lib)
    piterror=PitchErrorCompensationData()
    # 1:Enable pitch error compensation  0:Disable pitch error compensation
    piterror.enable=1
    # The distance between pitch points, in user units.
    piterror.pitchInterval=100
    #The number of pitch points
    piterror.pitchCount=4
    #The index of the pitch origin.
    piterror.pitchOriginIndex=0
    #The command position at the pitch origin, in user units.
    piterror.pitchOriginPosition=0
    #The distance beyond the first and last pitch points at which the offset reduces to 0, in user units. If this parameter is set to 0, the offset will not reduce to 0 at command positions beyond the first and last pitch points.
    piterror.edgeDropoffDistance=50

    #Add a pitch error compensation table.
    piterror.SetPitchCompensationValue(0,10)
    piterror.SetPitchCompensationValue(1,-10)
    piterror.SetPitchCompensationValue(2,15)
    piterror.SetPitchCompensationValue(3,-15)

    #Set the pitch compensation function for Axis 0.
    ret =Wmx3Lib_comp.SetPitchErrorCompensation(0,piterror)
    if ret != 0:
        print('SetPitchErrorCompensation error code is ' + str(ret) + ': ' + Wmx3Lib_comp.ErrorToString(ret))
        return

    # Create a command value of target as 300.
    posCommand = Motion_PosCommand()
    posCommand.profile.type = ProfileType.Trapezoidal
    posCommand.axis = 0
    posCommand.target = 300
    posCommand.profile.velocity = 1000
    posCommand.profile.acc = 10000
    posCommand.profile.dec = 10000

    # Execute command to move from current position to specified absolute position.
    ret = Wmx3Lib_cm.motion.StartPos(posCommand)
    if ret!=0:
        print('StartPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until the axis moves to the target position and stops.
    Wmx3Lib_cm.motion.Wait(0)




#``



# Write Python code to set the positive direction BacklashCompensation for Axis 14. Then, Move Axis 14 from 0 to the absolute position 300 at a speed of 1000.
# Axes = [14]

    # <log ---------------------------------------------------------------------------

    # Stop log just in case logging is on.
    ret = WMX3Log.StopLog(0)
    sleep(0.01)

    # Log the command position after applying compensation offsets. This is necessary to compare if compensation works as expected.
    cmLogIn_0.axisOptions.compCommandPos = 1

    ret = WMX3Log.SetCustomLog(0, cmLogIn_0)
    if ret != 0:
        print('SetCustomLog error code is ' + str(ret) + ': ' + WMX3Log.ErrorToString(ret))
        return
    sleep(0.1)

    # Start log
    ret = WMX3Log.StartLog(0)
    if ret != 0:
        print('StartLog error code is ' + str(ret) + ': ' + WMX3Log.ErrorToString(ret))
        return
    sleep(0.01)
    # log> ---------------------------------------------------------------------------

    # Set the positive direction BacklashCompensation for Axis 14. Then, Axis 14 moves from 0 to the absolute position 300 at a speed of 100.
    Wmx3Lib_comp = Compensation(Wmx3Lib)

    backlashcomp = BacklashCompensationData()
    # If 1, backlash compensation is enabled. If 0, backlash compensation is disabled.
    backlashcomp.enable = 1
    # If 1, positive backlash compensation is applied. If -1, negative backlash compensation is applied.
    backlashcomp.offsetDirection = 1
    # The maximum backlash compensation offset, in user units.
    backlashcomp.backlashHigh = 20
    # The minimum backlash compensation offset, in user units.
    backlashcomp.backlashLow = 5
    # The distance after reversing direction above which the maximum backlash compensation is applied, in user units.
    backlashcomp.distanceHigh = 200
    # The distance after reversing direction below which the minimum backlash compensation is applied, in user units.
    backlashcomp.distanceLow = 100

    # Set the BacklashCompensation for Axis 14.
    ret = Wmx3Lib_comp.SetBacklashCompensation(14, backlashcomp)
    if ret != 0:
        print('SetBacklashCompensation error code is ' + str(ret) + ': ' + Wmx3Lib_comp.ErrorToString(ret))
        return

    # Create a command value of target as 300.
    posCommand = Motion_PosCommand()
    posCommand.profile.type = ProfileType.Trapezoidal
    posCommand.axis = 14
    posCommand.target = 300
    posCommand.profile.velocity = 1000
    posCommand.profile.acc = 10000
    posCommand.profile.dec = 10000

    # Execute command to move from current position to specified absolute position.
    ret = Wmx3Lib_cm.motion.StartPos(posCommand)
    if ret != 0:
        print('StartPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until the axis moves to the target position and stops.
    Wmx3Lib_cm.motion.Wait(14)

    # Disable Backlash Compensation is a necessary step! 
    ret = Wmx3Lib_comp.DisableBacklashCompensation(14)
    if ret != 0:
        print('DisableBacklashCompensation error code is ' + str(ret) + ': ' + Wmx3Lib_comp.ErrorToString(ret))
        return


#``



# Write Python code to demonstrate a position synchronous output(PSO) function of Axis 12 using the LessThan comparison type. The position synchronization comparison values of Axis 12 are: 100, 200, 300, with the position synchronization output point at 1.2. Move Axis 12 to 400, with a speed of 500, and acceleration and deceleration are set to 5000.
# Axes = [12]

    Wmx3Lib_EventCtl = EventControl(Wmx3Lib)
    PsoStu = EventControl_PSOStatus()
    PsoOut = EventControl_PSOOutput()
    PsoCompSor = EventControl_ComparatorSource()

    # Set the comparison axis 16 command position output to 1.2.
    PsoOut.outputType = EventControl_PSOOutputType.IOOutput
    PsoOut.byteAddress = 1
    PsoOut.bitAddress = 2
    PsoOut.invert = 0
    PsoCompSor.sourceType = EventControl_ComparatorSourceType.PosCommand
    PsoCompSor.axis = 12
    # The comparison position values are: 100, 200, 300.
    point = [100, 200, 300]

    # Create a command value of axis 16 moves a distance of 400 from the current position at a speed of 500, with an acceleration and deceleration of 5000.
    posCommand = Motion_PosCommand()
    posCommand.profile.type = ProfileType.Trapezoidal
    posCommand.axis = 12
    posCommand.profile.velocity = 500
    posCommand.profile.acc = 5000
    posCommand.profile.dec = 5000
    posCommand.target = 400
    # Set parameters for a position synchronous output channel. A position synchronous output channel is able to output an output signal when certain conditions, such as an axis reaching a certain position, are met.
    ret = Wmx3Lib_EventCtl.SetPSOConfig(0, EventControl_ComparisonType.LessThan, PsoCompSor, PsoOut, 0)
    if ret != 0:
        print('SetPSOConfig to off error code is ' + str(ret) + ': ' + Wmx3Lib_EventCtl.ErrorToString(ret))
    # Set multiple data points for a position synchronous output channel.
    ret = Wmx3Lib_EventCtl.SetPSOMultipleData(0, 3, point)
    if ret != 0:
        print('SetPSOMultipleData to off error code is ' + str(ret) + ': ' + Wmx3Lib_EventCtl.ErrorToString(ret))
    # Get the channel status
    ret, PsoStu = Wmx3Lib_EventCtl.GetPSOStatus(0)
    PsoCount = Wmx3Lib_EventCtl.GetPSODataCount(0)
    # If the channel is already open, execute StopPSO.
    if PsoStu.enabled == 1:
        Wmx3Lib_EventCtl.StopPSO(0)
        sleep(0.01)
    # StartPSO
    ret = Wmx3Lib_EventCtl.StartPSO(0)
    if ret != 0:
        print('StartPSO to off error code is ' + str(ret) + ': ' + Wmx3Lib_EventCtl.ErrorToString(ret))
    # Execute command to move to a specified absolute position.
    ret = Wmx3Lib_cm.motion.StartPos(posCommand)
    if ret != 0:
        print('StartPos to off error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
    Wmx3Lib_cm.motion.Wait(12)
    # StopPSO
    Wmx3Lib_EventCtl.StopPSO(0)


#``



# Write Python code to demonstrate a position synchronous output(PSO) function of Axis 7 using the Equal, PositiveDirection, and NegativeDirection comparison type. Channel 0, 1, 2 are used, each with identical parameter settings except for the comparison type. The position synchronization comparison values are: 150, 300, 450, with the position synchronization output point at 6.0, 7.1, 8.2. Move Axis 7 to 500, with a speed of 1000, and acceleration and deceleration are set to 10000.
# Axes = [7]

    Wmx3Lib_EventCtl = EventControl(Wmx3Lib)
    PsoStu = EventControl_PSOStatus()
    PsoOut = EventControl_PSOOutput()
    PsoCompSor = EventControl_ComparatorSource()

    # Set the comparison axis 7 command position output to 6.0.
    PsoOut.outputType = EventControl_PSOOutputType.IOOutput
    PsoOut.byteAddress = 6
    PsoOut.bitAddress = 0
    PsoOut.invert = 0
    PsoCompSor.sourceType = EventControl_ComparatorSourceType.PosCommand
    PsoCompSor.axis = 7
    # The comparison position values are: 150, 300, 450.
    point = [150, 300, 450]
    # Create a command value of axis 7 moves a distance of 500 from the current position at a speed of 1000, with an acceleration and deceleration of 10000.
    posCommand = Motion_PosCommand()
    posCommand.profile.type = ProfileType.Trapezoidal
    posCommand.axis = 7
    posCommand.profile.velocity = 1000
    posCommand.profile.acc = 10000
    posCommand.profile.dec = 10000
    posCommand.target = 500
    # Set parameters for a position synchronous output channel 0. A position synchronous output channel is able to output an output signal when certain conditions, such as an axis reaching a certain position, are met.
    Wmx3Lib_EventCtl.SetPSOConfig(0, EventControl_ComparisonType.Equal, PsoCompSor, PsoOut, 0)
    # Output to 7.1
    PsoOut.byteAddress = 7
    PsoOut.bitAddress = 1
    # Set parameters for a position synchronous output channel 1. A position synchronous output channel is able to output an output signal when certain conditions, such as an axis reaching a certain position, are met.
    Wmx3Lib_EventCtl.SetPSOConfig(1, EventControl_ComparisonType.PositiveDirection, PsoCompSor, PsoOut, 0)
    # Output to 8.2
    PsoOut.byteAddress = 8
    PsoOut.bitAddress = 2
    # Set parameters for a position synchronous output channel 2. A position synchronous output channel is able to output an output signal when certain conditions, such as an axis reaching a certain position, are met.
    Wmx3Lib_EventCtl.SetPSOConfig(2, EventControl_ComparisonType.NegativeDirection, PsoCompSor, PsoOut, 0)
    # Set multiple data points for a position synchronous output channel.
    ret = Wmx3Lib_EventCtl.SetPSOMultipleData(0, 3, point)
    if ret != 0:
        print('SetPSOMultipleData0 to off error code is ' + str(ret) + ': ' + Wmx3Lib_EventCtl.ErrorToString(ret))
    ret = Wmx3Lib_EventCtl.SetPSOMultipleData(1, 3, point)
    if ret != 0:
        print('SetPSOMultipleData1 to off error code is ' + str(ret) + ': ' + Wmx3Lib_EventCtl.ErrorToString(ret))
    ret = Wmx3Lib_EventCtl.SetPSOMultipleData(2, 3, point)
    if ret != 0:
        print('SetPSOMultipleData2 to off error code is ' + str(ret) + ': ' + Wmx3Lib_EventCtl.ErrorToString(ret))
    # Get the channel status
    ret, PsoStu = Wmx3Lib_EventCtl.GetPSOStatus(0)
    # If the channel is already open, execute StopPSO.
    if PsoStu.enabled == 1:
        Wmx3Lib_EventCtl.StopPSO(0)
        sleep(0.01)
    # Get the channel status
    ret, PsoStu = Wmx3Lib_EventCtl.GetPSOStatus(1)
    # If the channel is already open, execute StopPSO.
    if PsoStu.enabled == 1:
        Wmx3Lib_EventCtl.StopPSO(1)
        sleep(0.01)
    # Get the channel status
    ret, PsoStu = Wmx3Lib_EventCtl.GetPSOStatus(2)
    # If the channel is already open, execute StopPSO.
    if PsoStu.enabled == 1:
        Wmx3Lib_EventCtl.StopPSO(2)
        sleep(0.01)

    # StartPSO
    ret = Wmx3Lib_EventCtl.StartPSO(0)
    if ret != 0:
        print('StartPSO to off error code is ' + str(ret) + ': ' + Wmx3Lib_EventCtl.ErrorToString(ret))
    # StartPSO
    ret = Wmx3Lib_EventCtl.StartPSO(1)
    if ret != 0:
        print('StartPSO to off error code is ' + str(ret) + ': ' + Wmx3Lib_EventCtl.ErrorToString(ret))
    # StartPSO
    ret = Wmx3Lib_EventCtl.StartPSO(2)
    if ret != 0:
        print('StartPSO to off error code is ' + str(ret) + ': ' + Wmx3Lib_EventCtl.ErrorToString(ret))

    # Execute command to move to a specified absolute position.
    ret = Wmx3Lib_cm.motion.StartPos(posCommand)
    if ret != 0:
        print('StartPos to off error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
    Wmx3Lib_cm.motion.Wait(7)
    # StopPSO
    Wmx3Lib_EventCtl.StopPSO(0)
    Wmx3Lib_EventCtl.StopPSO(1)
    Wmx3Lib_EventCtl.StopPSO(2)


#``



# Write Python code to demonstrate a position synchronous output(PSO) function of Axis 9 using the Equal, PositiveDirection, and NegativeDirection comparison type. Channel 0, 1, 2 are used, each with identical parameter settings except for the comparison type. Interval position synchronization output parameters: rangeStart = 0, rangeEnd = 400, and interval = 100 with the position synchronization output point at 3.0, 4.1, 5.2. Move Axis 9 to 610, with a speed of 1000, and acceleration and deceleration are set to 10000.
# Axes = [9]

    Wmx3Lib_EventCtl = EventControl(Wmx3Lib)
    PsoStu = EventControl_PSOStatus()
    PsoOut = EventControl_PSOOutput()
    PsoCompSor = EventControl_ComparatorSource()

    # Set the comparison axis 9 command position output to 3.0.
    PsoOut.outputType = EventControl_PSOOutputType.IOOutput
    PsoOut.byteAddress = 3
    PsoOut.bitAddress = 0
    PsoOut.invert = 0
    PsoCompSor.sourceType = EventControl_ComparatorSourceType.PosCommand
    PsoCompSor.axis = 9
    # Create a command value of axis 9 moves a distance of 500 from the current position at a speed of 1000, with an acceleration and deceleration of 10000.
    posCommand = Motion_PosCommand()
    posCommand.profile.type = ProfileType.Trapezoidal
    posCommand.axis = 9
    posCommand.profile.velocity = 1000
    posCommand.profile.acc = 10000
    posCommand.profile.dec = 10000
    posCommand.target = 610
    # Set parameters for a position synchronous output channel 0. A position synchronous output channel is able to output an output signal when certain conditions, such as an axis reaching a certain position, are met.
    Wmx3Lib_EventCtl.SetPSOConfig(0, EventControl_ComparisonType.Equal, PsoCompSor, PsoOut, 0)
    # Output to 4.1
    PsoOut.byteAddress = 4
    PsoOut.bitAddress = 1
    # Set parameters for a position synchronous output channel 1. A position synchronous output channel is able to output an output signal when certain conditions, such as an axis reaching a certain position, are met.
    Wmx3Lib_EventCtl.SetPSOConfig(1, EventControl_ComparisonType.LessThan, PsoCompSor, PsoOut, 0)
    # Output to 5.2
    PsoOut.byteAddress = 5
    PsoOut.bitAddress = 2
    # Set parameters for a position synchronous output channel 2. A position synchronous output channel is able to output an output signal when certain conditions, such as an axis reaching a certain position, are met.
    Wmx3Lib_EventCtl.SetPSOConfig(2, EventControl_ComparisonType.MoreThan, PsoCompSor, PsoOut, 0)
    # Set multiple data points for a position synchronous output channel.
    ret = Wmx3Lib_EventCtl.SetPSOIntervalData(0, 0, 400, 100)
    if ret != 0:
        print('SetPSOIntervalData0 to off error code is ' + str(ret) + ': ' + Wmx3Lib_EventCtl.ErrorToString(ret))
    ret = Wmx3Lib_EventCtl.SetPSOIntervalData(1, 0, 400, 100)
    if ret != 0:
        print('SetPSOIntervalData1 to off error code is ' + str(ret) + ': ' + Wmx3Lib_EventCtl.ErrorToString(ret))
    ret = Wmx3Lib_EventCtl.SetPSOIntervalData(2, 0, 400, 100)
    if ret != 0:
        print('SetPSOIntervalData2 to off error code is ' + str(ret) + ': ' + Wmx3Lib_EventCtl.ErrorToString(ret))
    # Get the channel status
    ret, PsoStu = Wmx3Lib_EventCtl.GetPSOStatus(0)
    # If the channel is already open, execute StopPSO.
    if PsoStu.enabled == 1:
        Wmx3Lib_EventCtl.StopPSO(0)
        sleep(0.01)
    # Get the channel status
    ret, PsoStu = Wmx3Lib_EventCtl.GetPSOStatus(1)
    # If the channel is already open, execute StopPSO.
    if PsoStu.enabled == 1:
        Wmx3Lib_EventCtl.StopPSO(1)
        sleep(0.01)
    # Get the channel status
    ret, PsoStu = Wmx3Lib_EventCtl.GetPSOStatus(2)
    # If the channel is already open, execute StopPSO.
    if PsoStu.enabled == 1:
        Wmx3Lib_EventCtl.StopPSO(2)
        sleep(0.01)

    # StartPSO
    ret = Wmx3Lib_EventCtl.StartPSO(0)
    if ret != 0:
        print('StartPSO to off error code is ' + str(ret) + ': ' + Wmx3Lib_EventCtl.ErrorToString(ret))
    # StartPSO
    ret = Wmx3Lib_EventCtl.StartPSO(1)
    if ret != 0:
        print('StartPSO to off error code is ' + str(ret) + ': ' + Wmx3Lib_EventCtl.ErrorToString(ret))
    # StartPSO
    ret = Wmx3Lib_EventCtl.StartPSO(2)
    if ret != 0:
        print('StartPSO to off error code is ' + str(ret) + ': ' + Wmx3Lib_EventCtl.ErrorToString(ret))

    # Execute command to move to a specified absolute position.
    ret = Wmx3Lib_cm.motion.StartPos(posCommand)
    if ret != 0:
        print('StartPos to off error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
    Wmx3Lib_cm.motion.Wait(9)

    # StopPSO
    Wmx3Lib_EventCtl.StopPSO(0)
    Wmx3Lib_EventCtl.StopPSO(1)
    Wmx3Lib_EventCtl.StopPSO(2)


#``



# Write Python code to set the feedback parameters for Axis 0. Set‘In Pos Width’to 1000,‘In Pos Width2’to 1000,‘In Pos Width3’to 1000,‘In Pos Width4’to 1000,‘In Pos Width5’to 1000,‘Velocity Monitor Source’to UseVelocityFeedback,‘Pos Set Width’to 1000,‘Delayed Pos Set Width’to 1000,‘Delayed Pos Set Milliseconds’to 0.
    # Axes = [0]

    # Example of Axis 0 Feedback Parameters
    axis = 0

    #In Pos Width      The width of a window centered at the target position of the current motion command. When the feedback position falls within this window, the axis is considered to be in position.
    #Variable Name:   inPosWidth
    #Type:            double
    #Unit:            user unit
    #Minimum Value:   0
    #Maximum Value:   274877906943
    #Default Value:   1000
    #Read the current values of parameters
    feedbackParam = Config_FeedbackParam()
    ret, feedbackParam = Wmx3Lib_cm.config.GetFeedbackParam(axis)
    feedbackParam.inPosWidth = 1000
    #Write the updated values of parameters
    ret, feedbackParamErr = Wmx3Lib_cm.config.SetFeedbackParam(axis, feedbackParam)
    if(ret!=0):
        print('Set inPosWidth error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    #In Pos Width2    This parameter is the same as the In Pos Width parameter, except it affects the In Pos 2 status instead of the In Pos status.
    #Variable Name:   inPosWidth2
    #Type:            double
    #Unit:            user unit
    #Minimum Value:   0
    #Maximum Value:   274877906943
    #Default Value:   1000
    #Read the current values of parameters
    feedbackParam = Config_FeedbackParam()
    ret, feedbackParam = Wmx3Lib_cm.config.GetFeedbackParam(axis)
    feedbackParam.inPosWidth2 = 1000
    #Write the updated values of parameters
    ret, feedbackParamErr = Wmx3Lib_cm.config.SetFeedbackParam(axis, feedbackParam)
    if(ret!=0):
        print('Set inPosWidth2 error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # In Pos Width3    This parameter is the same as the In Pos Width parameter, except it affects the In Pos 3 status instead of the In Pos status.
    # Variable Name:   inPosWidth3
    # Type:            double
    # Unit:            user unit
    # Minimum Value:   0
    # Maximum Value:   274877906943
    # Default Value:   1000
    # Read the current values of parameters
    feedbackParam = Config_FeedbackParam()
    ret, feedbackParam = Wmx3Lib_cm.config.GetFeedbackParam(axis)
    feedbackParam.inPosWidth3 = 1000
    # Write the updated values of parameters
    ret, feedbackParamErr = Wmx3Lib_cm.config.SetFeedbackParam(axis, feedbackParam)
    if (ret != 0):
        print('Set inPosWidth3 error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # In Pos Width4    This parameter is the same as the In Pos Width parameter, except it affects the In Pos 4 status instead of the In Pos status.
    # Variable Name:   inPosWidth4
    # Type:            double
    # Unit:            user unit
    # Minimum Value:   0
    # Maximum Value:   274877906943
    # Default Value:   1000
    # Read the current values of parameters
    feedbackParam = Config_FeedbackParam()
    ret, feedbackParam = Wmx3Lib_cm.config.GetFeedbackParam(axis)
    feedbackParam.inPosWidth4 = 1000
    # Write the updated values of parameters
    ret, feedbackParamErr = Wmx3Lib_cm.config.SetFeedbackParam(axis, feedbackParam)
    if (ret != 0):
        print('Set inPosWidth4 error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # In Pos Width5    This parameter is the same as the In Pos Width parameter, except it affects the In Pos 5 status instead of the In Pos status.
    # Variable Name:   inPosWidth5
    # Type:            double
    # Unit:            user unit
    # Minimum Value:   0
    # Maximum Value:   274877906943
    # Default Value:   1000
    # Read the current values of parameters
    feedbackParam = Config_FeedbackParam()
    ret, feedbackParam = Wmx3Lib_cm.config.GetFeedbackParam(axis)
    feedbackParam.inPosWidth5 = 1000
    # Write the updated values of parameters
    ret, feedbackParamErr = Wmx3Lib_cm.config.SetFeedbackParam(axis, feedbackParam)
    if (ret != 0):
        print('Set inPosWidth5 error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Velocity Monitor Source    This parameter determines whether the Actual Velocity status is calculated from the position feedback, or is obtained directly from the servo velocity feedback.
    # Variable Name:   velocityMonitorSource
    # Type:            VelocityMonitorSource
    # Default Value:   UseVelocityFeedback
    # Read the current values of parameters
    feedbackParam = Config_FeedbackParam()
    ret, feedbackParam = Wmx3Lib_cm.config.GetFeedbackParam(axis)
    feedbackParam.velocityMonitorSource = Config_VelocityMonitorSource.UseVelocityFeedback
    # Write the updated values of parameters
    ret, feedbackParamErr = Wmx3Lib_cm.config.SetFeedbackParam(axis, feedbackParam)
    if (ret != 0):
        print('Set velocityMonitorSource error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Pos Set Width    The width of a window centered at the target position of the current motion command. When the feedback position falls within this window and the cyclic command position is equal to the target position (the command generation has finished), the Pos Set status is set to TRUE.
    # Variable Name:   posSetWidth
    # Type:            double
    # Unit:            user unit
    # Minimum Value:   0
    # Maximum Value:   274877906943
    # Default Value:   1000
    # Read the current values of parameters
    feedbackParam = Config_FeedbackParam()
    ret, feedbackParam = Wmx3Lib_cm.config.GetFeedbackParam(axis)
    feedbackParam.posSetWidth = 1000
    # Write the updated values of parameters
    ret, feedbackParamErr = Wmx3Lib_cm.config.SetFeedbackParam(axis, feedbackParam)
    if (ret != 0):
        print('Set posSetWidth error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Delayed Pos Set Width     The width of a window centered at the target position of the current motion command. After the cyclic command position becomes equal to the target position (the command generation has finished), when the feedback position falls within this window for Delayed Pos Set Milliseconds amount of time continuously, the Delayed Pos Set status is set to TRUE.
    # Variable Name:   delayedPosSetWidth
    # Type:            double
    # Unit:            user unit
    # Minimum Value:   0
    # Maximum Value:   274877906943
    # Default Value:   1000
    # Read the current values of parameters
    feedbackParam = Config_FeedbackParam()
    ret, feedbackParam = Wmx3Lib_cm.config.GetFeedbackParam(axis)
    feedbackParam.delayedPosSetWidth = 1000
    # Write the updated values of parameters
    ret, feedbackParamErr = Wmx3Lib_cm.config.SetFeedbackParam(axis, feedbackParam)
    if (ret != 0):
        print('Set delayedPosSetWidth error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Delayed Pos Set Milliseconds     The amount of time that the feedback position must be within the Delayed Pos Set Width of the target position continuously before the Delayed Pos Set status is set to TRUE.
    #                                   If this parameter is set to 0, the Delayed Pos Set status is set to TRUE immediately when the feedback position goes within the Delayed Pos Set Width of the target position after the command generation has finished.
    # Variable Name:   delayedPosSetMilliseconds
    # Type:            double
    # Unit:            user unit
    # Minimum Value:   0
    # Maximum Value:   274877906943
    # Default Value:   0
    # Read the current values of parameters
    feedbackParam = Config_FeedbackParam()
    ret, feedbackParam = Wmx3Lib_cm.config.GetFeedbackParam(axis)
    feedbackParam.delayedPosSetMilliseconds = 0
    # Write the updated values of parameters
    ret, feedbackParamErr = Wmx3Lib_cm.config.SetFeedbackParam(axis, feedbackParam)
    if (ret != 0):
        print('Set delayedPosSetMilliseconds error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return




#``



# Write Python code to set the Homing parameters for Axis 0. Set‘Home Type’to CurrentPos,‘Home Direction’to Positive,‘Homing Velocity Slow’to 10000,‘Homing Velocity Slow Acc’to 10000,‘Homing Velocity Slow Dec’to 10000,‘Homing Velocity Fast’to 10000,‘Homing Velocity Fast Acc’to 10000,‘Homing Velocity Fast Dec’to 10000,‘Homing Reverse Distance’to 0,‘Home Shift Velocity’to 10000,‘Home Shift Acc’to 10000,‘Home Shift Dec’to 10000,‘Home Shift Distance’to 0,‘Invert HS Polarity ’to FALSE,‘Multiple Z-Pulse’to 0,‘Round Pos Cmd After Homing’to FALSE,‘Pause Mode’to FALSE,‘Max HS On At Start Reverse Distance’to 0,‘Max LS Reverse Distance’to 0,‘Z-Pulse Distance Check ’to 0,‘Home Position’to 0,‘Gantry Homing Use Slave HS’to FALSE,‘Gantry Homing Use Slave LS’to FALSE,‘Gantry Homing Use Slave Z-Pulse’to FALSE,‘Gantry Homing Use Slave Touch Probe’to FALSE,‘Gantry Homing Use Slave Mechanical End’to FALSE,‘Gantry Homing Retain Sync Offset’to FALSE,‘Immediate Stop at LS’to FALSE,‘Mechanical End Detection Pos Diff ’to 0,‘Mechanical End Detection Time Milliseconds’to 0,‘Mechanical End Detection Ignore LS’to FALSE,‘Mechanical End Detection First Torque Limit’to 0,‘Mechanical End Detection Second Torque Limit’to 0,‘Open Loop Homing’to FALSE,‘Clear Home Done On Servo Off’to FALSE,‘Clear Home Done On Comm Stop’to True.
    # Axes = [0]

    # Example of Axis 0 Homing Parameters
    axis = 0
    # Home Type        The method of homing during a home operation. Each method is explained in detail in Homing.
    # Variable Name:   homeType
    # Type:            HomeType
    # Default Value:   CurrentPos
    # Gantry Homing:   Master
    # Read the current values of parameters
    homeParam = Config_HomeParam()
    ret, homeParam = Wmx3Lib_cm.config.GetHomeParam(axis)
    homeParam.homeType = Config_HomeType.CurrentPos
    # SetHomeParam -> First return value: Error code, Second return value: param error
    ret, homeParamError = Wmx3Lib_cm.config.SetHomeParam(axis, homeParam)
    if(ret!=0):
        print('Set homeType error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Home Direction  The direction to search for the home position during a home operation. This direction is the homing direction and the opposite direction is the reverse direction in the discussion in Homing.
    # Variable Name:   homeDirection
    # Type:            HomeDirection
    # Default Value:   Positive
    # Gantry Homing:   Master
    # Read the current values of parameters
    homeParam = Config_HomeParam()
    ret, homeParam = Wmx3Lib_cm.config.GetHomeParam(axis)
    homeParam.homeDirection  = Config_HomeDirection.Positive
    # SetHomeParam -> First return value: Error code, Second return value: param error
    ret, homeParamError = Wmx3Lib_cm.config.SetHomeParam(axis, homeParam)
    if(ret!=0):
        print('Set homeDirection error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Homing Velocity Slow    The "slow" homing velocity to use during a home operation. See Homing for information on when the "slow" homing velocity is used for each home type.
    # Variable Name:   homingVelocitySlow
    # Type:            double
    # Unit:            user unit / second
    # Minimum Value:   1e-6
    # Maximum Value:   274877906943
    # Default Value:   10000
    # Gantry Homing:   Master
    # Read the current values of parameters
    homeParam = Config_HomeParam()
    ret, homeParam = Wmx3Lib_cm.config.GetHomeParam(axis)
    homeParam.homingVelocitySlow  = 10000
    # SetHomeParam -> First return value: Error code, Second return value: param error
    ret, homeParamError = Wmx3Lib_cm.config.SetHomeParam(axis, homeParam)
    if(ret!=0):
        print('Set homingVelocitySlow error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Homing Velocity Slow Acc    The acceleration to use when accelerating to the "slow" homing velocity. See Homing for information on when the "slow" homing velocity is used for each home type.
    # Variable Name:   homingVelocitySlowAcc
    # Type:            double
    # Unit:            user unit / second^2
    # Minimum Value:   1e-6
    # Maximum Value:   274877906943
    # Default Value:   10000
    # Gantry Homing:   Master
    # Read the current values of parameters
    homeParam = Config_HomeParam()
    ret, homeParam = Wmx3Lib_cm.config.GetHomeParam(axis)
    homeParam.homingVelocitySlowAcc  = 10000
    # SetHomeParam -> First return value: Error code, Second return value: param error
    ret, homeParamError = Wmx3Lib_cm.config.SetHomeParam(axis, homeParam)
    if(ret!=0):
        print('Set homingVelocitySlowAcc error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Homing Velocity Slow Dec    The acceleration to use when accelerating to the "slow" homing velocity. See Homing for information on when the "slow" homing velocity is used for each home type.
    # Variable Name:   homingVelocitySlowDec
    # Type:            double
    # Unit:            user unit / second^2
    # Minimum Value:   1e-6
    # Maximum Value:   274877906943
    # Default Value:   10000
    # Gantry Homing:   Master
    # Read the current values of parameters
    homeParam = Config_HomeParam()
    ret, homeParam = Wmx3Lib_cm.config.GetHomeParam(axis)
    homeParam.homingVelocitySlowDec  = 10000
    # SetHomeParam -> First return value: Error code, Second return value: param error
    ret, homeParamError = Wmx3Lib_cm.config.SetHomeParam(axis, homeParam)
    if(ret!=0):
        print('Set homingVelocitySlowDec error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Homing Velocity Fast     The "fast" homing velocity to use during a home operation. See Homing for information on when the "fast" homing velocity is used for each home type.
    # Variable Name:   homingVelocityFast
    # Type:            double
    # Unit:            user unit / second
    # Minimum Value:   1e-6
    # Maximum Value:   274877906943
    # Default Value:   10000
    # Gantry Homing:   Master
    # Read the current values of parameters
    homeParam = Config_HomeParam()
    ret, homeParam = Wmx3Lib_cm.config.GetHomeParam(axis)
    homeParam.homingVelocityFast   = 10000
    # SetHomeParam -> First return value: Error code, Second return value: param error
    ret, homeParamError = Wmx3Lib_cm.config.SetHomeParam(axis, homeParam)
    if(ret!=0):
        print('Set homingVelocitySlowDec error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Homing Velocity Fast Acc     The acceleration to use when accelerating to the "fast" homing velocity. See Homing for information on when the "fast" homing velocity is used for each home type.
    # Variable Name:   homingVelocityFastAcc
    # Type:            double
    # Unit:            user unit / second^2
    # Minimum Value:   1e-6
    # Maximum Value:   274877906943
    # Default Value:   10000
    # Gantry Homing:   Master
    # Read the current values of parameters
    homeParam = Config_HomeParam()
    ret, homeParam = Wmx3Lib_cm.config.GetHomeParam(axis)
    homeParam.homingVelocityFastAcc  = 10000
    # SetHomeParam -> First return value: Error code, Second return value: param error
    ret, homeParamError = Wmx3Lib_cm.config.SetHomeParam(axis, homeParam)
    if(ret!=0):
        print('Set homingVelocityFastAcc error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Homing Velocity Fast Dec    The deceleration to use when decelerating from the "fast" homing velocity. See Homing for information on when the "fast" homing velocity is used for each home type.
    # Variable Name:   homingVelocityFastDec
    # Type:            double
    # Unit:            user unit / second^2
    # Minimum Value:   1e-6
    # Maximum Value:   274877906943
    # Default Value:   10000
    # Gantry Homing:   Master
    # Read the current values of parameters
    homeParam = Config_HomeParam()
    ret, homeParam = Wmx3Lib_cm.config.GetHomeParam(axis)
    homeParam.homingVelocityFastDec  = 10000
    # SetHomeParam -> First return value: Error code, Second return value: param error
    ret, homeParamError = Wmx3Lib_cm.config.SetHomeParam(axis, homeParam)
    if(ret!=0):
        print('Set homingVelocityFastDec  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Homing Reverse Distance     The distance to continue reversing after clearing the home switch during a home operation. The home switch is cleared after the first home switch search of a HSHS or HSTouchProbe home operation.
    # Variable Name:   homingReverseDistance
    # Type:            double
    # Unit:            user unit
    # Minimum Value:   0
    # Maximum Value:   274877906943
    # Default Value:   0
    # Gantry Homing:   Master
    # Read the current values of parameters
    homeParam = Config_HomeParam()
    ret, homeParam = Wmx3Lib_cm.config.GetHomeParam(axis)
    homeParam.homingReverseDistance   = 0
    # SetHomeParam -> First return value: Error code, Second return value: param error
    ret, homeParamError = Wmx3Lib_cm.config.SetHomeParam(axis, homeParam)
    if(ret!=0):
        print('Set homingReverseDistance  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Home Shift Velocity     The velocity to use to move the axis to the home position after the home position is found. If the Home Shift Distance parameter is large, the home position may be far from the axis position when the home position is found. Even if the Home Shift Distance parameter is 0, the axis will still need to execute a home shift motion because the axis will not be exactly at the home position after it stops from the velocity it was at when searching for the home position.
    # Variable Name:   homeShiftVelocity
    # Type:            double
    # Unit:            user unit / second
    # Minimum Value:   1e-6
    # Maximum Value:   274877906943
    # Default Value:   10000
    # Gantry Homing:   Master
    # Read the current values of parameters
    homeParam = Config_HomeParam()
    ret, homeParam = Wmx3Lib_cm.config.GetHomeParam(axis)
    homeParam.homeShiftVelocity  = 10000
    # SetHomeParam -> First return value: Error code, Second return value: param error
    ret, homeParamError = Wmx3Lib_cm.config.SetHomeParam(axis, homeParam)
    if(ret!=0):
        print('Set homeShiftVelocity error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Home Shift Acc     The acceleration to use when accelerating to the Home Shift Velocity.
    # Variable Name:   homeShiftAcc
    # Type:            double
    # Unit:            user unit / second^2
    # Minimum Value:   1e-6
    # Maximum Value:   274877906943
    # Default Value:   10000
    # Gantry Homing:   Master
    # Read the current values of parameters
    homeParam = Config_HomeParam()
    ret, homeParam = Wmx3Lib_cm.config.GetHomeParam(axis)
    homeParam.homeShiftAcc = 10000
    # SetHomeParam -> First return value: Error code, Second return value: param error
    ret, homeParamError = Wmx3Lib_cm.config.SetHomeParam(axis, homeParam)
    if(ret!=0):
        print('Set homingVelocitySlowDec error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Home Shift Dec     The deceleration to use when decelerating from the Home Shift Velocity.
    # Variable Name:   homeShiftDec
    # Type:            double
    # Unit:            user unit / second^2
    # Minimum Value:   1e-6
    # Maximum Value:   274877906943
    # Default Value:   10000
    # Gantry Homing:   Master
    # Read the current values of parameters
    homeParam = Config_HomeParam()
    ret, homeParam = Wmx3Lib_cm.config.GetHomeParam(axis)
    homeParam.homeShiftDec   = 10000
    # SetHomeParam -> First return value: Error code, Second return value: param error
    ret, homeParamError = Wmx3Lib_cm.config.SetHomeParam(axis, homeParam)
    if(ret!=0):
        print('Set homeShiftDec  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Home Shift Distance      The distance to shift the home position after it is found. A positive value indicates a shift in the direction of homing and a negative value indicates a shift in the reverse direction (the direction of homing is determined by the Home Direction parameter). The shifted home position becomes the actual home position.
    # Variable Name:   homeShiftDistance
    # Type:            double
    # Unit:            user unit
    # Minimum Value:   -274877906943
    # Maximum Value:   274877906943
    # Default Value:   0
    # Gantry Homing:   Master
    # Read the current values of parameters
    homeParam = Config_HomeParam()
    ret, homeParam = Wmx3Lib_cm.config.GetHomeParam(axis)
    homeParam.homeShiftDistance  = 0
    # SetHomeParam -> First return value: Error code, Second return value: param error
    ret, homeParamError = Wmx3Lib_cm.config.SetHomeParam(axis, homeParam)
    if(ret!=0):
        print('Set homeShiftDistance error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Invert HS Polarity     If set to FALSE, the home switch will be active high. If set to TRUE, the home switch polarity will be inverted and become active low.
    # Variable Name:   invertHSPolarity
    # Type:            bool
    # Default Value:   FALSE
    # Gantry Homing:   Master/Slave
    # Read the current values of parameters
    homeParam = Config_HomeParam()
    ret, homeParam = Wmx3Lib_cm.config.GetHomeParam(axis)
    homeParam.invertHSPolarity  = False
    # SetHomeParam -> First return value: Error code, Second return value: param error
    ret, homeParamError = Wmx3Lib_cm.config.SetHomeParam(axis, homeParam)
    if(ret!=0):
        print('Set invertHSPolarity error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Multiple Z-Pulse     For home types that search for the Z-pulse (index pulse), the number of Z-pulses to search for. If set to 0 or 1, the home position will be set to the position of the first Z-pulse that is found. If set to a value greater than 1, the home position will be set to the position after that many Z-pulses have been found.
    # Variable Name:   multipleZPulse
    # Type:            unsigned int
    # Minimum Value:   0
    # Maximum Value:   100
    # Default Value:   0
    # Gantry Homing:   Master
    # Read the current values of parameters
    homeParam = Config_HomeParam()
    ret, homeParam = Wmx3Lib_cm.config.GetHomeParam(axis)
    homeParam.multipleZPulse  = 0
    # SetHomeParam -> First return value: Error code, Second return value: param error
    ret, homeParamError = Wmx3Lib_cm.config.SetHomeParam(axis, homeParam)
    if(ret!=0):
        print('Set multipleZPulse error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Round Pos Cmd After Homing     Whether to round the command position to the nearest whole number after homing. If set to FALSE, decimal user units of the command position will remain after homing. If set to TRUE, decimal user units of the command position will be rounded to the nearest whole number after homing. This does not change the home position; it will only adjust the command position (the same as if a position command to the rounded position is executed).
    # Variable Name:   roundPosCmdAfterHoming
    # Type:            bool
    # Default Value:   FALSE
    # Gantry Homing:   Master/Slave
    # Read the current values of parameters
    homeParam = Config_HomeParam()
    ret, homeParam = Wmx3Lib_cm.config.GetHomeParam(axis)
    homeParam.roundPosCmdAfterHoming  = False
    # SetHomeParam -> First return value: Error code, Second return value: param error
    ret, homeParamError = Wmx3Lib_cm.config.SetHomeParam(axis, homeParam)
    if(ret!=0):
        print('Set roundPosCmdAfterHoming error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Pause Mode       Whether to pause the homing operation when the axis changes direction or momentarily stops during homing. While the homing operation is paused, the axis servo may be turned on or off without canceling the home operation. To continue the homing operation from the paused state, call the Continue function.
    # Variable Name:   pauseMode
    # Type:            bool
    # Default Value:   FALSE
    # Gantry Homing:   Master
    # Read the current values of parameters
    homeParam = Config_HomeParam()
    ret, homeParam = Wmx3Lib_cm.config.GetHomeParam(axis)
    homeParam.pauseMode  = False
    # SetHomeParam -> First return value: Error code, Second return value: param error
    ret, homeParamError = Wmx3Lib_cm.config.SetHomeParam(axis, homeParam)
    if(ret!=0):
        print('Set pauseMode error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Max HS On At Start Reverse Distance      For home types that search for the home switch, if the home switch is already on when homing is started, the axis will move in the reverse homing direction to clear the home switch. This parameter determines the maximum distance that the axis can reverse to clear the home switch. If this distance is exceeded, the axis will stop and register a home error. If this parameter is set to 0, there is no limit to the reverse travel distance.
    # Variable Name:   maxHSOnAtStartReverseDistance
    # Type:            double
    # Unit:            user unit
    # Minimum Value:   0
    # Maximum Value:   274877906943
    # Default Value:   0
    # Gantry Homing:   Master
    # Read the current values of parameters
    homeParam = Config_HomeParam()
    ret, homeParam = Wmx3Lib_cm.config.GetHomeParam(axis)
    homeParam.maxHSOnAtStartReverseDistance  = 0
    # SetHomeParam -> First return value: Error code, Second return value: param error
    ret, homeParamError = Wmx3Lib_cm.config.SetHomeParam(axis, homeParam)
    if(ret!=0):
        print('Set maxHSOnAtStartReverseDistance error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Max LS Reverse Distance      For home types that search for the home switch, if the limit switch is triggered while searching for the home switch or touch probe, the axis will reverse until the falling edge of the home switch is found. This parameter determines the maximum distance the axis can reverse to find the falling edge of the home switch. If this distance is exceeded, the axis will stop and register a home error. If this parameter is set to 0, there is no limit to the reverse travel distance.
    # Variable Name:   maxLSReverseDistance
    # Type:            double
    # Unit:            user unit
    # Minimum Value:   0
    # Maximum Value:   274877906943
    # Default Value:   0
    # Gantry Homing:   Master
    # Read the current values of parameters
    homeParam = Config_HomeParam()
    ret, homeParam = Wmx3Lib_cm.config.GetHomeParam(axis)
    homeParam.maxLSReverseDistance   = False
    # SetHomeParam -> First return value: Error code, Second return value: param error
    ret, homeParamError = Wmx3Lib_cm.config.SetHomeParam(axis, homeParam)
    if(ret!=0):
        print('Set maxLSReverseDistance  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Z-Pulse Distance Check     If set to a non-zero value, whenever a homing procedure that searches for multiple Z-pulses (index pulses) is executed, the distance between successive Z-pulses is checked. If the distance does not equal the distance specified in this parameter, a home error will be registered.
    # Variable Name:   zPulseDistanceCheck
    # Type:            double
    # Unit:            user unit
    # Minimum Value:   0
    # Maximum Value:   274877906943
    # Default Value:   0
    # Gantry Homing:   Master
    # Read the current values of parameters
    homeParam = Config_HomeParam()
    ret, homeParam = Wmx3Lib_cm.config.GetHomeParam(axis)
    homeParam.zPulseDistanceCheck   = 0
    # SetHomeParam -> First return value: Error code, Second return value: param error
    ret, homeParamError = Wmx3Lib_cm.config.SetHomeParam(axis, homeParam)
    if(ret!=0):
        print('Set zPulseDistanceCheck  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Home Position    The command position at the home position. At the end of homing, the axis will be at the home position with a command position equal to this value. This effectively shifts the zero position. The difference between this parameter and the Home Shift Distance is that the axis does not move by the shift amount at the end of homing.
    # Variable Name:   homePosition
    # Type:            double
    # Unit:            user unit
    # Minimum Value:   -274877906943
    # Maximum Value:   274877906943
    # Default Value:   0
    # Gantry Homing:   Master/Slave
    # Read the current values of parameters
    homeParam = Config_HomeParam()
    ret, homeParam = Wmx3Lib_cm.config.GetHomeParam(axis)
    homeParam.homePosition   = 0
    # SetHomeParam -> First return value: Error code, Second return value: param error
    ret, homeParamError = Wmx3Lib_cm.config.SetHomeParam(axis, homeParam)
    if(ret!=0):
        print('Set homePosition  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Gantry Homing Use Slave HS      This parameter only affects gantry homing. If this parameter is set to TRUE, the homing procedure will search for the slave axis home switches in addition to the home switch of the master axis. If this parameter is set to FALSE, the homing procedure will only search for the master axis home switch.
    # Variable Name:   gantryHomingUseSlaveHS
    # Type:            bool
    # Default Value:   FALSE
    # Gantry Homing:   Master
    # Read the current values of parameters
    homeParam = Config_HomeParam()
    ret, homeParam = Wmx3Lib_cm.config.GetHomeParam(axis)
    homeParam.gantryHomingUseSlaveHS   = False
    # SetHomeParam -> First return value: Error code, Second return value: param error
    ret, homeParamError = Wmx3Lib_cm.config.SetHomeParam(axis, homeParam)
    if(ret!=0):
        print('Set gantryHomingUseSlaveHS  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Gantry Homing Use Slave LS     This parameter only affects gantry homing. If this parameter is set to TRUE, the homing procedure will search for the slave axis limit switches in addition to the limit switch of the master axis. If this parameter is set to FALSE, the homing procedure will only search for the master axis limit switch.
    # Variable Name:   gantryHomingUseSlaveLS
    # Type:            bool
    # Default Value:   FALSE
    # Gantry Homing:   Master
    # Read the current values of parameters
    homeParam = Config_HomeParam()
    ret, homeParam = Wmx3Lib_cm.config.GetHomeParam(axis)
    homeParam.gantryHomingUseSlaveLS  = False
    # SetHomeParam -> First return value: Error code, Second return value: param error
    ret, homeParamError = Wmx3Lib_cm.config.SetHomeParam(axis, homeParam)
    if(ret!=0):
        print('Set gantryHomingUseSlaveLS error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Gantry Homing Use Slave Z-Pulse      This parameter only affects gantry homing. If this parameter is set to TRUE, the homing procedure will search for the slave axis Z-pulses (index pulses) in addition to the Z-pulse of the master axis. If this parameter is set to FALSE, the homing procedure will only search for the master axis Z-pulse.
    # Variable Name:   gantryHomingUseSlaveZPulse
    # Type:            bool
    # Default Value:   FALSE
    # Gantry Homing:   Master
    # Read the current values of parameters
    homeParam = Config_HomeParam()
    ret, homeParam = Wmx3Lib_cm.config.GetHomeParam(axis)
    homeParam.gantryHomingUseSlaveZPulse   = False
    # SetHomeParam -> First return value: Error code, Second return value: param error
    ret, homeParamError = Wmx3Lib_cm.config.SetHomeParam(axis, homeParam)
    if(ret!=0):
        print('Set gantryHomingUseSlaveZPulse  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Gantry Homing Use Slave Touch Probe      This parameter only affects gantry homing. If this parameter is set to TRUE, the homing procedure will search for the slave axis touch probes in addition to the touch probe of the master axis. If this parameter is set to FALSE, the homing procedure will only search for the master axis touch probe.
    # Variable Name:   gantryHomingUseSlaveTouchProbe
    # Type:            bool
    # Default Value:   FALSE
    # Gantry Homing:   Master
    # Read the current values of parameters
    homeParam = Config_HomeParam()
    ret, homeParam = Wmx3Lib_cm.config.GetHomeParam(axis)
    homeParam.gantryHomingUseSlaveTouchProbe  = False
    # SetHomeParam -> First return value: Error code, Second return value: param error
    ret, homeParamError = Wmx3Lib_cm.config.SetHomeParam(axis, homeParam)
    if(ret!=0):
        print('Set gantryHomingUseSlaveTouchProbe error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Gantry Homing Use Slave Mechanical End      This parameter only affects gantry homing. If this parameter is set to TRUE, the homing procedure will search for the slave axis mechanical ends in addition to the mechanical end of the master axis. If this parameter is set to FALSE, the homing procedure will only search for the master axis mechanical end.
    # Variable Name:   gantryHomingUseSlaveMechanicalEnd
    # Type:            bool
    # Default Value:   FALSE
    # Gantry Homing:   Master
    # Read the current values of parameters
    homeParam = Config_HomeParam()
    ret, homeParam = Wmx3Lib_cm.config.GetHomeParam(axis)
    homeParam.gantryHomingUseSlaveMechanicalEnd  = False
    # SetHomeParam -> First return value: Error code, Second return value: param error
    ret, homeParamError = Wmx3Lib_cm.config.SetHomeParam(axis, homeParam)
    if(ret!=0):
        print('Set gantryHomingUseSlaveMechanicalEnd error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Gantry Homing Retain Sync Offset      This parameter only affects gantry homing. If this parameter is set to TRUE, during the homing procedure, the sync offset between the master and slave is never broken. Depending on other parameters, the slave home positions may be searched, but they will be ignored after they are found, and the slave axes will follow the master axis to its home position instead.
    # Variable Name:   gantryHomingRetainSyncOffset
    # Type:            bool
    # Default Value:   FALSE
    # Gantry Homing:   Master
    # Read the current values of parameters
    homeParam = Config_HomeParam()
    ret, homeParam = Wmx3Lib_cm.config.GetHomeParam(axis)
    homeParam.gantryHomingRetainSyncOffset   = False
    # SetHomeParam -> First return value: Error code, Second return value: param error
    ret, homeParamError = Wmx3Lib_cm.config.SetHomeParam(axis, homeParam)
    if(ret!=0):
        print('Set gantryHomingRetainSyncOffset  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Immediate Stop at LS      If this parameter is set to TRUE, and the home type uses limit switches, the axis will immediately stop after detecting the limit switch, with infinite deceleration. No position command beyond the position where the limit switch was detected will be sent to the servo. This parameter is for servos that ignore position commands beyond the limit switch after the limit switch is detected. Enabling this parameter can reduce the time taken for the homing operation to complete, as no time is spent sending position commands that the servo will ignore anyway.
    # Variable Name:   immediateStopAtLS
    # Type:            bool
    # Default Value:   FALSE
    # Gantry Homing:   Master
    # Read the current values of parameters
    homeParam = Config_HomeParam()
    ret, homeParam = Wmx3Lib_cm.config.GetHomeParam(axis)
    homeParam.immediateStopAtLS  = False
    # SetHomeParam -> First return value: Error code, Second return value: param error
    ret, homeParamError = Wmx3Lib_cm.config.SetHomeParam(axis, homeParam)
    if(ret!=0):
        print('Set immediateStopAtLS error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Mechanical End Detection Pos Diff      This parameter only affects mechanical end detection home types. When the axis presses against the mechanical end, the home position will be detected when the difference between the command position and feedback position exceeds this parameter for Mechanical End Detection Time Milliseconds.
    # Variable Name:   mechanicalEndDetectionPosDiff
    # Type:            double
    # Unit:            user unit
    # Minimum Value:   0
    # Maximum Value:   274877906943
    # Default Value:   0
    # Gantry Homing:   Master/Slave
    # Read the current values of parameters
    homeParam = Config_HomeParam()
    ret, homeParam = Wmx3Lib_cm.config.GetHomeParam(axis)
    homeParam.mechanicalEndDetectionPosDiff  = 0
    # SetHomeParam -> First return value: Error code, Second return value: param error
    ret, homeParamError = Wmx3Lib_cm.config.SetHomeParam(axis, homeParam)
    if(ret!=0):
        print('Set mechanicalEndDetectionPosDiff error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Mechanical End Detection Time Milliseconds      This parameter only affects mechanical end detection home types. The home position will be detected when the difference between the command position and feedback position exceeds the Mechanical End Detection Pos Diff for the amount of time specified in this parameter.
    # Variable Name:   mechanicalEndDetectionTimeMilliseconds
    # Type:            double
    # Unit:            user unit
    # Minimum Value:   0
    # Maximum Value:   274877906943
    # Default Value:   0
    # Gantry Homing:   Master/Slave
    # Read the current values of parameters
    homeParam = Config_HomeParam()
    ret, homeParam = Wmx3Lib_cm.config.GetHomeParam(axis)
    homeParam.mechanicalEndDetectionTimeMilliseconds  = False
    # SetHomeParam -> First return value: Error code, Second return value: param error
    ret, homeParamError = Wmx3Lib_cm.config.SetHomeParam(axis, homeParam)
    if(ret!=0):
        print('Set mechanicalEndDetectionTimeMilliseconds error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Mechanical End Detection Ignore LS      This parameter only affects mechanical end detection home types, and it does not affect the MechanicalEndDetectionLS home type. When this parameter is set to TRUE, the limit switch in the direction of homing will be ignored if triggered. (Depending on the servo hardware and settings, the servo may still perform some action when the limit switch is triggered, such as generate an amp alarm.)
    # Variable Name:   mechanicalEndDetectionIgnoreLS
    # Type:            bool
    # Default Value:   FALSE
    # Gantry Homing:   Master
    # Read the current values of parameters
    homeParam = Config_HomeParam()
    ret, homeParam = Wmx3Lib_cm.config.GetHomeParam(axis)
    homeParam.mechanicalEndDetectionIgnoreLS  = False
    # SetHomeParam -> First return value: Error code, Second return value: param error
    ret, homeParamError = Wmx3Lib_cm.config.SetHomeParam(axis, homeParam)
    if(ret!=0):
        print('Set mechanicalEndDetectionIgnoreLS error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Mechanical End Detection First Torque Limit       This parameter only affects mechanical end detection home types (MechanicalEndDetection, MechanicalEndDetectionHS, MechanicalEndDetectionLS, and MechanicalEndDetectionReverseZPulse).
    # Variable Name:   mechanicalEndDetectionFirstTorqueLimit
    # Type:            double
    # Unit:            %
    # Minimum Value:   0
    # Maximum Value:   274877906943
    # Default Value:   0
    # Gantry Homing:   Master/Slave
    # Read the current values of parameters
    homeParam = Config_HomeParam()
    ret, homeParam = Wmx3Lib_cm.config.GetHomeParam(axis)
    homeParam.mechanicalEndDetectionFirstTorqueLimit  = False
    # SetHomeParam -> First return value: Error code, Second return value: param error
    ret, homeParamError = Wmx3Lib_cm.config.SetHomeParam(axis, homeParam)
    if(ret!=0):
        print('Set mechanicalEndDetectionFirstTorqueLimit error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Mechanical End Detection Second Torque Limit       This parameter only affects the MechanicalEndDetectionHS and MechanicalEndDetectionLS home types.
    # Variable Name:   mechanicalEndDetectionSecondTorqueLimit
    # Type:            double
    # Unit:            user unit
    # Minimum Value:   0
    # Maximum Value:   274877906943
    # Default Value:   0
    # Gantry Homing:   Master/Slave
    # Read the current values of parameters
    homeParam = Config_HomeParam()
    ret, homeParam = Wmx3Lib_cm.config.GetHomeParam(axis)
    homeParam.mechanicalEndDetectionSecondTorqueLimit  = False
    # SetHomeParam -> First return value: Error code, Second return value: param error
    ret, homeParamError = Wmx3Lib_cm.config.SetHomeParam(axis, homeParam)
    if(ret!=0):
        print('Set mechanicalEndDetectionSecondTorqueLimit error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Open Loop Homing      If set to FALSE, homing will be executed normally. If set to TRUE, the command position will be used instead of the feedback position to determine the home position. This parameter does not affect homing that uses the Z-pulse (index pulse) or touch probe, as these home types do not use the position feedback when determining the home position.
    # Variable Name:   openLoopHoming
    # Type:            bool
    # Default Value:   FALSE
    # Gantry Homing:   Master/Slave
    # Read the current values of parameters
    homeParam = Config_HomeParam()
    ret, homeParam = Wmx3Lib_cm.config.GetHomeParam(axis)
    homeParam.openLoopHoming  = False
    # SetHomeParam -> First return value: Error code, Second return value: param error
    ret, homeParamError = Wmx3Lib_cm.config.SetHomeParam(axis, homeParam)
    if(ret!=0):
        print('Set openLoopHoming error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Clear Home Done On Servo Off       If set to TRUE, the home done status will be cleared (set to 0) when the axis servo is in the servo off state. If set to FALSE, the home done status will not change when the axis servo is in the servo off state.
    # Variable Name:   clearHomeDoneOnServoOff
    # Type:            bool
    # Default Value:   FALSE
    # Gantry Homing:   Master
    # Read the current values of parameters
    homeParam = Config_HomeParam()
    ret, homeParam = Wmx3Lib_cm.config.GetHomeParam(axis)
    homeParam.clearHomeDoneOnServoOff  = False
    # SetHomeParam -> First return value: Error code, Second return value: param error
    ret, homeParamError = Wmx3Lib_cm.config.SetHomeParam(axis, homeParam)
    if(ret!=0):
        print('Set clearHomeDoneOnServoOff error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Clear Home Done On Comm Stop       If set to TRUE, the home done status will be cleared (set to 0) for all axes when the communication with the servo network is stopped. If set to FALSE, the home done status will not change when the communication with the servo network is stopped.
    # Variable Name:   clearHomeDoneOnCommStop
    # Type:            bool
    # Default Value:   True
    # Gantry Homing:   Master
    # Read the current values of parameters
    homeParam = Config_HomeParam()
    ret, homeParam = Wmx3Lib_cm.config.GetHomeParam(axis)
    homeParam.clearHomeDoneOnCommStop  = True
    # SetHomeParam -> First return value: Error code, Second return value: param error
    ret, homeParamError = Wmx3Lib_cm.config.SetHomeParam(axis, homeParam)
    if(ret!=0):
        print('Set clearHomeDoneOnCommStop error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return



#``



# Write Python code to set the Limit parameters for Axis 0. Set‘LS Type’to None,‘Positive LS Type’to None,‘Negative LS Type’to None,‘Invert Positive LS Polarity’to FALSE,‘Invert Negative LS Polarity’to FALSE,‘Near LS Type’to None,‘Near Positive LS Type’to None,‘Near Negative LS Type’to None,‘Near Positive LS Byte’to 0,‘Near Positive LS Bit’to 0,‘Invert Near Positive LS Polarity’to False,‘Near Negative LS Byte’to 0,‘Near Negative LS Bit’to 0,‘Invert Near Negative LS Polarity’to False,‘External LS Type’to None,‘External Positive LS Type’to None,‘External Negative LS Type’to None,‘External Positive LS Byte’to 0,‘Near Positive LS Bit’to 0,‘Invert External Positive LS Polarity’to False,‘External Positive LS Byte’to 0,‘External Negative LS Bit’to 0,‘Invert External Negative LS Polarity’to False,‘Soft Limit Type’to None,‘Positive Soft Limit Type’to None,‘Negative Soft Limit Type’to None,‘Soft Limit Positive Pos’to 0,‘Soft Limit Negative Pos’to 0,‘LS Dec’to 10000,‘LS Slow Dec’to 10000,‘All LS During Homing 'to 10000,‘LS Direction’to Normal.
    # Axes = [0]

    # Example of Axis 0
    axis = 0

    # LS Type          This parameter determines the action executed when the positive or negative limit switch is triggered.
    # Variable Name:   lsType
    # Type:            LimitSwitchType
    # Default Value:   None
    # Read the current values of parameters
    limitParam = Config_LimitParam()
    ret, limitParam = Wmx3Lib_cm.config.GetLimitParam(axis)
    limitParam.lsType = Config_LimitSwitchType.PyNone
    # limitParam -> First return value: Error code, Second return value: param error
    ret, limitParamError = Wmx3Lib_cm.config.SetLimitParam(axis, limitParam)
    if (ret != 0):
        print('Set lsType error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Positive LS Type      This parameter determines the action executed when the positive limit switch is triggered and the LS Type parameter is set to SeparatePositiveLSNegativeLS.
    # Variable Name:   positiveLSType
    # Type:            LimitSwitchType
    # Default Value:   None
    # Read the current values of parameters
    limitParam = Config_LimitParam()
    ret, limitParam = Wmx3Lib_cm.config.GetLimitParam(axis)
    limitParam.positiveLSType = Config_LimitSwitchType.PyNone
    # limitParam -> First return value: Error code, Second return value: param error
    ret, limitParamError = Wmx3Lib_cm.config.SetLimitParam(axis, limitParam)
    if (ret != 0):
        print('Set positiveLSType error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Negative LS Type     This parameter determines the action executed when the negative limit switch is triggered and the LS Type parameter is set to SeparatePositiveLSNegativeLS.
    # Variable Name:   negativeLSType
    # Type:            LimitSwitchType
    # Default Value:   None
    # Read the current values of parameters
    limitParam = Config_LimitParam()
    ret, limitParam = Wmx3Lib_cm.config.GetLimitParam(axis)
    limitParam.negativeLSType = Config_LimitSwitchType.PyNone
    # limitParam -> First return value: Error code, Second return value: param error
    ret, limitParamError = Wmx3Lib_cm.config.SetLimitParam(axis, limitParam)
    if (ret != 0):
        print('Set negativeLSType error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Invert Positive LS Polarity      TRUE: The positive limit switch polarity will be inverted and become active low.FALSE: The positive limit switch polarity will be normal and be active high.
    # Variable Name:   invertPositiveLSPolarity
    # Type:            bool
    # Default Value:   FALSE
    # Read the current values of parameters
    limitParam = Config_LimitParam()
    ret, limitParam = Wmx3Lib_cm.config.GetLimitParam(axis)
    limitParam.invertPositiveLSPolarity  = False
    # limitParam -> First return value: Error code, Second return value: param error
    ret, limitParamError = Wmx3Lib_cm.config.SetLimitParam(axis, limitParam)
    if (ret != 0):
        print('Set invertPositiveLSPolarity  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Invert Negative LS Polarity      TRUE: The negative limit switch polarity will be inverted and become active low.FALSE: The negative limit switch polarity will be normal and be active high.
    # Variable Name:   invertNegativeLSPolarity
    # Type:            bool
    # Default Value:   FALSE
    # Read the current values of parameters
    limitParam = Config_LimitParam()
    ret, limitParam = Wmx3Lib_cm.config.GetLimitParam(axis)
    limitParam.invertNegativeLSPolarity   = False
    # limitParam -> First return value: Error code, Second return value: param error
    ret, limitParamError = Wmx3Lib_cm.config.SetLimitParam(axis, limitParam)
    if (ret != 0):
        print('Set invertNegativeLSPolarity   error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Near LS Type     This parameter determines the action executed when the positive or negative near limit switch is triggered. The near limit switch is a software-based limit switch that can be mapped to any I/O input.If this parameter is set to None, the near limit switch will be disabled.
    # Variable Name:   nearLSType
    # Type:            LimitSwitchType
    # Default Value:   None
    # Read the current values of parameters
    limitParam = Config_LimitParam()
    ret, limitParam = Wmx3Lib_cm.config.GetLimitParam(axis)
    limitParam.nearLSType   = Config_LimitSwitchType.PyNone
    # limitParam -> First return value: Error code, Second return value: param error
    ret, limitParamError = Wmx3Lib_cm.config.SetLimitParam(axis, limitParam)
    if (ret != 0):
        print('Set nearLSType  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Near Positive LS Type      This parameter determines the action executed when the positive near limit switch is triggered and the Near LS Type is set to SeparatePositiveLSNegativeLS.
    # Variable Name:   nearPositiveLSType
    # Type:            LimitSwitchType
    # Default Value:   None
    # Read the current values of parameters
    limitParam = Config_LimitParam()
    ret, limitParam = Wmx3Lib_cm.config.GetLimitParam(axis)
    limitParam.nearPositiveLSType    = Config_LimitSwitchType.PyNone
    # limitParam -> First return value: Error code, Second return value: param error
    ret, limitParamError = Wmx3Lib_cm.config.SetLimitParam(axis, limitParam)
    if (ret != 0):
        print('Set nearPositiveLSType   error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Near Negative LS Type    This parameter determines the action executed when the negative near limit switch is triggered and the Near LS Type is set to SeparatePositiveLSNegativeLS.
    # Variable Name:   nearNegativeLSType
    # Type:            LimitSwitchType
    # Default Value:   None
    # Read the current values of parameters
    limitParam = Config_LimitParam()
    ret, limitParam = Wmx3Lib_cm.config.GetLimitParam(axis)
    limitParam.nearNegativeLSType   = Config_LimitSwitchType.PyNone
    # limitParam -> First return value: Error code, Second return value: param error
    ret, limitParamError = Wmx3Lib_cm.config.SetLimitParam(axis, limitParam)
    if (ret != 0):
        print('Set nearPositiveLSType  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Near Positive LS Byte    The byte address of the positive near limit switch I/O input.
    # Variable Name:   nearPositiveLSByte
    # Type:            int
    # Minimum Value:   0
    # Maximum Value:   7999
    # Default Value:   0
    # Read the current values of parameters
    limitParam = Config_LimitParam()
    ret, limitParam = Wmx3Lib_cm.config.GetLimitParam(axis)
    limitParam.nearPositiveLSByte  = 0
    # limitParam -> First return value: Error code, Second return value: param error
    ret, limitParamError = Wmx3Lib_cm.config.SetLimitParam(axis, limitParam)
    if (ret != 0):
        print('Set nearPositiveLSByte error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Near Positive LS Bit     The bit address of the positive near limit switch I/O input.
    # Variable Name:   nearPositiveLSBit
    # Type:            int
    # Minimum Value:   0
    # Maximum Value:   7
    # Default Value:   0
    # Read the current values of parameters
    limitParam = Config_LimitParam()
    ret, limitParam = Wmx3Lib_cm.config.GetLimitParam(axis)
    limitParam.nearPositiveLSBit = 0
    # limitParam -> First return value: Error code, Second return value: param error
    ret, limitParamError = Wmx3Lib_cm.config.SetLimitParam(axis, limitParam)
    if (ret != 0):
        print('Set nearPositiveLSBit error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Invert Near Positive LS Polarity    TRUE: The positive near limit switch polarity will be inverted and become active low.FALSE: The positive near limit switch polarity will be normal and be active high.
    # Variable Name:   invertNearPositiveLSPolarity
    # Type:            bool
    # Default Value:   False
    # Read the current values of parameters
    limitParam = Config_LimitParam()
    ret, limitParam = Wmx3Lib_cm.config.GetLimitParam(axis)
    limitParam.invertNearPositiveLSPolarity = False
    # limitParam -> First return value: Error code, Second return value: param error
    ret, limitParamError = Wmx3Lib_cm.config.SetLimitParam(axis, limitParam)
    if (ret != 0):
        print('Set invertNearPositiveLSPolarity error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Near Negative LS Byte    The byte address of the Negative near limit switch I/O input.
    # Variable Name:   nearNegativeLSByte
    # Type:            int
    # Minimum Value:   0
    # Maximum Value:   7999
    # Default Value:   0
    # Read the current values of parameters
    limitParam = Config_LimitParam()
    ret, limitParam = Wmx3Lib_cm.config.GetLimitParam(axis)
    limitParam.nearNegativeLSByte = 0
    # limitParam -> First return value: Error code, Second return value: param error
    ret, limitParamError = Wmx3Lib_cm.config.SetLimitParam(axis, limitParam)
    if (ret != 0):
        print('Set nearNegativeLSByte error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Near Negative LS Bit     The bit address of the Negative near limit switch I/O input.
    # Variable Name:   nearNegativeLSBit
    # Type:            int
    # Minimum Value:   0
    # Maximum Value:   7
    # Default Value:   0
    # Read the current values of parameters
    limitParam = Config_LimitParam()
    ret, limitParam = Wmx3Lib_cm.config.GetLimitParam(axis)
    limitParam.nearNegativeLSBit = 0
    # limitParam -> First return value: Error code, Second return value: param error
    ret, limitParamError = Wmx3Lib_cm.config.SetLimitParam(axis, limitParam)
    if (ret != 0):
        print('Set nearNegativeLSBit error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Invert Near Negative LS Polarity    TRUE: The negative near limit switch polarity will be inverted and become active low.FALSE: The negative near limit switch polarity will be normal and be active high.
    # Variable Name:   invertNearNegativeLSPolarity
    # Type:            bool
    # Default Value:   False
    # Read the current values of parameters
    limitParam = Config_LimitParam()
    ret, limitParam = Wmx3Lib_cm.config.GetLimitParam(axis)
    limitParam.invertNearNegativeLSPolarity = False
    # limitParam -> First return value: Error code, Second return value: param error
    ret, limitParamError = Wmx3Lib_cm.config.SetLimitParam(axis, limitParam)
    if (ret != 0):
        print('Set invertNearNegativeLSPolarity error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # External LS Type     This parameter determines the action executed when the positive or negative external limit switch is triggered. The external limit switch is a software-based limit switch that can be mapped to any I/O input. There is no difference between external limit switches and near limit switches, except that they use a different set of parameters.If this parameter is set to None, the external limit switch will be disabled.
    # Variable Name:   externalLSType
    # Type:            LimitSwitchType
    # Default Value:   None
    # Read the current values of parameters
    limitParam = Config_LimitParam()
    ret, limitParam = Wmx3Lib_cm.config.GetLimitParam(axis)
    limitParam.externalLSType   = Config_LimitSwitchType.PyNone
    # limitParam -> First return value: Error code, Second return value: param error
    ret, limitParamError = Wmx3Lib_cm.config.SetLimitParam(axis, limitParam)
    if (ret != 0):
        print('Set externalLSType error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # External Positive LS Type     This parameter determines the action executed when the positive external limit switch is triggered and the External LS Type is set to SeparatePositiveLSNegativeLS.
    # Variable Name:   externalPositiveLSType
    # Type:            LimitSwitchType
    # Default Value:   None
    # Read the current values of parameters
    limitParam = Config_LimitParam()
    ret, limitParam = Wmx3Lib_cm.config.GetLimitParam(axis)
    limitParam.externalPositiveLSType  = Config_LimitSwitchType.PyNone
    # limitParam -> First return value: Error code, Second return value: param error
    ret, limitParamError = Wmx3Lib_cm.config.SetLimitParam(axis, limitParam)
    if (ret != 0):
        print('Set externalPositiveLSType error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # External Negative LS Type   This parameter determines the action executed when the negative external limit switch is triggered and the External LS Type is set to SeparatePositiveLSNegativeLS.
    # Variable Name:   externalNegativeLSType
    # Type:            LimitSwitchType
    # Default Value:   None
    # Read the current values of parameters
    limitParam = Config_LimitParam()
    ret, limitParam = Wmx3Lib_cm.config.GetLimitParam(axis)
    limitParam.externalNegativeLSType   = Config_LimitSwitchType.PyNone
    # limitParam -> First return value: Error code, Second return value: param error
    ret, limitParamError = Wmx3Lib_cm.config.SetLimitParam(axis, limitParam)
    if (ret != 0):
        print('Set externalNegativeLSType error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # External Positive LS Byte    The byte address of the positive external limit switch I/O input.
    # Variable Name:   externalPositiveLSByte
    # Type:            int
    # Minimum Value:   0
    # Maximum Value:   7999
    # Default Value:   0
    # Read the current values of parameters
    limitParam = Config_LimitParam()
    ret, limitParam = Wmx3Lib_cm.config.GetLimitParam(axis)
    limitParam.externalPositiveLSByte = 0
    # limitParam -> First return value: Error code, Second return value: param error
    ret, limitParamError = Wmx3Lib_cm.config.SetLimitParam(axis, limitParam)
    if (ret != 0):
        print('Set externalPositiveLSByte error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Near Positive LS Bit     The bit address of the positive external limit switch I/O input.
    # Variable Name:   externalPositiveLSBit
    # Type:            int
    # Minimum Value:   0
    # Maximum Value:   7
    # Default Value:   0
    # Read the current values of parameters
    limitParam = Config_LimitParam()
    ret, limitParam = Wmx3Lib_cm.config.GetLimitParam(axis)
    limitParam.externalPositiveLSBit  = 0
    # limitParam -> First return value: Error code, Second return value: param error
    ret, limitParamError = Wmx3Lib_cm.config.SetLimitParam(axis, limitParam)
    if (ret != 0):
        print('Set externalPositiveLSBit  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Invert External Positive LS Polarity    TRUE: The positive external limit switch polarity will be inverted and become active low.FALSE: The positive external limit switch polarity will be normal and be active high.
    # Variable Name:   invertExternalPositiveLSPolarity
    # Type:            bool
    # Default Value:   False
    # Read the current values of parameters
    limitParam = Config_LimitParam()
    ret, limitParam = Wmx3Lib_cm.config.GetLimitParam(axis)
    limitParam.invertExternalPositiveLSPolarity = False
    # limitParam -> First return value: Error code, Second return value: param error
    ret, limitParamError = Wmx3Lib_cm.config.SetLimitParam(axis, limitParam)
    if (ret != 0):
        print('Set invertExternalPositiveLSPolarity error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # External Negative LS Byte    The byte address of the negative external limit switch I/O input.
    # Variable Name:   externalNegativeLSByte
    # Type:            int
    # Minimum Value:   0
    # Maximum Value:   7999
    # Default Value:   0
    # Read the current values of parameters
    limitParam = Config_LimitParam()
    ret, limitParam = Wmx3Lib_cm.config.GetLimitParam(axis)
    limitParam.externalNegativeLSByte  = 0
    # limitParam -> First return value: Error code, Second return value: param error
    ret, limitParamError = Wmx3Lib_cm.config.SetLimitParam(axis, limitParam)
    if (ret != 0):
        print('Set externalNegativeLSByte error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # External Negative LS Bit     The bit address of the negative external limit switch I/O input.
    # Variable Name:   externalNegativeLSBit
    # Type:            int
    # Minimum Value:   0
    # Maximum Value:   7
    # Default Value:   0
    # Read the current values of parameters
    limitParam = Config_LimitParam()
    ret, limitParam = Wmx3Lib_cm.config.GetLimitParam(axis)
    limitParam.externalNegativeLSBit = 0
    # limitParam -> First return value: Error code, Second return value: param error
    ret, limitParamError = Wmx3Lib_cm.config.SetLimitParam(axis, limitParam)
    if (ret != 0):
        print('Set externalNegativeLSBit error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Invert External Negative LS Polarity    TRUE: The negative external limit switch polarity will be inverted and become active low.FALSE: The negative external limit switch polarity will be normal and be active high.
    # Variable Name:   invertExternalNegativeLSPolarity
    # Type:            bool
    # Default Value:   False
    # Read the current values of parameters
    limitParam = Config_LimitParam()
    ret, limitParam = Wmx3Lib_cm.config.GetLimitParam(axis)
    limitParam.invertExternalNegativeLSPolarity = False
    # limitParam -> First return value: Error code, Second return value: param error
    ret, limitParamError = Wmx3Lib_cm.config.SetLimitParam(axis, limitParam)
    if (ret != 0):
        print('Set invertExternalNegativeLSPolarity error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Soft Limit Type   This parameter determines the action executed when the axis reaches the positive or negative software limit.
    # Variable Name:   softLimitType
    # Type:            LimitSwitchType
    # Default Value:   None
    # Read the current values of parameters
    limitParam = Config_LimitParam()
    ret, limitParam = Wmx3Lib_cm.config.GetLimitParam(axis)
    limitParam.softLimitType  = Config_LimitSwitchType.PyNone
    # limitParam -> First return value: Error code, Second return value: param error
    ret, limitParamError = Wmx3Lib_cm.config.SetLimitParam(axis, limitParam)
    if (ret != 0):
        print('Set softLimitType  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Positive Soft Limit Type   This parameter determines the action executed when the axis reaches the positive software limit and the Soft Limit Type is set to SeparatePositiveLSNegativeLS.
    # Variable Name:   positiveSoftLimitType
    # Type:            LimitSwitchType
    # Default Value:   None
    # Read the current values of parameters
    limitParam = Config_LimitParam()
    ret, limitParam = Wmx3Lib_cm.config.GetLimitParam(axis)
    limitParam.positiveSoftLimitType  = Config_LimitSwitchType.PyNone
    # limitParam -> First return value: Error code, Second return value: param error
    ret, limitParamError = Wmx3Lib_cm.config.SetLimitParam(axis, limitParam)
    if (ret != 0):
        print('Set positiveSoftLimitType  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Negative Soft Limit Type   This parameter determines the action executed when the axis reaches the negative software limit and the Soft Limit Type is set to SeparatePositiveLSNegativeLS.
    # Variable Name:   negativeSoftLimitType
    # Type:            LimitSwitchType
    # Default Value:   None
    # Read the current values of parameters
    limitParam = Config_LimitParam()
    ret, limitParam = Wmx3Lib_cm.config.GetLimitParam(axis)
    limitParam.negativeSoftLimitType  = Config_LimitSwitchType.PyNone
    # limitParam -> First return value: Error code, Second return value: param error
    ret, limitParamError = Wmx3Lib_cm.config.SetLimitParam(axis, limitParam)
    if (ret != 0):
        print('Set negativeSoftLimitType  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Soft Limit Positive Pos   The position at which the positive software limit will be triggered. If the axis command position exceeds this value in the positive direction, a software limit will be triggered.No software limit will be set for the positive direction if this parameter is set to 0.
    # Variable Name:   softLimitPositivePos
    # Type:            double
    # Uinit:           user unit
    # Default Value:   0
    # Read the current values of parameters
    limitParam = Config_LimitParam()
    ret, limitParam = Wmx3Lib_cm.config.GetLimitParam(axis)
    limitParam.softLimitPositivePos  = 0
    # limitParam -> First return value: Error code, Second return value: param error
    ret, limitParamError = Wmx3Lib_cm.config.SetLimitParam(axis, limitParam)
    if (ret != 0):
        print('Set softLimitPositivePos  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Soft Limit Negative Pos   The position at which the Negative software limit will be triggered. If the axis command position exceeds this value in the Negative direction, a software limit will be triggered.No software limit will be set for the Negative direction if this parameter is set to 0.
    # Variable Name:   softLimitNegativePos
    # Type:            double
    # Uinit:           user unit
    # Default Value:   0
    # Read the current values of parameters
    limitParam = Config_LimitParam()
    ret, limitParam = Wmx3Lib_cm.config.GetLimitParam(axis)
    limitParam.softLimitNegativePos  = 0
    # limitParam -> First return value: Error code, Second return value: param error
    ret, limitParamError = Wmx3Lib_cm.config.SetLimitParam(axis, limitParam)
    if (ret != 0):
        print('Set softLimitNegativePos  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # LS Dec           The deceleration to stop the axis at when the limit switch is triggered. This parameter is applicable for the Dec and DecServoOff limit switch types.
    # Variable Name:   lsDec
    # Type:            double
    # Uinit:           user unit/second^2
    # Minimum Value:   1e-6
    # Maximum Value:   274877906943
    # Default Value:   10000
    # Read the current values of parameters
    limitParam = Config_LimitParam()
    ret, limitParam = Wmx3Lib_cm.config.GetLimitParam(axis)
    limitParam.lsDec   = 10000
    # limitParam -> First return value: Error code, Second return value: param error
    ret, limitParamError = Wmx3Lib_cm.config.SetLimitParam(axis, limitParam)
    if (ret != 0):
        print('Set lsDec  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # LS Slow Dec      The deceleration to stop the axis at when the limit switch is triggered. This parameter is applicable for the SlowDec and SlowDecServoOff limit switch types. This parameter and the LS Dec parameter affect different limit switch types, but otherwise have the same functionality.
    # Variable Name:   lsSlowDec
    # Type:            double
    # Uinit:           user unit/second^2
    # Minimum Value:   1e-6
    # Maximum Value:   274877906943
    # Default Value:   10000
    # Read the current values of parameters
    limitParam = Config_LimitParam()
    ret, limitParam = Wmx3Lib_cm.config.GetLimitParam(axis)
    limitParam.lsSlowDec   = 10000
    # limitParam -> First return value: Error code, Second return value: param error
    ret, limitParamError = Wmx3Lib_cm.config.SetLimitParam(axis, limitParam)
    if (ret != 0):
        print('Set lsSlowDec  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # All LS During Homing     TRUE: While homing, the positive limit switch can trigger while the axis is moving in the negative direction, and the negative limit switch can trigger while the axis is moving in the positive direction.FALSE:The positive limit switch will not trigger while the axis is moving in the negative direction, and the negative limit switch will not trigger while the axis is moving in the positive direction.
    # Variable Name:   allLSDuringHoming
    # Type:            bool
    # Default Value:   False
    # Read the current values of parameters
    limitParam = Config_LimitParam()
    ret, limitParam = Wmx3Lib_cm.config.GetLimitParam(axis)
    limitParam.allLSDuringHoming = False
    # limitParam -> First return value: Error code, Second return value: param error
    ret, limitParamError = Wmx3Lib_cm.config.SetLimitParam(axis, limitParam)
    if (ret != 0):
        print('Set allLSDuringHoming error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # LS Direction     This parameter indicates whether the positive and negative limit switches are attached in the normal direction or the reverse direction.If this parameter is set to Normal, the positive limit switch should be attached in the positive direction of the axis and the negative limit switch should be attached in the negative direction of the axis. If this parameter is set to Reverse, the positive limit switch should be attached in the negative direction of the axis and the negative limit switch should be attached in the positive direction of the axis.
    # Variable Name:   lsDirection
    # Type:            LimitSwitchDirection
    # Default Value:   Normal
    # Read the current values of parameters
    limitParam = Config_LimitParam()
    ret, limitParam = Wmx3Lib_cm.config.GetLimitParam(axis)
    limitParam.lsDirection  = Config_LimitSwitchDirection.Normal
    # limitParam -> First return value: Error code, Second return value: param error
    ret, limitParamError = Wmx3Lib_cm.config.SetLimitParam(axis, limitParam)
    if (ret != 0):
        print('Set lsDirection  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return



#``



# Write Python code to set the Motion parameters for Axis 0. Set‘Quick Stop Dec’to 100000,‘Prohibit Overtravel’to ChangeDeceleration,‘Linear Intpl Override Type’to FastBlending,‘Linear Intpl Override Smooth Percent’to 30,‘Circular Intpl Override Type’to FALSE,‘Interrupted Intpl Use Quick Stop’to FALSE,‘Single Turn Reduce To Half Turn’to TRUE,‘Enable Global Starting Velocity’to FALSE,‘Global Starting Velocity ’to 0,‘Enable Global End Velocity’to FALSE,‘Enable Global End Velocity’to FALSE,‘ Global End Velocity’to 0,‘Enable Global Min Velocity’to FALSE,‘Global Min Velocity’to 0,‘Enable Global Moving Average Profile Time Milliseconds’to FALSE,‘Global Moving Average Profile Time Milliseconds’to 0,‘API Wait Until Motion Start’to TRUE,‘Linear Intpl Profile Calc Mode’to AxisLimit,
    # Axes = [0]

    # Example of Axis 0 Homing Parameters
    axis = 0

    # Quick Stop Dec   This parameter indicates whether the positive and negative limit switches are attached in the normal direction or the reverse direction.If this parameter is set to Normal, the positive limit switch should be attached in the positive direction of the axis and the negative limit switch should be attached in the negative direction of the axis. If this parameter is set to Reverse, the positive limit switch should be attached in the negative direction of the axis and the negative limit switch should be attached in the positive direction of the axis.
    # Variable Name:   quickStopDec
    # Type:            double
    # Unit:            user unit/second^2
    # Minimum Value:   1e-6
    # Maximum Value:   274877906943
    # Default Value:   100000
    # Read the current values of parameters
    motionParam = Config_MotionParam()
    ret, motionParam = Wmx3Lib_cm.config.GetMotionParam(axis)
    motionParam.quickStopDec = 100000
    # motionParam -> First return value: Error code, Second return value: param error
    ret, motionParamError = Wmx3Lib_cm.config.SetMotionParam(axis, motionParam)
    if (ret != 0):
        print('Set quickStopDec  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Prohibit Overtravel    This parameter determines whether an axis is allowed to overtravel beyond the target position, reverse direction, and move back to the target position if a profile could not be generated otherwise. For example, the axis may overtravel if an override is executed while the axis is at a high enough velocity such that it cannot decelerate to zero velocity before reaching the target position.
    # Variable Name:   prohibitOvertravel
    # Type:            ProhibitOvertravelType
    # Default Value:   ChangeDeceleration
    # Read the current values of parameters
    motionParam = Config_MotionParam()
    ret, motionParam = Wmx3Lib_cm.config.GetMotionParam(axis)
    motionParam.prohibitOvertravel = Config_ProhibitOvertravelType.ChangeDeceleration
    # motionParam -> First return value: Error code, Second return value: param error
    ret, motionParamError = Wmx3Lib_cm.config.SetMotionParam(axis, motionParam)
    if (ret != 0):
        print('Set prohibitOvertravel  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Linear Intpl Override Type    This parameter determines the method by which a linear interpolation override is executed.When executing a linear interpolation override, the value of this parameter for the first axis of the override linear interpolation is applied.
    # Variable Name:   linearIntplOverrideType
    # Type:            LinearIntplOverrideType
    # Default Value:   FastBlending
    # Read the current values of parameters
    motionParam = Config_MotionParam()
    ret, motionParam = Wmx3Lib_cm.config.GetMotionParam(axis)
    motionParam.linearIntplOverrideType = Config_LinearIntplOverrideType.FastBlending
    # motionParam -> First return value: Error code, Second return value: param error
    ret, motionParamError = Wmx3Lib_cm.config.SetMotionParam(axis, motionParam)
    if (ret != 0):
        print('Set linearIntplOverrideType  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Linear Intpl Override Smooth Percent    This parameter determines the amount of smoothing to apply during linear interpolation overrides, as a percentage of the travel distance of the override linear interpolation.This parameter only has an effect if the Linear Intpl Override Type parameter is set to Smoothing.
    # Variable Name:   linearIntplOverrideSmoothPercent
    # Type:            unsigned int
    # Unit:            %
    # Minimum Value:   0
    # Maximum Value:   100
    # Default Value:   30
    # Read the current values of parameters
    motionParam = Config_MotionParam()
    ret, motionParam = Wmx3Lib_cm.config.GetMotionParam(axis)
    motionParam.linearIntplOverrideSmoothPercent = 30
    # motionParam -> First return value: Error code, Second return value: param error
    ret, motionParamError = Wmx3Lib_cm.config.SetMotionParam(axis, motionParam)
    if (ret != 0):
        print('Set linearIntplOverrideSmoothPercent  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Circular Intpl Override Type    This parameter determines the method by which a circular interpolation override is executed. When executing a circular interpolation override, the value of this parameter for the first axis of the override circular interpolation is applied.
    # Variable Name:   circularIntplOverrideType
    # Type:            bool
    # Default Value:   FALSE
    # Read the current values of parameters
    motionParam = Config_MotionParam()
    ret, motionParam = Wmx3Lib_cm.config.GetMotionParam(axis)
    motionParam.circularIntplOverrideType = Config_CircularIntplOverrideType.FastBlending
    # motionParam -> First return value: Error code, Second return value: param error
    ret, motionParamError = Wmx3Lib_cm.config.SetMotionParam(axis, motionParam)
    if (ret != 0):
        print('Set interruptedIntplUseQuickStop error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Interrupted Intpl Use Quick Stop     If an interpolation command is interrupted (one of the interpolating axes triggers a limit switch, reaches the software limit, generates an amp alarm, etc.), all interpolating axes will decelerate to a stop. For axes with this parameter set to FALSE, the axes will decelerate along the original interpolated path, retaining the composite deceleration of the original interpolation command. For axes with this parameter set to TRUE, the axes will decelerate independently at the deceleration of the Quick Stop Dec parameter.
    # Variable Name:   interruptedIntplUseQuickStop
    # Type:            bool
    # Default Value:   FALSE
    # Read the current values of parameters
    motionParam = Config_MotionParam()
    ret, motionParam = Wmx3Lib_cm.config.GetMotionParam(axis)
    motionParam.interruptedIntplUseQuickStop = False
    # motionParam -> First return value: Error code, Second return value: param error
    ret, motionParamError = Wmx3Lib_cm.config.SetMotionParam(axis, motionParam)
    if (ret != 0):
        print('Set interruptedIntplUseQuickStop error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Single Turn Reduce To Half Turn    This parameter determines the method by which a circular interpolation override is executed. When executing a circular interpolation override, the value of this parameter for the first axis of the override circular interpolation is applied.
    # Variable Name:   singleTurnReduceToHalfTurn
    # Type:            bool
    # Default Value:   TRUE
    # Read the current values of parameters
    motionParam = Config_MotionParam()
    ret, motionParam = Wmx3Lib_cm.config.GetMotionParam(axis)
    motionParam.singleTurnReduceToHalfTurn = True
    # motionParam -> First return value: Error code, Second return value: param error
    ret, motionParamError = Wmx3Lib_cm.config.SetMotionParam(axis, motionParam)
    if (ret != 0):
        print('Set singleTurnReduceToHalfTurn  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Enable Global Starting Velocity   TRUE: The value specified in Starting Velocity for the motion commands of this axis will be ignored and overwritten by the value of the Global Starting Velocity parameter.FALSE: Starting Velocity is specified normally.
    # Variable Name:   enableGlobalStartingVelocity
    # Type:            bool
    # Default Value:   FALSE
    # Read the current values of parameters
    motionParam = Config_MotionParam()
    ret, motionParam = Wmx3Lib_cm.config.GetMotionParam(axis)
    motionParam.enableGlobalStartingVelocity = False
    # motionParam -> First return value: Error code, Second return value: param error
    ret, motionParamError = Wmx3Lib_cm.config.SetMotionParam(axis, motionParam)
    if (ret != 0):
        print('Set enableGlobalStartingVelocity  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Global Starting Velocity    If Enable Global Starting Velocity is TRUE, the value set for this parameter will overwrite the Starting Velocity used by this axis during motion.
    # Variable Name:   globalStartingVelocity
    # Type:            double
    # Unit:            user unit / second
    # Minimum Value:   0
    # Maximum Value:   274877906943
    # Default Value:   0
    # Read the current values of parameters
    motionParam = Config_MotionParam()
    ret, motionParam = Wmx3Lib_cm.config.GetMotionParam(axis)
    motionParam.globalStartingVelocity = 0
    # motionParam -> First return value: Error code, Second return value: param error
    ret, motionParamError = Wmx3Lib_cm.config.SetMotionParam(axis, motionParam)
    if (ret != 0):
        print('Set globalStartingVelocity error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Enable Global End Velocity    TRUE: The value specified in End Velocity for the motion commands of this axis will be ignored and overwritten by the value of the Global End Velocity parameter.FALSE: End Velocity is specified normally.
    # Variable Name:   enableGlobalEndVelocity
    # Type:            bool
    # Default Value:   FALSE
    # Read the current values of parameters
    motionParam = Config_MotionParam()
    ret, motionParam = Wmx3Lib_cm.config.GetMotionParam(axis)
    motionParam.enableGlobalEndVelocity  = False
    # motionParam -> First return value: Error code, Second return value: param error
    ret, motionParamError = Wmx3Lib_cm.config.SetMotionParam(axis, motionParam)
    if (ret != 0):
        print('Set enableGlobalEndVelocity  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Enable Global End Velocity    TRUE: The value specified in End Velocity for the motion commands of this axis will be ignored and overwritten by the value of the Global End Velocity parameter.FALSE: End Velocity is specified normally.
    # Variable Name:   enableGlobalEndVelocity
    # Type:            bool
    # Default Value:   FALSE
    # Read the current values of parameters
    motionParam = Config_MotionParam()
    ret, motionParam = Wmx3Lib_cm.config.GetMotionParam(axis)
    motionParam.enableGlobalEndVelocity  = False
    # motionParam -> First return value: Error code, Second return value: param error
    ret, motionParamError = Wmx3Lib_cm.config.SetMotionParam(axis, motionParam)
    if (ret != 0):
        print('Set enableGlobalEndVelocity  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Global End Velocity     If Enable Global End Velocity is TRUE, the value set for this parameter will overwrite the End Velocity used by this axis during motion.
    # Variable Name:   globalEndVelocity
    # Type:            double
    # Unit:            user unit / second
    # Minimum Value:   0
    # Maximum Value:   274877906943
    # Default Value:   0
    # Read the current values of parameters
    motionParam = Config_MotionParam()
    ret, motionParam = Wmx3Lib_cm.config.GetMotionParam(axis)
    motionParam.globalEndVelocity  = 0
    # motionParam -> First return value: Error code, Second return value: param error
    ret, motionParamError = Wmx3Lib_cm.config.SetMotionParam(axis, motionParam)
    if (ret != 0):
        print('Set globalEndVelocity  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Enable Global Min Velocity    TRUE: The value specified to the Global Min Velocity parameter will set a minimum velocity at which the axis moves at during motion commands. The axis will never move at a velocity below the minimum velocity, regardless of the values set for Velocity, Starting Velocity, and End Velocity.
    # Variable Name:   enableGlobalMinVelocity
    # Type:            bool
    # Default Value:   FALSE
    # Read the current values of parameters
    motionParam = Config_MotionParam()
    ret, motionParam = Wmx3Lib_cm.config.GetMotionParam(axis)
    motionParam.enableGlobalMinVelocity  = False
    # motionParam -> First return value: Error code, Second return value: param error
    ret, motionParamError = Wmx3Lib_cm.config.SetMotionParam(axis, motionParam)
    if (ret != 0):
        print('Set enableGlobalMinVelocity  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Global Min Velocity     TRUE: The value specified in End Velocity for the motion commands of this axis will be ignored and overwritten by the value of the Global End Velocity parameter.FALSE: End Velocity is specified normally.
    # Variable Name:   globalMinVelocity
    # Type:            double
    # Unit:            user unit / second
    # Minimum Value:   0
    # Maximum Value:   274877906943
    # Default Value:   0
    # Read the current values of parameters
    motionParam = Config_MotionParam()
    ret, motionParam = Wmx3Lib_cm.config.GetMotionParam(axis)
    motionParam.globalMinVelocity   = 0
    # motionParam -> First return value: Error code, Second return value: param error
    ret, motionParamError = Wmx3Lib_cm.config.SetMotionParam(axis, motionParam)
    if (ret != 0):
        print('Set globalMinVelocity  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Enable Global Moving Average Profile Time Milliseconds     TRUE: The value specified in Moving Average Time Milliseconds for the motion commands of this axis will be ignored and overwritten by the value of the Global Moving Average Profile Time Milliseconds parameter.FALSE: Moving Average Time Milliseconds is specified normally.
    # Variable Name:   enableGlobalMovingAverageProfileTimeMilliseconds
    # Type:            bool
    # Default Value:   FALSE
    # Read the current values of parameters
    motionParam = Config_MotionParam()
    ret, motionParam = Wmx3Lib_cm.config.GetMotionParam(axis)
    motionParam.enableGlobalMovingAverageProfileTimeMilliseconds   = False
    # motionParam -> First return value: Error code, Second return value: param error
    ret, motionParamError = Wmx3Lib_cm.config.SetMotionParam(axis, motionParam)
    if (ret != 0):
        print('Set enableGlobalMovingAverageProfileTimeMilliseconds  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Global Moving Average Profile Time Milliseconds     TRUE: The value specified in End Velocity for the motion commands of this axis will be ignored and overwritten by the value of the Global End Velocity parameter.FALSE: End Velocity is specified normally.
    # Variable Name:   globalMovingAverageProfileTimeMilliseconds
    # Type:            double
    # Unit:            milliseconds
    # Minimum Value:   0
    # Maximum Value:   120000
    # Default Value:   0
    # Read the current values of parameters
    motionParam = Config_MotionParam()
    ret, motionParam = Wmx3Lib_cm.config.GetMotionParam(axis)
    motionParam.globalMovingAverageProfileTimeMilliseconds   = 0
    # motionParam -> First return value: Error code, Second return value: param error
    ret, motionParamError = Wmx3Lib_cm.config.SetMotionParam(axis, motionParam)
    if (ret != 0):
        print('Set globalMovingAverageProfileTimeMilliseconds  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # API Wait Until Motion Start      TRUE: Motion API functions will wait until the motion has started before returning execution to the calling thread.FALSE: Motion API functions will return immediately, before the motion is actually started by the engine.
    # Variable Name:   apiWaitUntilMotionStart
    # Type:            bool
    # Default Value:   TRUE
    # Read the current values of parameters
    motionParam = Config_MotionParam()
    ret, motionParam = Wmx3Lib_cm.config.GetMotionParam(axis)
    motionParam.apiWaitUntilMotionStart = True
    # motionParam -> First return value: Error code, Second return value: param error
    ret, motionParamError = Wmx3Lib_cm.config.SetMotionParam(axis, motionParam)
    if (ret != 0):
        print('Set apiWaitUntilMotionStart  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Linear Intpl Profile Calc Mode      This parameter will determine the method in which the profile parameters for the linear interpolation are calculated from the profile parameters specified for each interpolating axis.
    # Variable Name:   linearIntplProfileCalcMode
    # Type:            LinearIntplProfileCalcMode
    # Default Value:   AxisLimit
    # Read the current values of parameters
    motionParam = Config_MotionParam()
    ret, motionParam = Wmx3Lib_cm.config.GetMotionParam(axis)
    motionParam.linearIntplProfileCalcMode  = Config_LinearIntplProfileCalcMode.AxisLimit
    # motionParam -> First return value: Error code, Second return value: param error
    ret, motionParamError = Wmx3Lib_cm.config.SetMotionParam(axis, motionParam)
    if (ret != 0):
        print('Set linearIntplProfileCalcMode   error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return



#``



# Write Python code to set the Alarm parameters for Axis 0. Set‘Following Error Stopped’to 0,‘Following Error Moving’to 0, ‘Following Error Type ’to NoAction,‘Velocity Following Error Stopped’to 0, ‘Velocity Following Error Stopped Milliseconds ’to 0,‘Velocity Following Error Moving’to 0,‘Velocity Following Error Moving Milliseconds ’to 0,‘Velocity Following Error Type’to NoAction,‘Servo Off During Amp Alarm’to TRUE,‘Servo On Following Error’to 0.
    # Axes = [0]

    # Example of Axis 0 Homing Parameters
    axis = 0

    # Following Error Stopped    The maximum difference between the command position and feedback position that can be tolerated while the axis is in the Idle operation state before a following error alarm is triggered. A following error alarm will never be triggered while the axis is Idle if this value is set to 0.
    # Variable Name:   followingErrorStopped
    # Type:            double
    # Unit:            user unit
    # Minimum Value:   0
    # Maximum Value:   274877906943
    # Default Value:   0
    # Read the current values of parameters
    alarmParam = Config_AlarmParam()
    ret, alarmParam = Wmx3Lib_cm.config.GetAlarmParam(axis)
    alarmParam.followingErrorStopped = 0
    # motionParam -> First return value: Error code, Second return value: param error
    ret, motionParamError = Wmx3Lib_cm.config.SetAlarmParam(axis, alarmParam)
    if (ret != 0):
        print('Set followingErrorStopped  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Following Error Moving     The maximum difference between the command position and feedback position that can be tolerated while the axis is executing a motion command before a following error alarm is triggered. A following error alarm will never be triggered while the axis is executing a motion command if this value is set to 0.
    # Variable Name:   followingErrorMoving
    # Type:            double
    # Unit:            user unit
    # Minimum Value:   0
    # Maximum Value:   274877906943
    # Default Value:   0
    # Read the current values of parameters
    alarmParam = Config_AlarmParam()
    ret, alarmParam = Wmx3Lib_cm.config.GetAlarmParam(axis)
    alarmParam.followingErrorMoving = 0
    # motionParam -> First return value: Error code, Second return value: param error
    ret, motionParamError = Wmx3Lib_cm.config.SetAlarmParam(axis, alarmParam)
    if (ret != 0):
        print('Set followingErrorMoving  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Following Error Type     This parameter determines the action that is executed when the following error alarm is triggered. A following error alarm is triggered whenever the difference between the command position and feedback position of a Position mode axis exceeds the Following Error Stopped or Following Error Moving parameter, depending on whether the axis is currently executing a command or not.
    # Variable Name:   followingErrorType
    # Type:            FollowingErrorAlarmType
    # Default Value:   NoAction
    # Read the current values of parameters
    alarmParam = Config_AlarmParam()
    ret, alarmParam = Wmx3Lib_cm.config.GetAlarmParam(axis)
    alarmParam.followingErrorType  = Config_FollowingErrorAlarmType.NoAction
    # motionParam -> First return value: Error code, Second return value: param error
    ret, motionParamError = Wmx3Lib_cm.config.SetAlarmParam(axis, alarmParam)
    if (ret != 0):
        print('Set followingErrorType  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Velocity Following Error Stopped     The maximum difference between the command velocity and feedback velocity that can be tolerated while the axis is in the Idle operation state before a following error alarm is triggered. A following error alarm will never be triggered while the axis is Idle if this value is set to 0.
    # Variable Name:   velocityFollowingErrorStopped
    # Type:            double
    # Unit:            user unit/second
    # Minimum Value:   0
    # Maximum Value:   274877906943
    # Default Value:   0
    # Read the current values of parameters
    alarmParam = Config_AlarmParam()
    ret, alarmParam = Wmx3Lib_cm.config.GetAlarmParam(axis)
    alarmParam.velocityFollowingErrorStopped = 0
    # motionParam -> First return value: Error code, Second return value: param error
    ret, motionParamError = Wmx3Lib_cm.config.SetAlarmParam(axis, alarmParam)
    if (ret != 0):
        print('Set velocityFollowingErrorStopped  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Velocity Following Error Stopped Milliseconds      If set to a value above 0, a following error alarm will only be triggered if the difference between the command velocity and feedback velocity exceeds the amount in Velocity Following Error Stopped continuously for the amount of time specified in this parameter while the axis is in the Idle operation state.
    # Variable Name:   velocityFollowingErrorStoppedMilliseconds
    # Type:            double
    # Unit:            user unit
    # Minimum Value:   0
    # Maximum Value:   274877906943
    # Default Value:   0
    # Read the current values of parameters
    alarmParam = Config_AlarmParam()
    ret, alarmParam = Wmx3Lib_cm.config.GetAlarmParam(axis)
    alarmParam.velocityFollowingErrorStoppedMilliseconds  = 0
    # motionParam -> First return value: Error code, Second return value: param error
    ret, motionParamError = Wmx3Lib_cm.config.SetAlarmParam(axis, alarmParam)
    if (ret != 0):
        print('Set velocityFollowingErrorStoppedMilliseconds error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Velocity Following Error Moving      The maximum difference between the command velocity and feedback velocity that can be tolerated while the axis is executing a motion command before a following error alarm is triggered. A following error alarm will never be triggered while the axis is executing a motion command if this value is set to 0.
    # Variable Name:   velocityFollowingErrorMoving
    # Type:            double
    # Unit:            user unit/second
    # Minimum Value:   0
    # Maximum Value:   274877906943
    # Default Value:   0
    # Read the current values of parameters
    alarmParam = Config_AlarmParam()
    ret, alarmParam = Wmx3Lib_cm.config.GetAlarmParam(axis)
    alarmParam.velocityFollowingErrorMoving  = 0
    # motionParam -> First return value: Error code, Second return value: param error
    ret, motionParamError = Wmx3Lib_cm.config.SetAlarmParam(axis, alarmParam)
    if (ret != 0):
        print('Set velocityFollowingErrorMoving error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Velocity Following Error Moving Milliseconds       If set to a value above 0, a following error alarm will only be triggered if the difference between the command velocity and feedback velocity exceeds the amount in Velocity Following Error Moving continuously for the amount of time specified in this parameter while the axis is executing a motion command.
    # Variable Name:   velocityFollowingErrorMovingMilliseconds
    # Type:            double
    # Unit:            milliseconds
    # Minimum Value:   0
    # Maximum Value:   274877906943
    # Default Value:   0
    # Read the current values of parameters
    alarmParam = Config_AlarmParam()
    ret, alarmParam = Wmx3Lib_cm.config.GetAlarmParam(axis)
    alarmParam.velocityFollowingErrorMovingMilliseconds  = 0
    # motionParam -> First return value: Error code, Second return value: param error
    ret, motionParamError = Wmx3Lib_cm.config.SetAlarmParam(axis, alarmParam)
    if (ret != 0):
        print('Set velocityFollowingErrorMovingMilliseconds error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Velocity Following Error Type      This parameter determines the action that is executed when the following error alarm is triggered. A following error alarm is triggered whenever the difference between the command velocity and feedback velocity of a Velocity mode axis exceeds the Velocity Following Error Stopped or Velocity Following Error Moving parameter, depending on whether the axis is currently executing a command or not.
    # Variable Name:   velocityFollowingErrorType
    # Type:            VelocityFollowingErrorAlarmType
    # Default Value:   NoAction
    # Read the current values of parameters
    alarmParam = Config_AlarmParam()
    ret, alarmParam = Wmx3Lib_cm.config.GetAlarmParam(axis)
    alarmParam.velocityFollowingErrorType  = Config_VelocityFollowingErrorAlarmType.NoAction
    # motionParam -> First return value: Error code, Second return value: param error
    ret, motionParamError = Wmx3Lib_cm.config.SetAlarmParam(axis, alarmParam)
    if (ret != 0):
        print('Set velocityFollowingErrorType error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Servo Off During Amp Alarm     This parameter determines if a servo off signal should be sent to the servo when the servo reports an amplifier alarm. Many servos automatically turn off during amplifier alarms, even without receiving a servo off signal. Most users should keep this parameter at the default value.
    # Variable Name:   servoOffDuringAmpAlarm
    # Type:            bool
    # Default Value:   TRUE
    # Read the current values of parameters
    alarmParam = Config_AlarmParam()
    ret, alarmParam = Wmx3Lib_cm.config.GetAlarmParam(axis)
    alarmParam.servoOffDuringAmpAlarm  = True
    # motionParam -> First return value: Error code, Second return value: param error
    ret, motionParamError = Wmx3Lib_cm.config.SetAlarmParam(axis, alarmParam)
    if (ret != 0):
        print('Set servoOffDuringAmpAlarm error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Servo On Following Error       This parameter is a safety feature that prevents the servo from turning on if a servo on command is sent while the pulse unit difference in the command position and feedback position is greater than this value. If a servo on command is sent while the difference in the command position and feedback position is greater than this parameter, a following error alarm is triggered.
    # Variable Name:   servoOnFollowingError
    # Type:            int
    # Unit:            pulse
    # Minimum Value:   0
    # Maximum Value:   274877906943
    # Default Value:   10000
    # Read the current values of parameters
    alarmParam = Config_AlarmParam()
    ret, alarmParam = Wmx3Lib_cm.config.GetAlarmParam(axis)
    alarmParam.servoOnFollowingError  = 10000
    # motionParam -> First return value: Error code, Second return value: param error
    ret, motionParamError = Wmx3Lib_cm.config.SetAlarmParam(axis, alarmParam)
    if (ret != 0):
        print('Set servoOnFollowingError error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return



#``



# Write Python code to set the Sync parameters for Axis 0. Set‘In Sync Width’to 0,‘Sync Gain ’to 0,‘Sync Compensation Mode’to VelocityOffset,‘Master Desync Type’to NoAction,‘Master Desync Dec’to 10000,‘Slave Desync Type’to NoAction,‘Slave Desync Dec’to 10000,‘Match Pos’to FALSE.
    # Axes = [0]

    # Example of Axis 0 Homing Parameters
    axis = 0

    # In Sync Width    This parameter determines when sync compensation should be applied to a sync slave axis. When the feedback position difference between the master axis and the slave axis exceeds this value, sync compensation will be applied.
    # Variable Name:   inSyncWidth
    # Type:            int
    # Unit:            user unit
    # Minimum Value:   0
    # Maximum Value:   2147483647
    # Default Value:   0
    # Axis:            Slave/Master
    # Read the current values of parameters
    syncParam = Config_SyncParam()
    ret, syncParam = Wmx3Lib_cm.config.GetSyncParam(axis)
    syncParam.inSyncWidth = 0
    # syncParam -> First return value: Error code, Second return value: param error
    ret, syncParamError = Wmx3Lib_cm.config.SetSyncParam(axis, syncParam)
    if (ret != 0):
        print('Set inSyncWidth  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Sync Gain        This parameter determines the gain when sync compensation is applied. The feedback position difference between the master axis and slave axis will be multiplied by this value when applying sync compensation.
    # Variable Name:   syncGain
    # Type:            double
    # Unit:            none
    # Minimum Value:   0
    # Maximum Value:   3
    # Default Value:   0
    # Axis:            Slave/Master
    # Read the current values of parameters
    syncParam = Config_SyncParam()
    ret, syncParam = Wmx3Lib_cm.config.GetSyncParam(axis)
    syncParam.syncGain  = 0
    # syncParam -> First return value: Error code, Second return value: param error
    ret, syncParamError = Wmx3Lib_cm.config.SetSyncParam(axis, syncParam)
    if (ret != 0):
        print('Set syncGain error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Sync Compensation Mode      This parameter determines the mode at which additional compensation is applied to improve the synchronization between the master and slave axes. See SyncCompensationMode for additional information of each mode.
    # Variable Name:   syncCompensationMode
    # Type:            SyncCompensationMode
    # Default Value:   VelocityOffset
    # Axis:            Slave
    # Read the current values of parameters
    syncParam = Config_SyncParam()
    ret, syncParam = Wmx3Lib_cm.config.GetSyncParam(axis)
    syncParam.syncCompensationMode  = Config_SyncCompensationMode.VelocityOffset
    # syncParam -> First return value: Error code, Second return value: param error
    ret, syncParamError = Wmx3Lib_cm.config.SetSyncParam(axis, syncParam)
    if (ret != 0):
        print('Set syncCompensationMode error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Master Desync Type       The action executed by the master axis when it one of the slave axes loses synchronization. A sync slave axis can lose synchronization if it encounters an amp alarm, the servo turns off, etc. This action is not executed if synchronization is deliberately stopped with functions such as ResolveSync.
    # Variable Name:   masterDesyncType
    # Type:            MasterDesyncType
    # Default Value:   NoAction
    # Axis:            Master
    # Read the current values of parameters
    syncParam = Config_SyncParam()
    ret, syncParam = Wmx3Lib_cm.config.GetSyncParam(axis)
    syncParam.masterDesyncType  = Config_MasterDesyncType.NoAction
    # syncParam -> First return value: Error code, Second return value: param error
    ret, syncParamError = Wmx3Lib_cm.config.SetSyncParam(axis, syncParam)
    if (ret != 0):
        print('Set masterDesyncType error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Master Desync Dec        This parameter determines the gain when sync compensation is applied. The feedback position difference between the master axis and slave axis will be multiplied by this value when applying sync compensation.
    # Variable Name:   masterDesyncDec
    # Type:            double
    # Unit:            user unit / second^2
    # Minimum Value:   1e-6
    # Maximum Value:   274877906943
    # Default Value:   10000
    # Axis:            Master
    # Read the current values of parameters
    syncParam = Config_SyncParam()
    ret, syncParam = Wmx3Lib_cm.config.GetSyncParam(axis)
    syncParam.masterDesyncDec  = 10000
    # syncParam -> First return value: Error code, Second return value: param error
    ret, syncParamError = Wmx3Lib_cm.config.SetSyncParam(axis, syncParam)
    if (ret != 0):
        print('Set masterDesyncDec error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Slave Desync Type       The action executed by the slave axis when it loses synchronization with the master axis due to the master axis servo turning off.
    # Variable Name:   slaveDesyncType
    # Type:            SlaveDesyncType
    # Default Value:   NoAction
    # Axis:            Slave
    # Read the current values of parameters
    syncParam = Config_SyncParam()
    ret, syncParam = Wmx3Lib_cm.config.GetSyncParam(axis)
    syncParam.slaveDesyncType  = 0
    # syncParam -> First return value: Error code, Second return value: param error
    ret, syncParamError = Wmx3Lib_cm.config.SetSyncParam(axis, syncParam)
    if (ret != 0):
        print('Set slaveDesyncType error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Slave Desync Dec       This parameter is reserved, and has no effect.
    # Variable Name:   slaveDesyncDec
    # Type:            double
    # Unit:            user unit / second^2
    # Minimum Value:   1e-6
    # Maximum Value:   274877906943
    # Default Value:   10000
    # Axis:            Slave
    # Read the current values of parameters
    syncParam = Config_SyncParam()
    ret, syncParam = Wmx3Lib_cm.config.GetSyncParam(axis)
    syncParam.slaveDesyncDec  = 10000
    # syncParam -> First return value: Error code, Second return value: param error
    ret, syncParamError = Wmx3Lib_cm.config.SetSyncParam(axis, syncParam)
    if (ret != 0):
        print('Set slaveDesyncDec error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Match Pos        TRUE: Sync Pos Cmd and Sync Actual Pos will be used instead of Pos Cmd and Actual Pos for the following functions:SetLog SetFlightRecorderParam  SetEvent SetPSOConfig SetPlannedVelOverrideConfig SetSoftwareTouchProbe SetCommandPos SetFeedbackPos StartECAM (if this axis is a slave axis and also an ECAM master axis)
    # Variable Name:   matchPos
    # Type:            bool
    # Default Value:   FALSE
    # Axis:            Slave
    # Read the current values of parameters
    syncParam = Config_SyncParam()
    ret, syncParam = Wmx3Lib_cm.config.GetSyncParam(axis)
    syncParam.matchPos  = False
    # syncParam -> First return value: Error code, Second return value: param error
    ret, syncParamError = Wmx3Lib_cm.config.SetSyncParam(axis, syncParam)
    if (ret != 0):
        print('Set matchPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return



#``



# Write Python code to set the Flight Recorder parameters for Axis 0. Set‘Enable Flight Recorder’to TRUE,‘Flight Recorder Time Stamp’to FALSE,‘Collect Axis Flight Recorder Data’to TRUE,‘Trigger Flight Recorder On Amp Alarm’to TRUE.
    # Axes = [0]


    # Example of Axis 0
    axis = 0
    # Enable Flight Recorder    This parameter determines whether flight recorder data should be saved to disk when one of the conditions for triggering the flight recorder is satisfied. The flight recorder data contains the position command and position feedback data of the axes for the last 5000 cycles (5 seconds for a 1ms Cycle Time Milliseconds) from when the flight recorder is triggered. The flight recorder is stored in the path specified by the user with SetFlightRecorderPath, or "C:\" by default, and has the file name "wmx_flight_recorder_ipt0.txt".
    # Variable Name:   enableFlightRecorder
    # Type:            bool
    # Default Value:   TRUE
    # Target:          System
    # Read the current values of parameters
    flightRecorderParam = Config_FlightRecorderParam()
    ret, flightRecorderParam = Wmx3Lib_cm.config.GetFlightRecorderParam()
    flightRecorderParam.enableFlightRecorder = True
    # flightRecorderParam -> First return value: Error code, Second return value: param error
    ret, flightRecorderParamError = Wmx3Lib_cm.config.SetFlightRecorderParam(flightRecorderParam)
    if (ret != 0):
        print('Set flightRecorderParam  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Flight Recorder Time Stamp   This parameter determines whether the file name of the flight recorder data file should contain the date and time information of when the flight recorder was triggered. If this parameter is set to FALSE, the flight recorder data file will be overwritten each time the flight recorder is triggered (as the file name is the same). If this parameter is set to TRUE, the flight recorder data file name will become "[YYYY.MM.DD_HH.mm.SS]wmx_flight_recorder_ipt0.txt," where YY = year, MM = month, DD = day, HH = hour in 24-hour format, mm = minute, and SS = second.
    # Variable Name:   flightRecorderTimeStamp
    # Type:            bool
    # Default Value:   FALSE
    # Target:          System
    # Read the current values of parameters
    flightRecorderParam = Config_FlightRecorderParam()
    ret, flightRecorderParam = Wmx3Lib_cm.config.GetFlightRecorderParam()
    flightRecorderParam.flightRecorderTimeStamp = True
    # flightRecorderParam -> First return value: Error code, Second return value: param error
    ret, flightRecorderParamError = Wmx3Lib_cm.config.SetFlightRecorderParam(flightRecorderParam)
    if (ret != 0):
        print('Set flightRecorderTimeStamp  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Collect Axis Flight Recorder Data    This parameter determines whether the file name of the flight recorder data file should contain the date and time information of when the flight recorder was triggered. If this parameter is set to FALSE, the flight recorder data file will be overwritten each time the flight recorder is triggered (as the file name is the same). If this parameter is set to TRUE, the flight recorder data file name will become "[YYYY.MM.DD_HH.mm.SS]wmx_flight_recorder_ipt0.txt," where YY = year, MM = month, DD = day, HH = hour in 24-hour format, mm = minute, and SS = second.
    # Variable Name:   collectAxisFlightRecorderData
    # Type:            bool
    # Default Value:   TRUE
    # Target:          Axis
    # Read the current values of parameters
    flightRecorderParam = Config_FlightRecorderParam()
    ret, flightRecorderParam = Wmx3Lib_cm.config.GetFlightRecorderParam()
    flightRecorderParam.SetCollectAxisFlightRecorderData(axis,True)

    # flightRecorderParam -> First return value: Error code, Second return value: param error
    ret, flightRecorderParamError = Wmx3Lib_cm.config.SetFlightRecorderParam(flightRecorderParam)
    if (ret != 0):
        print('Set triggerFlightRecorderOnAmpAlarm   error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Trigger Flight Recorder On Amp Alarm   TRUE: The flight recorder will trigger when a servo amplifier alarm is detected in any axis (including axes that are not configured to collect flight recorder data).FALSE: The flight recorder will not be triggered by amp alarms.
    # Variable Name:   triggerFlightRecorderOnAmpAlarm
    # Type:            bool
    # Default Value:   TRUE
    # Target:          System
    # Read the current values of parameters
    flightRecorderParam = Config_FlightRecorderParam()
    ret, flightRecorderParam = Wmx3Lib_cm.config.GetFlightRecorderParam()
    flightRecorderParam.triggerFlightRecorderOnAmpAlarm = True
    # flightRecorderParam -> First return value: Error code, Second return value: param error
    ret, syncParamError = Wmx3Lib_cm.config.SetFlightRecorderParam(flightRecorderParam)
    if (ret != 0):
        print('Set triggerFlightRecorderOnAmpAlarm  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return



#``



# Write Python code to set the Emergency Stop parameters for Axis 0. Set‘E-Stop Dec’to 100000,‘Enable E-Stop Signal’to FALSE,‘E-Stop Signal Source’to Input,‘E-Stop Signal Level’to Level1,‘Invert E-Stop Signal Polarity’to FALSE,‘E-Stop Signal Byte Address’to 0,‘E-Stop Signal Bit Address’to 0,‘Enable E-Stop Status Signal’to FALSE,‘E-Stop Status Signal Destination’to FALSE,‘Invert E-Stop Status Signal Polarity’to FALSE,‘E-Stop Status Signal Byte Address’to 0,‘E-Stop Status Signal Bit Address’to 0,‘E-Stop Level 1 Type’to Dec.
    # Axes = [0]

    # Example of Axis 0
    axis = 0
    # E-Stop Dec       The deceleration to stop the axis at when the axis is stopped using E-Stop (emergency stop) with with an EStopLevel of Level1.
    # Variable Name:   eStopDec
    # Type:            double
    # Unit:            user unit / second^2
    # Minimum Value:   0
    # Maximum Value:   274877906943
    # Default Value:   100000
    # Read the current values of parameters
    emergencyStopParam = Config_EmergencyStopParam()
    ret, emergencyStopParam = Wmx3Lib_cm.config.GetEmergencyStopParam()
    emergencyStopParam.SetEStopDec(axis, 100000)
    # emergencyStopParam -> First return value: Error code, Second return value: param error
    ret, emergencyStopParamError = Wmx3Lib_cm.config.SetEmergencyStopParam( emergencyStopParam)
    if (ret != 0):
        print('Set emergencyStopParam  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Enable E-Stop Signal       Set to TRUE to assign an input, output, or user memory bit to trigger and release the E-Stop (emergency stop).When the assigned signal bit is set high, an emergency stop will be triggered, and when it is set low, the emergency stop will be released.An emergency stop can still be triggered by other methods (such as the ExecEStop function or the ExecEStop event) regardless of the value of this parameter.
    # Variable Name:   enableEStopSignal
    # Type:            bool
    # Default Value:   FALSE
    # Read the current values of parameters
    emergencyStopParam = Config_EmergencyStopParam()
    ret, emergencyStopParam = Wmx3Lib_cm.config.GetEmergencyStopParam()
    emergencyStopParam.enableEStopSignal =False
    # emergencyStopParam -> First return value: Error code, Second return value: param error
    ret, emergencyStopParamError = Wmx3Lib_cm.config.SetEmergencyStopParam(emergencyStopParam)
    if (ret != 0):
        print('Set enableEStopSignal error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # E-Stop Signal Source      The source (input, output, or user memory) of the emergency stop signal. This parameter has no effect if the Enable E-Stop Signal parameter is set to FALSE.If this parameter is set to Input, an I/O input bit will trigger the emergency stop.If this parameter is set to Output, an I/O output bit will trigger the emergency stop.
    # Variable Name:   eStopSignalSource
    # Type:            EStopSignalSource
    # Default Value:   Input
    # Read the current values of parameters
    emergencyStopParam = Config_EmergencyStopParam()
    ret, emergencyStopParam = Wmx3Lib_cm.config.GetEmergencyStopParam()
    emergencyStopParam.eStopSignalSource = Config_EStopSignalSource.Input
    # emergencyStopParam -> First return value: Error code, Second return value: param error
    ret, emergencyStopParamError = Wmx3Lib_cm.config.SetEmergencyStopParam(emergencyStopParam)
    if (ret != 0):
        print('Set eStopSignalSource error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # E-Stop Signal Level       The level of the emergency stop that is triggered by the emergency stop signal. This parameter has no effect if the Enable E-Stop Signal parameter is set to FALSE.
    # Variable Name:   eStopSignalLevel
    # Type:            EStopLevel
    # Default Value:   Level1
    # Read the current values of parameters
    emergencyStopParam = Config_EmergencyStopParam()
    ret, emergencyStopParam = Wmx3Lib_cm.config.GetEmergencyStopParam()
    emergencyStopParam.eStopSignalLevel = EStopLevel.Level1
    # emergencyStopParam -> First return value: Error code, Second return value: param error
    ret, emergencyStopParamError = Wmx3Lib_cm.config.SetEmergencyStopParam(emergencyStopParam)
    if (ret != 0):
        print('Set eStopSignalLevel error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Invert E-Stop Signal Polarity       If set to TRUE, the emergency stop signal polarity will be inverted so that the emergency stop is triggered when the signal is low and released when the signal is high. This parameter has no effect if the Enable E-Stop Signal parameter is set to FALSE.
    # Variable Name:   invertEStopSignalPolarity
    # Type:            bool
    # Default Value:   FALSE
    # Read the current values of parameters
    emergencyStopParam = Config_EmergencyStopParam()
    ret, emergencyStopParam = Wmx3Lib_cm.config.GetEmergencyStopParam()
    emergencyStopParam.invertEStopSignalPolarity  = False
    # emergencyStopParam -> First return value: Error code, Second return value: param error
    ret, emergencyStopParamError = Wmx3Lib_cm.config.SetEmergencyStopParam(emergencyStopParam)
    if (ret != 0):
        print('Set invertEStopSignalPolarity error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # E-Stop Signal Byte Address      The maximum value for this parameter depends on the value of the E-Stop Signal Source parameter, and is summarized in the following table:The byte address of the emergency stop signal. This parameter has no effect if the Enable E-Stop Signal parameter is set to FALSE.
    # Variable Name:   eStopSignalByteAddress
    # Type:            unsigned int
    # Minimum Value:   0
    # Maximum Value:   See Below
    # Default Value:   0
    # Read the current values of parameters
    emergencyStopParam = Config_EmergencyStopParam()
    ret, emergencyStopParam = Wmx3Lib_cm.config.GetEmergencyStopParam()
    emergencyStopParam.eStopSignalByteAddress  = 0
    # emergencyStopParam -> First return value: Error code, Second return value: param error
    ret, emergencyStopParamError = Wmx3Lib_cm.config.SetEmergencyStopParam(emergencyStopParam)
    if (ret != 0):
        print('Set invertEStopSignalPolarity error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # E-Stop Signal Bit Address      The bit address of the emergency stop signal. This parameter has no effect if the Enable E-Stop Signal parameter is set to FALSE.
    # Variable Name:   eStopSignalBitAddress
    # Type:            unsigned char
    # Minimum Value:   0
    # Maximum Value:   7
    # Default Value:   0
    # Read the current values of parameters
    emergencyStopParam = Config_EmergencyStopParam()
    ret, emergencyStopParam = Wmx3Lib_cm.config.GetEmergencyStopParam()
    emergencyStopParam.eStopSignalBitAddress   = 0
    # emergencyStopParam -> First return value: Error code, Second return value: param error
    ret, emergencyStopParamError = Wmx3Lib_cm.config.SetEmergencyStopParam(emergencyStopParam)
    if (ret != 0):
        print('Set eStopSignalBitAddress  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Enable E-Stop Status Signal       Set to TRUE to assign an output or user memory bit to show the triggered state of the E-Stop (emergency stop).The assigned signal bit will be set to high while the emergency stop has been triggered and low while the emergency stop is released. This signal bit will contain the same value as the Emergency Stop status.
    # Variable Name:   enableEStopStatusSignal
    # Type:            bool
    # Default Value:   FALSE
    # Read the current values of parameters
    emergencyStopParam = Config_EmergencyStopParam()
    ret, emergencyStopParam = Wmx3Lib_cm.config.GetEmergencyStopParam()
    emergencyStopParam.enableEStopStatusSignal   = False
    # emergencyStopParam -> First return value: Error code, Second return value: param error
    ret, emergencyStopParamError = Wmx3Lib_cm.config.SetEmergencyStopParam(emergencyStopParam)
    if (ret != 0):
        print('Set enableEStopStatusSignal  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # E-Stop Status Signal Destination       The bit address of the emergency stop signal. This parameter has no effect if the Enable E-Stop Signal parameter is set to FALSE.
    # Variable Name:   eStopStatusSignalDestination
    # Type:            bool
    # Default Value:   FALSE
    # Read the current values of parameters
    emergencyStopParam = Config_EmergencyStopParam()
    ret, emergencyStopParam = Wmx3Lib_cm.config.GetEmergencyStopParam()
    emergencyStopParam.eStopStatusSignalDestination = Config_EStopStatusSignalDestination.Output
    # emergencyStopParam -> First return value: Error code, Second return value: param error
    ret, emergencyStopParamError = Wmx3Lib_cm.config.SetEmergencyStopParam(emergencyStopParam)
    if (ret != 0):
        print('Set eStopStatusSignalDestination  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Invert E-Stop Status Signal Polarity     If set to TRUE, the emergency stop status signal polarity will be inverted so that the signal is low while the emergency stop is triggered and high while the emergency stop is released. This parameter has no effect if the Enable E-Stop Status Signal parameter is set to FALSE.
    # Variable Name:   invertEStopStatusSignalPolarity
    # Type:            bool
    # Default Value:   FALSE
    # Read the current values of parameters
    emergencyStopParam = Config_EmergencyStopParam()
    ret, emergencyStopParam = Wmx3Lib_cm.config.GetEmergencyStopParam()
    emergencyStopParam.invertEStopStatusSignalPolarity  = False
    # emergencyStopParam -> First return value: Error code, Second return value: param error
    ret, emergencyStopParamError = Wmx3Lib_cm.config.SetEmergencyStopParam(emergencyStopParam)
    if (ret != 0):
        print('Set invertEStopStatusSignalPolarity error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # E-Stop Status Signal Byte Address      The maximum value for this parameter depends on the value of the E-Stop Status Signal Destination parameter, and is summarized in the following table:The byte address of the emergency stop status signal. This parameter has no effect if the Enable E-Stop Status Signal parameter is set to FALSE.
    # Variable Name:   eStopStatusSignalByteAddress
    # Type:            unsigned int
    # Minimum Value:   0
    # Maximum Value:   See Below
    # Default Value:   0
    # Read the current values of parameters
    emergencyStopParam = Config_EmergencyStopParam()
    ret, emergencyStopParam = Wmx3Lib_cm.config.GetEmergencyStopParam()
    emergencyStopParam.eStopStatusSignalByteAddress  = 0
    # emergencyStopParam -> First return value: Error code, Second return value: param error
    ret, emergencyStopParamError = Wmx3Lib_cm.config.SetEmergencyStopParam(emergencyStopParam)
    if (ret != 0):
        print('Set eStopStatusSignalByteAddress error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # E-Stop Status Signal Bit Address      The bit address of the emergency stop status signal. This parameter has no effect if the Enable E-Stop Status Signal parameter is set to FALSE.
    # Variable Name:   eStopStatusSignalBitAddress
    # Type:            unsigned int
    # Minimum Value:   0
    # Maximum Value:   7
    # Default Value:   0
    # Read the current values of parameters
    emergencyStopParam = Config_EmergencyStopParam()
    ret, emergencyStopParam = Wmx3Lib_cm.config.GetEmergencyStopParam()
    emergencyStopParam.eStopStatusSignalBitAddress = 0
    # emergencyStopParam -> First return value: Error code, Second return value: param error
    ret, emergencyStopParamError = Wmx3Lib_cm.config.SetEmergencyStopParam(emergencyStopParam)
    if (ret != 0):
        print('Set eStopStatusSignalBitAddress  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # E-Stop Level 1 Type      The action to take when a Level1 E-Stop (emergency stop) is triggered. This parameter affects all Level1 emergency stops, whether it was triggered by the ExecEStop function, the ExecEStop event, or the emergency stop signal set with Enable E-Stop Signal.
    # Variable Name:   eStopLevel1Type
    # Type:            EStopLevel1Type
    # Default Value:   Dec
    # Read the current values of parameters
    emergencyStopParam = Config_EmergencyStopParam()
    ret, emergencyStopParam = Wmx3Lib_cm.config.GetEmergencyStopParam()
    emergencyStopParam.eStopLevel1Type  = Config_EStopLevel1Type.Dec
    # emergencyStopParam -> First return value: Error code, Second return value: param error
    ret, emergencyStopParamError = Wmx3Lib_cm.config.SetEmergencyStopParam(emergencyStopParam)
    if (ret != 0):
        print('Set eStopLevel1Type  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return



#``



# Write Python code to set the Axis parameters for Axis 0. Set‘Axis Command Mode’to Position,‘Gear Ratio Numerator’to 1,‘Gear Ratio Denominator’to 1,‘Single Turn Mode ’to FALSE,‘Single Turn Encoder Count’to 65536,‘Max Trq Limit’to 300,‘Negative Trq Limit ’to 300,‘Positive Trq Limit’to 300,‘Axis Unit’to 0,‘Axis Polarity’to 1,‘Max Motor Speed’to 3000,‘Absolute Encoder Mode’to FALSE,‘Absolute Encoder Home Offset’to 0,‘Encoder Range Mode’to FALSE,‘Encoder Range Low’to 0,‘Encoder Range High’to 0.
    # Axes = [0]

    # Example of Axis 0
    axis = 0
    # Axis Command Mode    The command mode of the axis. The available options are position (CSP), velocity (CSV), and torque (CST). The command mode determines whether the axis receives a position command, a velocity command, or a torque command every cycle.
    # Variable Name:   axisCommandMode
    # Type:            AxisCommandMode
    # Default Value:   Position
    # Set Function:    SetAxisCommandMode
    # Read the current values of parameters
    axisParam = Config_AxisParam()
    ret, axisParam = Wmx3Lib_cm.config.GetAxisParam()
    axisParam.SetAxisCommandMode(axis, AxisCommandMode.Position)
    # axisParam -> First return value: Error code, Second return value: param error
    ret, axisParamError = Wmx3Lib_cm.config.SetAxisParam(axisParam)
    if (ret != 0):
        print('Set axisParam  error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Gear Ratio Numerator     The minimum and maximum values of this parameter depends on the value of the Gear Ratio Denominator parameter. The ratio Gear Ratio Numerator / Gear Ratio Denominator must be equal to or greater than 0.000001 and equal to or less than 2147483647.
    # Variable Name:   gearRatioNumerator
    # Type:            double
    # Unit:            none
    # Minimum Value:   See Below
    # Maximum Value:   See Below
    # Default Value:   1
    # Set Function:    SetGearRatio
    # Read the current values of parameters
    axisParam = Config_AxisParam()
    ret, axisParam = Wmx3Lib_cm.config.GetAxisParam()
    axisParam.SetGearRatioNumerator(axis,1)
    # axisParam -> First return value: Error code, Second return value: param error
    ret, axisParamError = Wmx3Lib_cm.config.SetAxisParam(axisParam)
    if (ret != 0):
        print('Set gearRatioNumerator error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Gear Ratio Denominator     The minimum and maximum values of this parameter depends on the value of the Gear Ratio Numerator parameter. The ratio Gear Ratio Numerator / Gear Ratio Denominator must be equal to or greater than 0.000001 and equal to or less than 2147483647.
    # Variable Name:   gearRatioDenominator
    # Type:            double
    # Unit:            none
    # Minimum Value:   See Below
    # Maximum Value:   See Below
    # Default Value:   1
    # Set Function:    SetGearRatio
    # Read the current values of parameters
    axisParam = Config_AxisParam()
    ret, axisParam = Wmx3Lib_cm.config.GetAxisParam()
    axisParam.SetGearRatioDenominator(axis,1)
    # axisParam -> First return value: Error code, Second return value: param error
    ret, axisParamError = Wmx3Lib_cm.config.SetAxisParam(axisParam)
    if (ret != 0):
        print('Set gearRatioDenominator error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Single Turn Mode      If this parameter is set to TRUE, this axis will be a single turn axis. A single turn axis only retains position information within a certain range, and if the axis moves out of this range, the position wraps around to the other end of the range. If this parameter is set to FALSE, the axis will be a normal axis.
    # Variable Name:   singleTurnMode
    # Type:            bool
    # Default Value:   FALSE
    # Set Function:    SetSingleTurn
    # Read the current values of parameters
    axisParam = Config_AxisParam()
    ret, axisParam = Wmx3Lib_cm.config.GetAxisParam()
    axisParam.SetSingleTurnMode(axis,False)
    # axisParam -> First return value: Error code, Second return value: param error
    ret, axisParamError = Wmx3Lib_cm.config.SetAxisParam(axisParam)
    if (ret != 0):
        print('Set gearRatioDenominator error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Single Turn Encoder Count     This parameter determines the wrap around range for axes with Single Turn Mode enabled. If the axis would move out of the range between 0 and this value, the axis position wraps around to the other end of this range.
    # Variable Name:   singleTurnEncoderCount
    # Type:            unsigned int
    # Unit:            pulse
    # Minimum Value:   256
    # Maximum Value:   2147483648
    # Default Value:   65536
    # Set Function:    SetSingleTurn
    # Read the current values of parameters
    axisParam = Config_AxisParam()
    ret, axisParam = Wmx3Lib_cm.config.GetAxisParam()
    axisParam.SetSingleTurnEncoderCount(axis,65536)
    # axisParam -> First return value: Error code, Second return value: param error
    ret, axisParamError = Wmx3Lib_cm.config.SetAxisParam(axisParam)
    if (ret != 0):
        print('Set singleTurnEncoderCount error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Max Trq Limit    The maximum torque that will be applied by the servo motor in either direction.This parameter requires the axis servo to support and be configured to receive the maximum torque limit input. Whether the axis is configured to receive maximum torque limit inputs can be checked from the Max Trq Limit Support status.
    # Variable Name:   maxTrqLimit
    # Type:            double
    # Unit:            %
    # Minimum Value:   0
    # Maximum Value:   274877906943
    # Default Value:   300
    # Set Function:    SetMaxTrqLimit
    # Read the current values of parameters
    axisParam = Config_AxisParam()
    ret, axisParam = Wmx3Lib_cm.config.GetAxisParam()
    axisParam.SetMaxTrqLimit(axis,300)
    # axisParam -> First return value: Error code, Second return value: param error
    ret, axisParamError = Wmx3Lib_cm.config.SetAxisParam(axisParam)
    if (ret != 0):
        print('Set maxTrqLimit error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Negative Trq Limit    The maximum torque that will be applied by the servo motor in the negative direction.This parameter requires the axis servo to support and be configured to receive the negative torque limit input. Whether the axis is configured to receive negative torque limit inputs can be checked from the Negative Trq Limit Support status.
    # Variable Name:   negativeTrqLimit
    # Type:            double
    # Unit:            %
    # Minimum Value:   0
    # Maximum Value:   274877906943
    # Default Value:   300
    # Set Function:    SetNegativeTrqLimit
    # Read the current values of parameters
    axisParam = Config_AxisParam()
    ret, axisParam = Wmx3Lib_cm.config.GetAxisParam()
    axisParam.SetNegativeTrqLimit(axis,300)
    # axisParam -> First return value: Error code, Second return value: param error
    ret, axisParamError = Wmx3Lib_cm.config.SetAxisParam(axisParam)
    if (ret != 0):
        print('Set negativeTrqLimit error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Positive Trq Limit    The maximum torque that will be applied by the servo motor in the positive  direction.This parameter requires the axis servo to support and be configured to receive the negative torque limit input. Whether the axis is configured to receive negative torque limit inputs can be checked from the Positive Trq Limit Support status.
    # Variable Name:   positiveTrqLimit
    # Type:            double
    # Unit:            %
    # Minimum Value:   0
    # Maximum Value:   274877906943
    # Default Value:   300
    # Set Function:    SetPositiveTrqLimit
    # Read the current values of parameters
    axisParam = Config_AxisParam()
    ret, axisParam = Wmx3Lib_cm.config.GetAxisParam()
    axisParam.SetPositiveTrqLimit(axis,300)
    # axisParam -> First return value: Error code, Second return value: param error
    ret, axisParamError = Wmx3Lib_cm.config.SetAxisParam(axisParam)
    if (ret != 0):
        print('Set positiveTrqLimit error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Axis Unit        The minimum unit of the command position, feedback position, command velocity, and feedback velocity. The Pos Cmd, Actual Pos, Velocity Cmd, and Actual Velocity statuses will be rounded to the nearest multiple of this value in the direction of zero.
    # Variable Name:   axisUnit
    # Type:            double
    # Unit:            user unit
    # Minimum Value:   0
    # Maximum Value:   none
    # Default Value:   0
    # Set Function:    SetAxisUnit
    # Read the current values of parameters
    axisParam = Config_AxisParam()
    ret, axisParam = Wmx3Lib_cm.config.GetAxisParam()
    axisParam.SetAxisUnit (axis,0)
    # axisParam -> First return value: Error code, Second return value: param error
    ret, axisParamError = Wmx3Lib_cm.config.SetAxisParam(axisParam)
    if (ret != 0):
        print('Set axisUnit error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Axis Polarity    If set to 1, the polarity of the axis will be normal. If set to -1, the polarity of the axis will be reversed, and motion in the positive direction will result in position commands in the negative direction to be sent to the axis servo.
    # Variable Name:   axisPolarity
    # Type:            char
    # Allowed Values:  1 (Normal), -1 (Reverse)
    # Default Value:   1
    # Set Function:    SetAxisPolarity
    # Read the current values of parameters
    axisParam = Config_AxisParam()
    ret, axisParam = Wmx3Lib_cm.config.GetAxisParam()
    axisParam.SetAxisPolarity(axis,1)
    # axisParam -> First return value: Error code, Second return value: param error
    ret, axisParamError = Wmx3Lib_cm.config.SetAxisParam(axisParam)
    if (ret != 0):
        print('Set axisPolarity error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Max Motor Speed  This parameter sets the maximum motor speed of an axis. The speed of the axis in either direction during all motions will be limited to this value.This parameter requires the axis servo to support and be configured to receive maximum motor speed inputs. Whether the axis is configured to receive maximum motor speed inputs can be checked from the Max Motor Speed Support status.
    # Variable Name:   maxMotorSpeed
    # Type:            double
    # Unit:            rpm
    # Minimum Value:   0
    # Maximum Value:   274877906943
    # Default Value:   3000
    # Set Function:    SetMaxMotorSpeed
    # Read the current values of parameters
    axisParam = Config_AxisParam()
    ret, axisParam = Wmx3Lib_cm.config.GetAxisParam()
    axisParam.SetAxisPolarity(axis,1)
    # axisParam -> First return value: Error code, Second return value: param error
    ret, axisParamError = Wmx3Lib_cm.config.SetAxisParam(axisParam)
    if (ret != 0):
        print('Set axisPolarity error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Absolute Encoder Mode   This parameter sets the absolute encoder mode of an axis. If this parameter is set to enabled, the home offset specified by the Absolute Encoder Home Offset parameter will be applied. The Absolute Encoder Home Offset parameter will also be updated when the axis completes a homing function.
    # Variable Name:   absoluteEncoderMode
    # Type:            bool
    # Default Value:   FALSE
    # Set Function:    SetAbsoluteEncoderMode
    # Read the current values of parameters
    axisParam = Config_AxisParam()
    ret, axisParam = Wmx3Lib_cm.config.GetAxisParam()
    axisParam.SetAbsoluteEncoderMode (axis,False)
    # axisParam -> First return value: Error code, Second return value: param error
    ret, axisParamError = Wmx3Lib_cm.config.SetAxisParam(axisParam)
    if (ret != 0):
        print('Set absoluteEncoderMode error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Absolute Encoder Home Offset   This parameter stores the absolute encoder home offset (the offset used to determine the home position). This parameter has no effect while the Absolute Encoder Mode parameter is set to FALSE.If the Absolute Encoder Mode parameter is set to TRUE, this value will set the home offset of the axis.
    # Variable Name:   absoluteEncoderHomeOffset
    # Type:            double
    # Unit:            pulse
    # Minimum Value:   0
    # Maximum Value:   274877906943
    # Default Value:   0
    # Set Function:    SetAbsoluteEncoderHomeOffset
    # Read the current values of parameters
    axisParam = Config_AxisParam()
    ret, axisParam = Wmx3Lib_cm.config.GetAxisParam()
    axisParam.SetAbsoluteEncoderHomeOffset(axis,0)
    # axisParam -> First return value: Error code, Second return value: param error
    ret, axisParamError = Wmx3Lib_cm.config.SetAxisParam(axisParam)
    if (ret != 0):
        print('Set SetAbsoluteEncoderHomeOffset error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Encoder Range Mode   This parameter sets the encoder range mode.
    # Variable Name:   encoderRangeMode
    # Type:            bool
    # Default Value:   FALSE
    # Set Function:    SetEncoderRange
    # Read the current values of parameters
    axisParam = Config_AxisParam()
    ret, axisParam = Wmx3Lib_cm.config.GetAxisParam()
    axisParam.SetEncoderRangeMode(axis,False)
    # axisParam -> First return value: Error code, Second return value: param error
    ret, axisParamError = Wmx3Lib_cm.config.SetAxisParam(axisParam)
    if (ret != 0):
        print('Set encoderRangeMode error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Encoder Range Low   If the Encoder Range Mode parameter is set to TRUE, this parameter will specify the low end of the encoder range.This parameter can be set to a value between 0 and -(2^31).
    # Variable Name:   encoderRangeLow
    # Type:            int
    # Unit:            pulse
    # Minimum Value:   -2147483648
    # Maximum Value:   0
    # Default Value:   0
    # Set Function:    SetEncoderRange
    # Read the current values of parameters
    axisParam = Config_AxisParam()
    ret, axisParam = Wmx3Lib_cm.config.GetAxisParam()
    axisParam.SetEncoderRangeLow(axis,0)
    # axisParam -> First return value: Error code, Second return value: param error
    ret, axisParamError = Wmx3Lib_cm.config.SetAxisParam(axisParam)
    if (ret != 0):
        print('Set encoderRangeLow error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Encoder Range High   If the Encoder Range Mode parameter is set to TRUE, this parameter will specify the high end of the encoder range.This parameter can be set to a value between 0 and 2^31 - 1.
    # Variable Name:   encoderRangeHigh
    # Type:            int
    # Unit:            pulse
    # Minimum Value:   0
    # Maximum Value:   2147483647
    # Default Value:   0
    # Set Function:    SetEncoderRange
    # Read the current values of parameters
    axisParam = Config_AxisParam()
    ret, axisParam = Wmx3Lib_cm.config.GetAxisParam()
    axisParam.SetEncoderRangeHigh(axis,0)
    # axisParam -> First return value: Error code, Second return value: param error
    ret, axisParamError = Wmx3Lib_cm.config.SetAxisParam(axisParam)
    if (ret != 0):
        print('Set SetEncoderRange error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return



#``



# Write Python code to get the System status for the entire system. Get the system status of 'Invalid License Error', 'Engine State', 'Number of Interrupts', 'Emergency Stop', 'Emergency Stop Level' for the entire system. Get the system status of 'Cycle Time Milliseconds' and 'Cycle Counter' for Master 0.
    # Axes = [0]

    # Invalid License Error     TRUE: The detected license is invalid. Communication cannot be started with an invalid license.
    # Variable Name:   invalidLicenseError
    # Type:            bool
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Invalid License Error : ' + str(CmStatus.invalidLicenseError))

    # Engine State      Status of the engine.
    # Variable Name:   engineState
    # Type:            EngineState::T
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Engine State : ' + str(CmStatus.engineState))

    # Number of Interrupts      The number of interrupts (cyclic handlers) that are currently running on the engine.
    # Variable Name:   numOfInterrupts
    # Type:            int
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Number of Interrupts : ' + str(CmStatus.numOfInterrupts))

    # Example of Master 0 Cycle Time Milliseconds
    master = 0
    # Cycle Time Milliseconds       The time between each communication cycle. The first index of the array corresponds to the first interrupt (cyclic handler), and the second index corresponds to the second interrupt. If only one interrupt is running on the engine, the second index will contain 0.
    # Variable Name:   cycleTimeMilliseconds
    # Type:            double
    # Unit:            milliseconds
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Cycle Time Milliseconds : ' + str(CmStatus.GetCycleTimeMilliseconds(master)))

    # Example of Master 0 Cycle Counter
    master = 0
    # Cycle Counter     A 64-bit integer containing the number of communication cycles that have elapsed since communication was last started. The first index of the array corresponds to the first interrupt (cyclic handler), and the second index corresponds to the second interrupt.
    # Variable Name:   cycleCounter
    # Type:            long long
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Cycle Counter : ' + str(CmStatus.GetCycleCounter(master)))

    # Emergency Stop        TRUE: The system is in emergency stop state. FALSE: The system is not in emergency stop state.
    # Variable Name:   emergencyStop
    # Type:            bool
    # Update Timing:   Acyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Emergency Stop : ' + str(CmStatus.emergencyStop))

    # Emergency Stop Level      The emergency stop level of the system, if Emergency Stop is TRUE.
    # Variable Name:   emergencyStopLevel
    # Type:            EStopLevel::T
    # Update Timing:   Acyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Emergency Stop Level : ' + str(CmStatus.emergencyStopLevel))



#``



# Write Python code to get the Axis status for Axis 0. Get the axis status of 'Servo On', 'Servo Offline', 'Amp Alarm', 'Amp Alarm Code', 'Master Axis', 'Second Master Axis', 'Pos Cmd', 'Actual Pos', 'Comp Pos Cmd', 'Comp Actual Pos', 'Sync Pos Cmd', 'Sync Actual Pos', 'Encoder Command', 'Encoder Feedback', 'Accumulated Encoder Feedback', 'Velocity Cmd', 'Actual Velocity', 'Velocity Lag', 'Torque Cmd', 'Actual Torque', 'Actual Following Error', 'Compensation / Pitch Error Compensation', 'Compensation / Pitch Error Compensation 2D', 'Compensation / Backlash Compensation', 'Compensation / Total Pos Compensation', 'Axis Supported Function / Pos Feedback Support', 'Axis Supported Function / Pos Command Support', 'Axis Supported Function / Velocity Feedback Support', 'Axis Supported Function / Velocity Command Support', 'Axis Supported Function / Velocity Offset Support', 'Axis Supported Function / Trq Feedback Support', 'Axis Supported Function / Trq Command Support', 'Axis Supported Function / Max Trq Limit Support', 'Axis Supported Function / Positive Trq Limit Support', 'Axis Supported Function / Negative Trq Limit Support', 'Axis Supported Function / Max Motor Speed Support', 'Op State', 'Detail Op State', 'Axis Command Mode', 'Axis Command Mode Feedback', 'Axis Sync Mode', 'Sync Offset', 'Sync Phase Offset', 'Sync Gear Ratio', 'Profile Total Milliseconds', 'Profile Acc Milliseconds', 'Profile Cruise Milliseconds', 'Profile Dec Milliseconds', 'Profile Remaining Milliseconds', 'Profile Completed Milliseconds', 'Profile Target Pos', 'Profile Total Distance', 'Profile Remaining Distance', 'Profile Completed Distance', 'Intpl Velocity', 'Intpl Segment', 'Following Error Alarm', 'Command Ready', 'Waiting for Trigger', 'Motion Paused', 'Motion Complete', 'Exec Superimposed Motion', 'Cmd Acc', 'Acc Flag', 'Dec Flag', 'In Pos', 'In Pos 2', 'In Pos 3', 'In Pos 4', 'In Pos 5', 'Cmd Distribution End', 'Pos Set', 'Delayed Pos Set', 'Cmd Distribution End Delayed Pos Set Diff', 'Positive LS', 'Negative LS', 'Near Positive LS', 'Near Negative LS', 'External Positive LS', 'External Negative LS', 'Positive Soft Limit', 'Negative Soft Limit', 'Home State', 'Home Error', 'Home Offset', 'Home Switch', 'Home Done', 'Home Paused', 'Cmd Pos To Fb Pos Flag', 'Single Turn Counter', 'User Offset', 'User Offset Pos Cmd', 'User Offset Actual Pos', 'User Velocity Offset', 'User Torque Offset', 'Vibration Pos Min', 'Vibration Pos Max', 'Vibration Pos Average', 'Vibration Vel Min', 'Vibration Vel Max', 'Vibration Vel Average', 'Vibration Trq Min', 'Vibration Trq Max', 'Vibration Trq Average' for Axis 0.

    # Axes = [0]


    # Example of Axis 0 Status
    axis = 0
    # Servo On      TRUE: The axis servo is on. FALSE: The axis servo is off.
    # Variable Name:   servoOn
    # Type:            bool
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Servo On : ' + str(CmStatus.GetAxesStatus(axis).servoOn))

    # Servo Offline     TRUE: The axis is offline. The axis servo could not be found in the network, or the axis is not in operational state. FALSE: The axis is online.
    # Variable Name:   servoOffline
    # Type:            bool
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Servo Offline : ' + str(CmStatus.GetAxesStatus(axis).servoOffline))

    # Amp Alarm     TRUE: The axis encountered an amp alarm. FALSE: The axis has no amp alarm.
    # Variable Name:   ampAlarm
    # Type:            bool
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Amp Alarm : ' + str(CmStatus.GetAxesStatus(axis).ampAlarm))

    # Amp Alarm Code        The amp alarm code, if the axis has an amp alarm (if Amp Alarm is TRUE).
    # Variable Name:   ampAlarmCode
    # Type:            int
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Amp Alarm Code : ' + str(CmStatus.GetAxesStatus(axis).ampAlarmCode))

    # Master Axis       If this axis is a synchronous control slave axis, this status contains the master axis. Otherwise, this status contains -1.
    # Variable Name:   masterAxis
    # Type:            int
    # Update Timing:   Acyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Master Axis : ' + str(CmStatus.GetAxesStatus(axis).masterAxis))

    # Second Master Axis        If this axis is a combine sync control slave axis, this status contains the second master axis. Otherwise, this status contains -1.
    # Variable Name:   secondMasterAxis
    # Type:            int
    # Update Timing:   Acyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Second Master Axis : ' + str(CmStatus.GetAxesStatus(axis).secondMasterAxis))

    # Pos Cmd       The command position of the axis. For axes in Position Axis Command Mode, the command position is set cyclically by motion commands the axis is executing. For axes in Velocity or Torque Axis Command Mode, the command position is set equal to Actual Pos every cycle (this prevents the axis from moving suddenly when its mode is changed to Position).
    # Variable Name:   posCmd
    # Type:            double
    # Unit:            user unit
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Pos Cmd : ' + str(CmStatus.GetAxesStatus(axis).posCmd))

    # Actual Pos        The feedback position of the axis. For this status to return a value, the servo must be configured to return position feedback data. Whether the servo is correctly configured to return position feedback data can be checked with the Pos Feedback Support status.
    # Variable Name:   actualPos
    # Type:            double
    # Unit:            user unit
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Actual Pos : ' + str(CmStatus.GetAxesStatus(axis).actualPos))

    # Comp Pos Cmd      The command position of the axis after applying compensation offsets.
    # Variable Name:   compPosCmd
    # Type:            double
    # Unit:            user unit
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Comp Pos Cmd : ' + str(CmStatus.GetAxesStatus(axis).compPosCmd))

    # Comp Actual Pos       The feedback position of the axis after applying compensation offsets.
    # Variable Name:   compActualPos
    # Type:            double
    # Unit:            user unit
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Comp Actual Pos : ' + str(CmStatus.GetAxesStatus(axis).compActualPos))

    # Sync Pos Cmd      If this axis is a synchronous control slave axis, this status contains the command position after sync offsets are applied. This will shift the slave command position to have the same coordinates as the master axis. This value will normally contain the same value as the master axis command position. If this axis is not a synchronous control slave axis, this status contains the same value as the command position.
    # Variable Name:   syncPosCmd
    # Type:            double
    # Unit:            user unit
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Sync Pos Cmd : ' + str(CmStatus.GetAxesStatus(axis).syncPosCmd))

    # Sync Actual Pos       If this axis is a synchronous control slave axis, this status contains the feedback position after sync offsets are applied. This will shift the slave feedback position to have the same coordinates as the master axis. If synchronization is perfect, this value will contain the same value as the master axis feedback position. If this axis is not a synchronous control slave axis, this status contains the same value as the feedback position.
    # Variable Name:   syncActualPos
    # Type:            double
    # Unit:            user unit
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Sync Actual Pos : ' + str(CmStatus.GetAxesStatus(axis).syncActualPos))

    # Encoder Command       The 32-bit integer command position that is sent to the servo. This command position is the final position command that is sent to the servo, after modifying the command position by the compensation, home offsets, and sync offsets.
    # Variable Name:   encoderCommand
    # Type:            int
    # Unit:            pulse
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Encoder Command : ' + str(CmStatus.GetAxesStatus(axis).encoderCommand))

    # Encoder Feedback      The 32-bit integer feedback position that is received from the servo. This feedback position is the actual position of the servo, without accounting for compensation, home offests, and sync offsets.
    # Variable Name:   encoderFeedback
    # Type:            int
    # Unit:            pulse
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Encoder Feedback : ' + str(CmStatus.GetAxesStatus(axis).encoderFeedback))

    # Accumulated Encoder Feedback      A 64-bit signed integer that contains the accumulated value of the encoder feedback since starting the engine. The difference in the value of the 32-bit Encoder Feedback is calculated every cycle and added to this accumulated sum. Once the accumulated feedback reaches 2^63 - 1 or -(2^63), it will stop increasing beyond that position. This represents the upper and lower limits of the feedback position that can be calculated for a linear axis (for Single Turn axes, this value will loop back at Single Turn Encoder Count intervals, so there is no limit).
    # Variable Name:   accumulatedEncoderFeedback
    # Type:            long long
    # Unit:            pulse
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Accumulated Encoder Feedback : ' + str(CmStatus.GetAxesStatus(axis).accumulatedEncoderFeedback))

    # Velocity Cmd      The command velocity of the axis. For axes in Velocity mode, the command velocity is set cyclically by velocity commands the axis is executing. For axes in Position mode, this status returns the instantaneous velocity calculated from the position commands of this cycle and the previous cycle.
    # Variable Name:   velocityCmd
    # Type:            double
    # Unit:            user unit / second
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Velocity Cmd : ' + str(CmStatus.GetAxesStatus(axis).velocityCmd))

    # Actual Velocity       The feedback velocity of the axis. If the servo is not configured to return velocity feedback data (if the Velocity Feedback Support status is FALSE), or if the Velocity Monitor Source parameter is set to CalculateFromPositionFeedback, this status will contain a velocity calculated from the feedback position over several cycles. Otherwise, this status will contain the feedback velocity from the servo drive.
    # Variable Name:   actualVelocity
    # Type:            double
    # Unit:            user unit / second
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Actual Velocity : ' + str(CmStatus.GetAxesStatus(axis).actualVelocity))

    # Velocity Lag      The difference between the command velocity and the feedback velocity. If the servo is not configured to return velocity feedback data (if the Velocity Feedback Support status is FALSE), or if the Velocity Monitor Source parameter is set to CalculateFromPositionFeedback, a velocity calculated from the feedback position is used in place of the feedback velocity from the servo drive to calculate the velocity lag.
    # Variable Name:   velocityLag
    # Type:            double
    # Unit:            user unit / second
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Velocity Lag : ' + str(CmStatus.GetAxesStatus(axis).velocityLag))

    # Torque Cmd        The command torque of the axis. For axes in Torque mode, the command torque is set cyclically by torque commands the axis is executing.
    # Variable Name:   torqueCmd
    # Type:            double
    # Unit:            %
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Torque Cmd : ' + str(CmStatus.GetAxesStatus(axis).torqueCmd))

    # Actual Torque     The feedback torque of the axis. For this status to return a value, the servo must be configured to return torque feedback data. Whether the servo is correctly configured to return torque feedback data can be checked with the Trq Feedback Support status.
    # Variable Name:   actualTorque
    # Type:            double
    # Unit:            %
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Actual Torque : ' + str(CmStatus.GetAxesStatus(axis).actualTorque))

    # Actual Following Error        Feedback following error in pulses. For this status to return a value, the servo must be configured to return following error data.
    # Variable Name:   actualFollowingError
    # Type:            double
    # Unit:            pulse
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Actual Following Error : ' + str(CmStatus.GetAxesStatus(axis).actualFollowingError))

    # Compensation / Pitch Error Compensation       The compensation offset currently applied by the pitch error compensation function.
    # Variable Name:   pitchErrorCompensation
    # Type:            double
    # Unit:            user unit
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Compensation / Pitch Error Compensation : ' + str(CmStatus.GetAxesStatus(axis).compensation.pitchErrorCompensation))

    # Compensation / Pitch Error Compensation 2D        The compensation offset currently applied by the two-dimensional pitch error compensation function.
    # Variable Name:   pitchErrorCompensation2D
    # Type:            double
    # Unit:            user unit
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Compensation / Pitch Error Compensation 2D : ' + str(CmStatus.GetAxesStatus(axis).compensation.pitchErrorCompensation2D))

    # Compensation / Backlash Compensation      The compensation offset currently applied by the backlash compensation function.
    # Variable Name:   backlashCompensation
    # Type:            double
    # Unit:            user unit
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    tempCompensation = CmStatus.GetAxesStatus(axis).compensation
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Compensation / Backlash Compensation : ' + str(CmStatus.GetAxesStatus(axis).compensation.backlashCompensation))

    # Compensation / Total Pos Compensation     The total position compensation offset applied by all compensation functions.
    # Variable Name:   totalPosCompensation
    # Type:            double
    # Unit:            user unit
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Compensation / Total Pos Compensation : ' + str(CmStatus.GetAxesStatus(axis).compensation.totalPosCompensation))

    # Axis Supported Function / Pos Feedback Support        TRUE: The axis returns position feedback data every cycle. The position feedback data is stored in the Actual Pos status. FALSE: The axis does not return position feedback data every cycle.
    # Variable Name:   posFeedbackSupport
    # Type:            bool
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Axis Supported Function / Pos Feedback Support : ' + str(CmStatus.GetAxesStatus(axis).axisSupportedFunction.posFeedbackSupport))

    # Axis Supported Function / Pos Command Support     TRUE: The axis supports receiving position command data every cycle. The Axis Command Mode must be set to Position to execute position command data. FALSE: The axis does not support receiving position command data every cycle.
    # Variable Name:   posCommandSupport
    # Type:            bool
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Axis Supported Function / Pos Command Support : ' + str(CmStatus.GetAxesStatus(axis).axisSupportedFunction.posCommandSupport))

    # Axis Supported Function / Velocity Feedback Support       TRUE: The axis returns velocity feedback data every cycle. The velocity feedback data is stored in the Actual Velocity status. FALSE: The axis does not return velocity feedback data every cycle.
    # Variable Name:   velocityFeedbackSupport
    # Type:            bool
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Axis Supported Function / Velocity Feedback Support : ' + str(CmStatus.GetAxesStatus(axis).axisSupportedFunction.velocityFeedbackSupport))

    # Axis Supported Function / Velocity Command Support        TRUE: The axis supports receiving velocity command data every cycle. The Axis Command Mode must be set to Velocity to execute velocity command data. FALSE: The axis does not support receiving velocity command data every cycle.
    # Variable Name:   velocityCommandSupport
    # Type:            bool
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Axis Supported Function / Velocity Command Support : ' + str(CmStatus.GetAxesStatus(axis).axisSupportedFunction.velocityCommandSupport))

    # Axis Supported Function / Velocity Offset Support     TRUE: The axis supports receiving velocity offset data every cycle. The velocity offset data is generated for sync slave axes with the Sync Compensation Mode parameter set to VelocityOffset or SymmetricVelocityOffset and sync master axes with the Sync Compensation Mode parameter of the slave axis set to SymmetricVelocityOffset. FALSE: The axis does not support receiving velocity offset data every cycle.
    # Variable Name:   velocityOffsetSupport
    # Type:            bool
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Axis Supported Function / Velocity Offset Support : ' + str(CmStatus.GetAxesStatus(axis).axisSupportedFunction.velocityOffsetSupport))

    # Axis Supported Function / Trq Feedback Support        TRUE: The axis returns torque feedback data every cycle. The torque feedback data is stored in the Actual Torque status. FALSE: The axis does not return torque feedback data every cycle.
    # Variable Name:   trqFeedbackSupport
    # Type:            bool
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Axis Supported Function / Trq Feedback Support : ' + str(CmStatus.GetAxesStatus(axis).axisSupportedFunction.trqFeedbackSupport))

    # Axis Supported Function / Trq Command Support     TRUE: The axis supports receiving torque command data every cycle. The Axis Command Mode must be set to Torque to execute torque command data. FALSE: The axis does not support receiving torque command data every cycle.
    # Variable Name:   trqCommandSupport
    # Type:            bool
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Axis Supported Function / Trq Command Support : ' + str(CmStatus.GetAxesStatus(axis).axisSupportedFunction.trqCommandSupport))

    # Axis Supported Function / Max Trq Limit Support       TRUE: The axis supports receiving maximum torque limit data every cycle. The maximum torque limit is set by the Max Trq Limit parameter. FALSE: The axis does not support receiving maximum torque limit data every cycle.
    # Variable Name:   maxTrqLimitSupport
    # Type:            bool
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Axis Supported Function / Max Trq Limit Support : ' + str(CmStatus.GetAxesStatus(axis).axisSupportedFunction.maxTrqLimitSupport))

    # Axis Supported Function / Positive Trq Limit Support      TRUE: The axis supports receiving positive torque limit data every cycle. The positive torque limit is set by the Positive Trq Limit parameter. FALSE: The axis does not support receiving positive torque limit data every cycle.
    # Variable Name:   positiveTrqLimitSupport
    # Type:            bool
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Axis Supported Function / Positive Trq Limit Support : ' + str(CmStatus.GetAxesStatus(axis).axisSupportedFunction.positiveTrqLimitSupport))

    # Axis Supported Function / Negative Trq Limit Support      TRUE: The axis supports receiving negative torque limit data every cycle. The negative torque limit is set by the Negative Trq Limit parameter. FALSE: The axis does not support receiving negative torque limit data every cycle.
    # Variable Name:   negativeTrqLimitSupport
    # Type:            bool
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Axis Supported Function / Negative Trq Limit Support : ' + str(CmStatus.GetAxesStatus(axis).axisSupportedFunction.negativeTrqLimitSupport))

    # Axis Supported Function / Max Motor Speed Support     TRUE: The axis supports receiving maximum motor speed data every cycle. The maximum motor speed is set by the Max Motor Speed parameter. FALSE: The axis does not support receiving maximum motor speed data every cycle.
    # Variable Name:   maxMotorSpeedSupport
    # Type:            bool
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Axis Supported Function / Max Motor Speed Support : ' + str(CmStatus.GetAxesStatus(axis).axisSupportedFunction.maxMotorSpeedSupport))

    # Op State      The operation state of the axis. The operation state shows the type of motion command that the axis is currently executing.
    # Variable Name:   opState
    # Type:            OperationState::T
    # Update Timing:   Acyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Op State : ' + str(CmStatus.GetAxesStatus(axis).opState))

    # Detail Op State       The detailed operation state of the axis. This status is similar to the Op State status, except the states are subdivided into more specific states.
    # Variable Name:   detailOpState
    # Type:            DetailOperationState::T
    # Update Timing:   Acyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Detail Op State : ' + str(CmStatus.GetAxesStatus(axis).detailOpState))

    # Axis Command Mode     The command mode of the axis. The command mode determines whether the axis is executing cyclic position commands, cyclic velocity commands, or cyclic torque commands. This status equals the value set by the Axis Command Mode parameter.
    # Variable Name:   axisCommandMode
    # Type:            AxisCommandMode::T
    # Update Timing:   Acyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Axis Command Mode : ' + str(CmStatus.GetAxesStatus(axis).axisCommandMode))

    # Axis Command Mode Feedback        The feedback from the servo of the current command mode of the axis. When the command mode is changed, the servo may take a few cycles to switch to the new command mode. This status returns the old command mode until the switch is complete.
    # Variable Name:   axisCommandModeFeedback
    # Type:            AxisCommandMode::T
    # Update Timing:   Acyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Axis Command Mode Feedback : ' + str(CmStatus.GetAxesStatus(axis).axisCommandModeFeedback))

    # Axis Sync Mode        The sync control mode of the axis. If the axis is not a synchronous control slave axis, the sync control mode is NoSync. If the axis is a sync slave, the sync control mode depends on the Sync Compensation Mode of the axis and whether the axis has Velocity Offset Support.
    # Variable Name:   axisSyncMode
    # Type:            AxisSyncMode::T
    # Update Timing:   Acyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Axis Sync Mode : ' + str(CmStatus.GetAxesStatus(axis).axisSyncMode))

    # Sync Offset       If the axis is a synchronous control slave axis, this status contains the sync offset between the master axis and the slave axis. The sync offset is calculated when synchronous control is started as the difference between the master axis and slave axis command positions. If useMasterFeedback is set, the master feedback position is used instead of the master command position for calculating the sync offset.
    # Variable Name:   syncOffset
    # Type:            double
    # Unit:            user unit
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Sync Offset : ' + str(CmStatus.GetAxesStatus(axis).syncOffset))

    # Sync Phase Offset     If the axis is a synchronous control slave axis, this status contains the phase offset between the master axis and the slave axis. The phase offset can be modified with functions such as SetAbsoluteSyncPhase and AddRelativeSyncPhase.
    # Variable Name:   syncPhaseOffset
    # Type:            double
    # Unit:            user unit
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Sync Phase Offset : ' + str(CmStatus.GetAxesStatus(axis).syncPhaseOffset))

    # Sync Gear Ratio       If the axis is a synchronous control slave axis, this status contains the sync gear ratio between the master axis and the slave axis. The sync gear ratio can be modified with functions such as SetSyncGearRatio.
    # Variable Name:   syncGearRatio
    # Type:            double
    # Unit:            none (ratio)
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Sync Gear Ratio : ' + str(CmStatus.GetAxesStatus(axis).syncGearRatio))

    # Profile Total Milliseconds        The total time the current motion profile will take to complete. For axes executing Trigger Motion as an override, the profile status of the overridden motion will be returned until the trigger condition is satisfied. If the trigger motion is started from Idle state, the profile status will return 0 until the trigger condition is satisfied.
    # Variable Name:   profileTotalMilliseconds
    # Type:            double
    # Unit:            milliseconds
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Profile Total Milliseconds : ' + str(CmStatus.GetAxesStatus(axis).profileTotalMilliseconds))

    # Profile Acc Milliseconds      The total time the current motion profile will spend accelerating. For axes executing Trigger Motion as an override, the profile status of the overridden motion will be returned until the trigger condition is satisfied. If the trigger motion is started from Idle state, the profile status will return 0 until the trigger condition is satisfied.
    # Variable Name:   profileAccMilliseconds
    # Type:            double
    # Unit:            milliseconds
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Profile Acc Milliseconds : ' + str(CmStatus.GetAxesStatus(axis).profileAccMilliseconds))

    # Profile Cruise Milliseconds       The total time the current motion profile will spend at a constant velocity. For axes executing Trigger Motion as an override, the profile status of the overridden motion will be returned until the trigger condition is satisfied. If the trigger motion is started from Idle state, the profile status will return 0 until the trigger condition is satisfied.
    # Variable Name:   profileCruiseMilliseconds
    # Type:            double
    # Unit:            milliseconds
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Profile Cruise Milliseconds : ' + str(CmStatus.GetAxesStatus(axis).profileCruiseMilliseconds))

    # Profile Dec Milliseconds      The total time the current motion profile will spend decelerating. If the motion is an override that causes the axis to change the direction of travel, the time spent decelerating before reversing direction is not included in this value. For axes executing Trigger Motion as an override, the profile status of the overridden motion will be returned until the trigger condition is satisfied. If the trigger motion is started from Idle state, the profile status will return 0 until the trigger condition is satisfied.
    # Variable Name:   profileDecMilliseconds
    # Type:            double
    # Unit:            milliseconds
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Profile Dec Milliseconds : ' + str(CmStatus.GetAxesStatus(axis).profileDecMilliseconds))

    # Profile Remaining Milliseconds        The remaining time the current motion profile will take to complete. For axes executing Trigger Motion as an override, the profile status of the overridden motion will be returned until the trigger condition is satisfied. If the trigger motion is started from Idle state, the profile status will return 0 until the trigger condition is satisfied.
    # Variable Name:   profileRemainingMilliseconds
    # Type:            double
    # Unit:            milliseconds
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Profile Remaining Milliseconds : ' + str(CmStatus.GetAxesStatus(axis).profileRemainingMilliseconds))

    # Profile Completed Milliseconds        The time that the current motion profile has executed for. For axes executing Trigger Motion as an override, the profile status of the overridden motion will be returned until the trigger condition is satisfied. If the trigger motion is started from Idle state, the profile status will return 0 until the trigger condition is satisfied.
    # Variable Name:   profileCompletedMilliseconds
    # Type:            double
    # Unit:            milliseconds
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Profile Completed Milliseconds : ' + str(CmStatus.GetAxesStatus(axis).profileCompletedMilliseconds))

    # Profile Target Pos        The target positon of the current motion profile. For axes executing Trigger Motion as an override, the profile status of the overridden motion will be returned until the trigger condition is satisfied. If the trigger motion is started from Idle state, the profile status will return 0 until the trigger condition is satisfied.
    # Variable Name:   profileTargetPos
    # Type:            double
    # Unit:            user unit
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Profile Target Pos : ' + str(CmStatus.GetAxesStatus(axis).profileTargetPos))

    # Profile Total Distance        The total distance that the current motion profile will move. This is equal to the sum of the Profile Remaining Distance and the Profile Completed Distance. For the motion profiles of interpolation commands, this is the composite distance along the interpolation path. For axes executing Trigger Motion as an override, the profile status of the overridden motion will be returned until the trigger condition is satisfied. If the trigger motion is started from Idle state, the profile status will return 0 until the trigger condition is satisfied.
    # Variable Name:   profileTotalDistance
    # Type:            double
    # Unit:            user unit
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Profile Total Distance : ' + str(CmStatus.GetAxesStatus(axis).profileTotalDistance))

    # Profile Remaining Distance        The remaining distance until the current motion profile completes. For the motion profiles of interpolation commands, this is the composite remaining distance along the interpolation path. For axes executing Trigger Motion as an override, the profile status of the overridden motion will be returned until the trigger condition is satisfied. If the trigger motion is started from Idle state, the profile status will return 0 until the trigger condition is satisfied.
    # Variable Name:   profileRemainingDistance
    # Type:            double
    # Unit:            user unit
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Profile Remaining Distance : ' + str(CmStatus.GetAxesStatus(axis).profileRemainingDistance))

    # Profile Completed Distance        The distance moved so far by the current motion profile. For the motion profiles of interpolation commands, this is the composite distance moved along the interpolation path. For axes executing Trigger Motion as an override, the profile status of the overridden motion will be returned until the trigger condition is satisfied. If the trigger motion is started from Idle state, the profile status will return 0 until the trigger condition is satisfied.
    # Variable Name:   profileCompletedDistance
    # Type:            double
    # Unit:            user unit
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Profile Completed Distance : ' + str(CmStatus.GetAxesStatus(axis).profileCompletedDistance))

    # Intpl Velocity        If the axis is executing an interpolation command, this status contains the composite velocity along the interpolation path. All axes executing the same interpolation command will have the same value. For axes executing Trigger Motion as an override, the profile status of the overridden motion will be returned until the trigger condition is satisfied. If the trigger motion is started from Idle state, the profile status will return 0 until the trigger condition is satisfied.
    # Variable Name:   intplVelocity
    # Type:            double
    # Unit:            user unit / second
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Intpl Velocity : ' + str(CmStatus.GetAxesStatus(axis).intplVelocity))

    # Intpl Segment     If the axis is executing an interpolation command consiting of several segments (such as path interpolation and spline interpolation), this status contains the index of the currently executing segment.
    # Variable Name:   intplSegment
    # Type:            int
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Intpl Segment : ' + str(CmStatus.GetAxesStatus(axis).intplSegment))

    # Following Error Alarm     TRUE: Following error has occurred. FALSE: Following error has not occurred. The condition for the following error is configured with the Following Error Type and Velocity Following Error Type parameters. This status is also turned on when the error configured with the Servo On Following Error parameter occurs.
    # Variable Name:   followingErrorAlarm
    # Type:            bool
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Following Error Alarm : ' + str(CmStatus.GetAxesStatus(axis).followingErrorAlarm))

    # Command Ready     TRUE: The axis is in a state that is able to accept motion commands, including overrides. FALSE: The axis is in a state that is unable to accept motion commands.
    # Variable Name:   commandReady
    # Type:            bool
    # Update Timing:   Acyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Command Ready : ' + str(CmStatus.GetAxesStatus(axis).commandReady))

    # Waiting for Trigger       TRUE: The axis is waiting for the trigger condition of a trigger motion to be satisfied. For more information regarding trigger motion, see Trigger Motion. FALSE: The axis is not waiting for a trigger condition.
    # Variable Name:   waitingForTrigger
    # Type:            bool
    # Update Timing:   Acyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Waiting for Trigger : ' + str(CmStatus.GetAxesStatus(axis).waitingForTrigger))

    # Motion Paused     TRUE: The axis motion has been paused by a function such as Pause. FALSE: The axis motion is not paused, or the axis is not executing motion.
    # Variable Name:   motionPaused
    # Type:            bool
    # Update Timing:   Acyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Motion Paused : ' + str(CmStatus.GetAxesStatus(axis).motionPaused))

    # Motion Complete       This status is set to 0 when a new motion command is started. When the motion completes, this status is set to 1 in the same cycle that the operation state (Op State) is set to Idle. This status is set to 0 when a stop function is called. The status remains 0 after the axis stops. This status is also set to 0 when a jog or velocity command is started. These motion commands do not set this status to 1. This status is also set to 0 when one of the following conditions cause the axis to stop. •A limit switch is triggered for the axis with the DecServoOff, Dec, SlowDecServoOff, or SlowDec limit switch type. •A following error alarm is triggered for the axis with the QuickStop following error alarm type. •A velocity following error alarm is triggered for the axis with the QuickStop velocity following error alarm type. •A sync master axis has desynchronized with the DecServoOff or Dec master desync type. •An emergency stop is triggered with the Level1 emergency stop level. This status is not updated for Sync axes. This status is also set to 1 in the abnormal case in which one of the motion commands in the above two tables are executed, but the target position is farther away than the Maximum Travel Distance.
    # Variable Name:   motionComplete
    # Type:            bool
    # Update Timing:   Acyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Motion Complete : ' + str(CmStatus.GetAxesStatus(axis).motionComplete))

    # Exec Superimposed Motion      TRUE: Axis is executing superimposed motion. FALSE: Axis is not executing superimposed motion.
    # Variable Name:   execSuperimposedMotion
    # Type:            bool
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Exec Superimposed Motion : ' + str(CmStatus.GetAxesStatus(axis).execSuperimposedMotion))

    # Cmd Acc       Instantaneous command acceleration calculated from command velocity (for Velocity mode axes) or command position (for Position mode axes). This status is returned regardless of the motion command that is being executed.
    # Variable Name:   cmdAcc
    # Type:            double
    # Unit:            user unit / second^2
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Cmd Acc : ' + str(CmStatus.GetAxesStatus(axis).cmdAcc))

    # Acc Flag      TRUE: Axis is accelerating. FALSE: Axis is not accelerating.
    # Variable Name:   accFlag
    # Type:            bool
    # Update Timing:   Acyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Acc Flag : ' + str(CmStatus.GetAxesStatus(axis).accFlag))

    # Dec Flag      TRUE: Axis is decelerating. FALSE: Axis is not decelerating.
    # Variable Name:   decFlag
    # Type:            bool
    # Update Timing:   Acyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Dec Flag : ' + str(CmStatus.GetAxesStatus(axis).decFlag))

    # In Pos        TRUE: The axis is within the In Pos Width of the target position of the current motion command. FALSE: The axis is not within the In Pos Width of the target position of the current motion command. In Position State for Single Turn Axes : Single turn axes are set using the Single Turn Mode parameter. Wraparound around the single turn encoder count range is considered when calculating the in position state for single turn axes. For example, if the single turn encoder count is the equivalent of 1000 user units, the in position width is 100 user units, and the cyclic command position is 0, the axis will be in position if the feedback position is between 900-1000 or between 0-100. If a position command causes the axis to move a distance greater than one single turn encoder count, the axis will be in position each time the axis passes the target position inside the single turn encoder count range. For example, if the single turn encoder count is the equivalent of 1000 user units, and a relative position command of 5000 user units is executed, the axis will wrap around the single turn range five times, passing by the target position four times and stopping at the target position on the fifth lap. Each time the axis passes the target position, the axis will be in position as long as the distance between the feedback position and the target position is within the in position width. Wraparound around the single turn encoder count range is NOT considered when calculating the in position state during the execution of an interpolation command.
    # Variable Name:   inPos
    # Type:            bool
    # Update Timing:   Acyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('In Pos : ' + str(CmStatus.GetAxesStatus(axis).inPos))

    # In Pos 2      TRUE: The axis is within the In Pos Width 2 of the target position of the current motion command. FALSE: The axis is not within the In Pos Width 2 of the target position of the current motion command. This status is the same as the In Pos status except the In Pos Width 2 parameter is used instead of In Pos Width.
    # Variable Name:   inPos2
    # Type:            bool
    # Update Timing:   Acyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('In Pos 2 : ' + str(CmStatus.GetAxesStatus(axis).inPos2))

    # In Pos 3      TRUE: The axis is within the In Pos Width 3 of the target position of the current motion command. FALSE: The axis is not within the In Pos Width 3 of the target position of the current motion command. This status is the same as the In Pos status except the In Pos Width 3 parameter is used instead of In Pos Width.
    # Variable Name:   inPos3
    # Type:            bool
    # Update Timing:   Acyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('In Pos 3 : ' + str(CmStatus.GetAxesStatus(axis).inPos3))

    # In Pos 4      TRUE: The axis is within the In Pos Width 4 of the target position of the current motion command. FALSE: The axis is not within the In Pos Width 4 of the target position of the current motion command. This status is the same as the In Pos status except the In Pos Width 4 parameter is used instead of In Pos Width.
    # Variable Name:   inPos4
    # Type:            bool
    # Update Timing:   Acyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('In Pos 4 : ' + str(CmStatus.GetAxesStatus(axis).inPos4))

    # In Pos 5      TRUE: The axis is within the In Pos Width 5 of the target position of the current motion command. FALSE: The axis is not within the In Pos Width 5 of the target position of the current motion command. This status is the same as the In Pos status except the In Pos Width 5 parameter is used instead of In Pos Width.
    # Variable Name:   inPos5
    # Type:            bool
    # Update Timing:   Acyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('In Pos 5 : ' + str(CmStatus.GetAxesStatus(axis).inPos5))

    # Cmd Distribution End      TRUE: The command position of the axis is equal to the target position of the current motion command. The actual position (Actual Pos) of the axis may still not be at the target position. This status indicates that the axis has completed the motion command and is in Idle operation state. FALSE: The command position of the axis is not equal to the target position of the current motion command. The axis is still executing the motion command.
    # Variable Name:   cmdDistributionEnd
    # Type:            bool
    # Update Timing:   Acyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Cmd Distribution End : ' + str(CmStatus.GetAxesStatus(axis).cmdDistributionEnd))

    # Pos Set       TRUE: The command position of the axis is equal to the target position of the current motion command and the feedback position is within the Pos Set Width of the target position. FALSE: The command position of the axis is not equal to the target position of the current motion command, or the feedback position is not within the Pos Set Width of the target position. If the Cmd Distribution End status is TRUE, and the difference between the Actual Pos and Pos Cmd is less than or equal to the Pos Set Width parameter, this status will be set to TRUE. Otherwise, this status will be set to FALSE. If the Servo On status is FALSE, this status will be set to FALSE. Pos Set State for Single Turn Axes : Single turn axes are set using the Single Turn Mode parameter. Wraparound around the single turn encoder count range is considered when calculating this status. For example, if the single turn encoder count is the equivalent of 1000 user units, the Pos Set Width is 100 user units, and the target position is 0, this status will be set to TRUE if the feedback position is between 900-1000 or between 0-100.
    # Variable Name:   posSet
    # Type:            bool
    # Update Timing:   Acyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Pos Set : ' + str(CmStatus.GetAxesStatus(axis).posSet))

    # Delayed Pos Set       TRUE: The command position of the axis is equal to the target position of the current motion command and the feedback position remained within the Delayed Pos Set Width of the target position continuously for Delayed Pos Set Milliseconds amount of time. FALSE: The command position of the axis is not equal to the target position of the current motion command, or the feedback position is not within the Delayed Pos Set Width of the target position, or the axis did not remain within this range continuously for Delayed Pos Set Milliseconds amount of time. If the Servo On status is FALSE, this status will be set to FALSE. Delayed Pos Set State for Single Turn Axes : Single turn axes are set using the Single Turn Mode parameter. Wraparound around the single turn encoder count range is considered when calculating this status. For example, if the single turn encoder count is the equivalent of 1000 user units, the Delayed Pos Set Width is 100 user units, and the target position is 0, this status will be set to TRUE if the feedback position is between 900-1000 or between 0-100 for Delayed Pos Set Milliseconds amount of time.
    # Variable Name:   delayedPosSet
    # Type:            bool
    # Update Timing:   Acyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Delayed Pos Set : ' + str(CmStatus.GetAxesStatus(axis).delayedPosSet))

    # Cmd Distribution End Delayed Pos Set Diff     The duration between when the Cmd Distribution End status was set and when the Delayed Pos Set status was set, in units of communication cycles. This value is set during the cycle that the Delayed Pos Set status is set. This value is cleared whenever the Cmd Distribution End status changes from FALSE to TRUE.
    # Variable Name:   cmdDistributionEndDelayedPosSetDiff
    # Type:            unsigned int
    # Unit:            communication cycles
    # Update Timing:   Acyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Cmd Distribution End Delayed Pos Set Diff : ' + str(CmStatus.GetAxesStatus(axis).cmdDistributionEndDelayedPosSetDiff))

    # Positive LS       TRUE: Positive limit switch is on. FALSE: Positive limit switch is off. If the Invert Positive LS Polarity parameter is set to TRUE, this status will return TRUE when the positive limit switch signal from the servo is low and FALSE when the positive limit switch signal from the servo is high.
    # Variable Name:   positiveLS
    # Type:            bool
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Positive LS : ' + str(CmStatus.GetAxesStatus(axis).positiveLS))

    # Negative LS       TRUE: Negative limit switch is on. FALSE: Negative limit switch is off. If the Invert Negative LS Polarity parameter is set to TRUE, this status will return TRUE when the negative limit switch signal from the servo is low and FALSE when the negative limit switch signal from the servo is high.
    # Variable Name:   negativeLS
    # Type:            bool
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Negative LS : ' + str(CmStatus.GetAxesStatus(axis).negativeLS))

    # Near Positive LS      TRUE: Positive near limit switch is on. FALSE: Positive near limit switch is off. If the Invert Near Positive LS Polarity parameter is set to TRUE, this status will return TRUE when the positive near limit switch signal is low and FALSE when the positive near limit switch signal is high. This status will always return FALSE if the Near LS Type parameter is set to None or if the Near LS Type parameter is set to SeparatePositiveLSNegativeLS and the Near Positive LS Type parameter is set to None.
    # Variable Name:   nearPositiveLS
    # Type:            bool
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Near Positive LS : ' + str(CmStatus.GetAxesStatus(axis).nearPositiveLS))

    # Near Negative LS      TRUE: Negative near limit switch is on. FALSE: Negative near limit switch is off. If the Invert Near Negative LS Polarity parameter is set to TRUE, this status will return TRUE when the negative near limit switch signal is low and FALSE when the negative near limit switch signal is high. This status will always return FALSE if the Near LS Type parameter is set to None or if the Near LS Type parameter is set to SeparatePositiveLSNegativeLS and the Near Negative LS Type parameter is set to None.
    # Variable Name:   nearNegativeLS
    # Type:            bool
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Near Negative LS : ' + str(CmStatus.GetAxesStatus(axis).nearNegativeLS))

    # External Positive LS      TRUE: Positive external limit switch is on. FALSE: Positive external limit switch is off. If the Invert External Positive LS Polarity parameter is set to TRUE, this status will return TRUE when the positive external limit switch signal is low and FALSE when the positive external limit switch signal is high. This status will always return FALSE if the External LS Type parameter is set to None or if the External LS Type parameter is set to SeparatePositiveLSNegativeLS and the External Positive LS Type parameter is set to None.
    # Variable Name:   externalPositiveLS
    # Type:            bool
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('External Positive LS : ' + str(CmStatus.GetAxesStatus(axis).externalPositiveLS))

    # External Negative LS      TRUE: Negative external limit switch is on. FALSE: Negative external limit switch is off. If the Invert External Negative LS Polarity parameter is set to TRUE, this status will return TRUE when the negative external limit switch signal is low and FALSE when the negative external limit switch signal is high. This status will always return FALSE if the External LS Type parameter is set to None or if the External LS Type parameter is set to SeparatePositiveLSNegativeLS and the External Negative LS Type parameter is set to None.
    # Variable Name:   externalNegativeLS
    # Type:            bool
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('External Negative LS : ' + str(CmStatus.GetAxesStatus(axis).externalNegativeLS))

    # Positive Soft Limit       TRUE: Positive software limit is on. FALSE: Positive software limit is off.
    # Variable Name:   positiveSoftLimit
    # Type:            bool
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Positive Soft Limit : ' + str(CmStatus.GetAxesStatus(axis).positiveSoftLimit))

    # Negative Soft Limit       TRUE: Negative software limit is on. FALSE: Negative software limit is off.
    # Variable Name:   negativeSoftLimit
    # Type:            bool
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Negative Soft Limit : ' + str(CmStatus.GetAxesStatus(axis).negativeSoftLimit))

    # Home State        If the axis is executing a homing operation, this status contains the homing state of the axis.
    # Variable Name:   homeState
    # Type:            HomeState::T
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Home State : ' + str(CmStatus.GetAxesStatus(axis).homeState))

    # Home Error        The last encountered homing error code. This error code is cleared when an axis starts a new homing operation.
    # Variable Name:   homeError
    # Type:            HomeError::T
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Home Error : ' + str(CmStatus.GetAxesStatus(axis).homeError))

    # Home Offset       The cumulative sum of the offsets applied from changes to the home position. This value will change after performing a homing operation.
    # Variable Name:   homeOffset
    # Type:            double
    # Unit:            user unit
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Home Offset : ' + str(CmStatus.GetAxesStatus(axis).homeOffset))

    # Home Switch       TRUE: Home switch is on. FALSE: Home switch is off. If the Invert HS Polarity parameter is set to TRUE, this status will return TRUE when the home switch signal from the servo is low and FALSE when the home switch signal from the servo is high.
    # Variable Name:   homeSwitch
    # Type:            bool
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Home Switch : ' + str(CmStatus.GetAxesStatus(axis).homeSwitch))

    # Home Done     TRUE: Homing is complete. FALSE: Homing is not complete. Homing can be executed using functions such as StartHome. This status can also be manually toggled using the SetHomeDone function. If the Clear Home Done On Servo Off parameter is enabled for an axis, this status is set to FALSE when the servo is turned off. If the Clear Home Done On Comm Stop parameter is enabled for an axis, this status is set to FALSE when communication is stopped. When the servo is offline (see Servo Offline), this status is set to FALSE. This status is also set to FALSE when a new homing routine is started. When this status is set to FALSE, homing must be completed again before this status becomes TRUE. This status affects certain operations, such as the software limit (see Soft Limit Type).
    # Variable Name:   homeDone
    # Type:            bool
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Home Done : ' + str(CmStatus.GetAxesStatus(axis).homeDone))

    # Home Paused       TRUE: Axis is paused while homing. FALSE: Axis is not paused while homing.
    # Variable Name:   homePaused
    # Type:            bool
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Home Paused : ' + str(CmStatus.GetAxesStatus(axis).homePaused))

    # Cmd Pos To Fb Pos Flag        TRUE: Axis is executing a SetCommandPosToFeedbackPos operation. FALSE: Axis is not executing a SetCommandPosToFeedbackPos operation.
    # Variable Name:   cmdPosToFbPosFlag
    # Type:            bool
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Cmd Pos To Fb Pos Flag : ' + str(CmStatus.GetAxesStatus(axis).cmdPosToFbPosFlag))

    # Single Turn Counter       If the axis is a single turn axis (if the Single Turn Mode parameter is set to TRUE), this status contains the number of single turn rotations since starting single turn mode. When the axis position exceeds the Single Turn Encoder Count and loops back, this value increases by one. When the axis position goes below zero and loops back, this value decreases by one. This value itself loops around at 0 and 2^32-1 (for example, if this value decreases by 1 from 0, it becomes 2^32-1). This value is reset to 0 each time the Single Turn Encoder Count, Single Turn Mode, Gear Ratio Numerator, Gear Ratio Denominator, or Axis Polarity parameter is changed. This status contains 0 for non-single turn axes.
    # Variable Name:   singleTurnCounter
    # Type:            unsigned int
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Single Turn Counter : ' + str(CmStatus.GetAxesStatus(axis).singleTurnCounter))

    # User Offset       This status contains the user offset. The user offset is an additional offset that is applied to the command and feedback position. It can be freely set when developing a customized User RTDLL.
    # Variable Name:   userOffset
    # Type:            double
    # Unit:            user unit
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('User Offset : ' + str(CmStatus.GetAxesStatus(axis).userOffset))

    # User Offset Pos Cmd       This status contains the command position of the axis after applying the user offset.
    # Variable Name:   userOffsetPosCmd
    # Type:            double
    # Unit:            user unit
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('User Offset Pos Cmd : ' + str(CmStatus.GetAxesStatus(axis).userOffsetPosCmd))

    # User Offset Actual Pos        This status contains the feedback position of the axis after applying the user offset.
    # Variable Name:   userOffsetActualPos
    # Type:            double
    # Unit:            user unit
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('User Offset Actual Pos : ' + str(CmStatus.GetAxesStatus(axis).userOffsetActualPos))

    # User Velocity Offset      This status contains the user velocity offset. The user velocity offset is an additional offset that is applied to the command and feedback velocity. It can be freely set when developing a customized User RTDLL.
    # Variable Name:   userVelocityOffset
    # Type:            double
    # Unit:            user unit
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('User Velocity Offset : ' + str(CmStatus.GetAxesStatus(axis).userVelocityOffset))

    # User Torque Offset        This status contains the user torque offset. The user torque offset is an additional offset that is applied to the command and feedback torque. It can be freely set when developing a customized User RTDLL.
    # Variable Name:   userTorqueOffset
    # Type:            double
    # Unit:            user unit
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('User Torque Offset : ' + str(CmStatus.GetAxesStatus(axis).userTorqueOffset))

    # Vibration Pos Min     The status measures the minimum value of Actual Pos - Pos Cmd while the axis is stationary. The axis is considered to be stationary if the Op State of the axis is Idle or Sync, and the Delayed Pos Set signal has become TRUE at least once after the axis entered one of these operation states. This status is 0 when the engine is started. Whenever a smaller value of Actual Pos - Pos Cmd is measured while the axis is stationary, this status updates to equal that value. This status is reset to 0 when the axis changes from non-stationary to stationary state. The ClearVibrationStatus function can also be called to reset this status to 0 on the next communication cycle.
    # Variable Name:   vibrationPosMin
    # Type:            double
    # Unit:            user unit
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Vibration Pos Min : ' + str(CmStatus.GetAxesStatus(axis).vibrationPosMin))

    # Vibration Pos Max     The status measures the maximum value of Actual Pos - Pos Cmd while the axis is stationary. The axis is considered to be stationary if the Op State of the axis is Idle or Sync, and the Delayed Pos Set signal has become TRUE at least once after the axis entered one of these operation states. This status is 0 when the engine is started. Whenever a larger value of Actual Pos - Pos Cmd is measured while the axis is stationary, this status updates to equal that value. This status is reset to 0 when the axis changes from non-stationary to stationary state. The ClearVibrationStatus function can also be called to reset this status to 0 on the next communication cycle.
    # Variable Name:   vibrationPosMax
    # Type:            double
    # Unit:            user unit
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Vibration Pos Max : ' + str(CmStatus.GetAxesStatus(axis).vibrationPosMax))

    # Vibration Pos Average     The status measures the average value of Actual Pos - Pos Cmd while the axis is stationary. The axis is considered to be stationary if the Op State of the axis is Idle or Sync, and the Delayed Pos Set signal has become TRUE at least once after the axis entered one of these operation states. This status is 0 when the engine is started. On the cycles in which the axis is stationary, the average is updated with the new measured value of Actual Pos - Pos Cmd. The average is not affected by the value of Actual Pos - Pos Cmd while the axis is not stationary. This status is reset to 0 when the axis changes from non-stationary to stationary state. The ClearVibrationStatus function can also be called to reset this status to 0 on the next communication cycle.
    # Variable Name:   vibrationPosAvg
    # Type:            double
    # Unit:            user unit
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Vibration Pos Average : ' + str(CmStatus.GetAxesStatus(axis).vibrationPosAvg))

    # Vibration Vel Min     The status measures the minimum value of Actual Velocity while the axis is stationary. The axis is considered to be stationary if the Op State of the axis is Idle or Sync, and the Delayed Pos Set signal has become TRUE at least once after the axis entered one of these operation states. This status is 0 when the engine is started. Whenever a smaller value of Actual Velocity is measured while the axis is stationary, this status updates to equal that value. This status is reset to 0 when the axis changes from non-stationary to stationary state. The ClearVibrationStatus function can also be called to reset this status to 0 on the next communication cycle.
    # Variable Name:   vibrationVelMin
    # Type:            double
    # Unit:            user unit / second
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Vibration Vel Min : ' + str(CmStatus.GetAxesStatus(axis).vibrationVelMin))

    # Vibration Vel Max     The status measures the maximum value of Actual Velocity while the axis is stationary. The axis is considered to be stationary if the Op State of the axis is Idle or Sync, and the Delayed Pos Set signal has become TRUE at least once after the axis entered one of these operation states. This status is 0 when the engine is started. Whenever a larger value of Actual Velocity is measured while the axis is stationary, this status updates to equal that value. This status is reset to 0 when the axis changes from non-stationary to stationary state. The ClearVibrationStatus function can also be called to reset this status to 0 on the next communication cycle.
    # Variable Name:   vibrationVelMax
    # Type:            double
    # Unit:            user unit / second
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Vibration Vel Max : ' + str(CmStatus.GetAxesStatus(axis).vibrationVelMax))

    # Vibration Vel Average     The status measures the average value of Actual Velocity while the axis is stationary. The axis is considered to be stationary if the Op State of the axis is Idle or Sync, and the Delayed Pos Set signal has become TRUE at least once after the axis entered one of these operation states. This status is 0 when the engine is started. On the cycles in which the axis is stationary, the average is updated with the new measured value of Actual Velocity. The average is not affected by the value of Actual Velocity while the axis is not stationary. This status is reset to 0 when the axis changes from non-stationary to stationary state. The ClearVibrationStatus function can also be called to reset this status to 0 on the next communication cycle.
    # Variable Name:   vibrationVelAvg
    # Type:            double
    # Unit:            user unit / second
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Vibration Vel Average : ' + str(CmStatus.GetAxesStatus(axis).vibrationVelAvg))

    # Vibration Trq Min     The status measures the minimum value of Actual Torque while the axis is stationary. The axis is considered to be stationary if the Op State of the axis is Idle or Sync, and the Delayed Pos Set signal has become TRUE at least once after the axis entered one of these operation states. This status is 0 when the engine is started. Whenever a smaller value of Actual Torque is measured while the axis is stationary, this status updates to equal that value. This status is reset to 0 when the axis changes from non-stationary to stationary state. The ClearVibrationStatus function can also be called to reset this status to 0 on the next communication cycle.
    # Variable Name:   vibrationTrqMin
    # Type:            double
    # Unit:            %
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Vibration Trq Min : ' + str(CmStatus.GetAxesStatus(axis).vibrationTrqMin))

    # Vibration Trq Max        The status measures the maximum value of Actual Torque while the axis is stationary. The axis is considered to be stationary if the Op State of the axis is Idle or Sync, and the Delayed Pos Set signal has become TRUE at least once after the axis entered one of these operation states. This status is 0 when the engine is started. Whenever a larger value of Actual Torque is measured while the axis is stationary, this status updates to equal that value. This status is reset to 0 when the axis changes from non-stationary to stationary state. The ClearVibrationStatus function can also be called to reset this status to 0 on the next communication cycle.
    # Variable Name:   vibrationTrqMax
    # Type:            double
    # Unit:            %
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Vibration Trq Max : ' + str(CmStatus.GetAxesStatus(axis).vibrationTrqMax))

    # Vibration Trq Average     The status measures the average value of Actual Torque while the axis is stationary. The axis is considered to be stationary if the Op State of the axis is Idle or Sync, and the Delayed Pos Set signal has become TRUE at least once after the axis entered one of these operation states. This status is 0 when the engine is started. On the cycles in which the axis is stationary, the average is updated with the new measured value of Actual Torque. The average is not affected by the value of Actual Torque while the axis is not stationary. This status is reset to 0 when the axis changes from non-stationary to stationary state. The ClearVibrationStatus function can also be called to reset this status to 0 on the next communication cycle.
    # Variable Name:   vibrationTrqAvg
    # Type:            double
    # Unit:            %
    # Update Timing:   Cyclic
    # Read the current system status from the engine
    # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
    ret, CmStatus = Wmx3Lib_cm.GetStatus()
    if (ret != 0):
        print('GetStatus error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    print('Vibration Trq Average : ' + str(CmStatus.GetAxesStatus(axis).vibrationTrqAvg))



#``



# Write Python code to perform a soft landing, or torque control.

# WMX3 python library
from WMX3ApiPython import *
from time import *

INFINITE = int(0xFFFFFFFF)
class WMX3SoftLand():
    def __init__(self):
        self.wmxApi = WMX3Api()
        self.Wmx3Lib_buf = ApiBuffer(self.wmxApi)
        self.Wmx3Lib_cm = CoreMotion(self.wmxApi)
        self.ApiBuffstu = ApiBufferStatus()
        self.Opsta = ApiBufferOptions()
    def SoftLandInit(self,channel):
        # Create devices.
        ret=self.wmxApi.CreateDevice('C:\\Program Files\\SoftServo\\WMX3\\', DeviceType.DeviceTypeNormal, INFINITE)
        if ret!=0:
            return  ret
        sleep(0.1)
        #  Free the buffer of the specified channel.
        ret = self.Wmx3Lib_buf.FreeApiBuffer(channel)
        sleep(0.01)
        # Create a buffer for the specified channel.
        ret = self.Wmx3Lib_buf.CreateApiBuffer(channel, 1024 * 1024 * 3)
        if ret != 0:
            return ret

    def SoftLandClose(self,channel):
        self.Wmx3Lib_buf.FreeApiBuffer(channel)
        self.wmxApi.CloseDevice()

    def GetApiBufferStu(self,channel):
        ret,self.ApiBuffstu= self.Wmx3Lib_buf.GetStatus(channel)
        return  self.ApiBuffstu.remainingBlockCount
    def SoftLandApibufferData(self,channel,axis,StartPoint,SlowVelPoint,TargetPoint,FastVel,SlowVel,Acc,Trqlimit,SleepTime):
        self.Wmx3Lib_buf.Halt(channel)
        sleep(0.01)
        self.Wmx3Lib_buf.Clear(channel)
        sleep(0.01)
        # Start recording for the specified channel.
        self.Wmx3Lib_buf.StartRecordBufferChannel(0)
        # Create a command value.
        posCommand = Motion_PosCommand()
        posCommand.profile.type = ProfileType.Trapezoidal
        posCommand.axis = axis
        posCommand.target = StartPoint
        posCommand.profile.velocity = FastVel
        posCommand.profile.acc = Acc
        posCommand.profile.dec = Acc
        # Run to the starting position.
        self.Wmx3Lib_cm.motion.StartPos(posCommand)
        # Wait for the movement to be completed.
        self.Wmx3Lib_buf.Wait(axis)
        posCommand.target = SlowVelPoint
        posCommand.profile.velocity = FastVel
        posCommand.profile.endVelocity = SlowVel
        # Run at high speed to the low-speed point, and set the end speed equal to the low speed.
        self.Wmx3Lib_cm.motion.StartPos(posCommand)
        # Wait for the movement to be completed.
        self.Wmx3Lib_buf.Wait(axis)
        # Torque limit value written.
        self.Wmx3Lib_cm.torque.SetMaxTrqLimit(axis,Trqlimit)
      # self.Wmx3Lib_cm.torque.SetNegativeTrqLimit(axis,Trqlimit)
      # self.Wmx3Lib_cm.torque.SetPositiveTrqLimit(axis,Trqlimit)
        posCommand.target = TargetPoint
        posCommand.profile.velocity = SlowVel
        posCommand.profile.startingVelocity = SlowVel
        posCommand.profile.endVelocity = 0
        # Run to the target point at low speed.
        self.Wmx3Lib_cm.motion.StartPos(posCommand)
        # Wait for the movement to be completed.
        self.Wmx3Lib_buf.Wait(axis)
        # Delay
        self.Wmx3Lib_buf.Sleep(SleepTime*1000)

        # Raise the process.
        posCommand.target = SlowVelPoint
        posCommand.profile.velocity = SlowVel
        posCommand.profile.startingVelocity = 0
        posCommand.profile.endVelocity = FastVel
        # Run at low speed to the deceleration point first.
        self.Wmx3Lib_cm.motion.StartPos(posCommand)
        # Wait for the movement to be completed.
        self.Wmx3Lib_buf.Wait(axis)
        # Torque restriction is lifted
        self.Wmx3Lib_cm.torque.SetMaxTrqLimit(axis, 300)
        # self.Wmx3Lib_cm.torque.SetNegativeTrqLimit(axis,300)
        # self.Wmx3Lib_cm.torque.SetPositiveTrqLimit(axis,300)
        posCommand.target = StartPoint
        posCommand.profile.velocity = FastVel
        posCommand.profile.startingVelocity = FastVel
        posCommand.profile.endVelocity = 0
        # Run to the start point at high speed.
        self.Wmx3Lib_cm.motion.StartPos(posCommand)
        # Wait for the movement to be completed.
        self.Wmx3Lib_buf.Wait(axis)
        # End Recording.
        self.Wmx3Lib_buf.EndRecordBufferChannel()
        # When this option is FALSE, the API buffer will continue execution when an API returns an error. When this option is TRUE, the API buffer will stop execution when an API returns an error. Execution may be resumed using the Execute function.
        self.Opsta.stopOnLastBlock = True
        # When this option is FALSE, the API buffer will remain in Active state after the last API in the buffer is executed. When another API is added to the buffer, it is immediately executed. When this option is TRUE, the API buffer will change to the Stop state when the last API in the buffer is executed as if the Halt function is called. When another API is added to the buffer, it will not be executed until the Execute function is called.
        self.Opsta.stopOnError = True
        # When this option is FALSE, the API buffer will wait for additional API functions to be entered into the buffer when the buffer becomes empty. When this option is TRUE, the API buffer will rewind when the buffer becomes empty and continue execution from the first API in the buffer. This option will not rewind the buffer when the first API in the buffer has been overwritten by an API that is added later.
        self.Opsta.autoRewind = False
        self.Wmx3Lib_buf.SetOptions(channel,self.Opsta)

    def SoftLandMovStarPoint(self,axis,StartPoint,SlowVelPoint,FastVel,SlowVel,Acc):
        posCommand = Motion_PosCommand()
        posCommand.profile.type = ProfileType.Trapezoidal
        posCommand.axis = axis
        posCommand.profile.velocity = SlowVel
        posCommand.profile.acc = Acc
        posCommand.profile.dec = Acc
        posCommand.target = SlowVelPoint
        posCommand.profile.startingVelocity = 0
        posCommand.profile.endVelocity = FastVel
        # Execute command to move to a specified absolute position.
        self.Wmx3Lib_cm.motion.StartPos(posCommand)
        self.Wmx3Lib_cm.Wait(axis)
        self.Wmx3Lib_cm.torque.SetMaxTrqLimit(axis, 300)
        # self.Wmx3Lib_cm.torque.SetNegativeTrqLimit(axis,300)
        # self.Wmx3Lib_cm.torque.SetPositiveTrqLimit(axis,300)
        posCommand.target = StartPoint
        posCommand.profile.velocity = FastVel
        posCommand.profile.startingVelocity = FastVel
        posCommand.profile.endVelocity = 0
        # Execute command to move to a specified absolute position.
        self.Wmx3Lib_cm.motion.StartPos(posCommand)
        self.Wmx3Lib_cm.Wait(axis)
    def SoftLandStart(self,channel):
        ret=self.Wmx3Lib_buf.Execute(channel)
        return ret

def main():
    Wmx3Lib = WMX3Api()
    CmStatus = CoreMotionStatus()
    Wmx3Lib_cm = CoreMotion(Wmx3Lib)
    Wmx3Lib_buf = ApiBuffer(Wmx3Lib)
    Wmx_Softland= WMX3SoftLand()
    print('Program begin.')
    sleep(1)

    # Create devices.
    ret = Wmx3Lib.CreateDevice('C:\\Program Files\\SoftServo\\WMX3', DeviceType.DeviceTypeNormal, INFINITE)
    if ret!=0:
        print('CreateDevice error code is ' + str(ret) + ': ' + Wmx3Lib.ErrorToString(ret))
    # Set Device Name.
    Wmx3Lib.SetDeviceName('ApiBufferMotion')
    #AxisId
    axis = 0
    # Start Communication.
    timeoutCounter=0
    for i in range(100):
        ret = Wmx3Lib.StartCommunication(INFINITE)
        if ret != 0:
            print('StartCommunication error code is ' + str(ret) + ': ' + Wmx3Lib.ErrorToString(ret))
        ret, CmStatus = Wmx3Lib_cm.GetStatus()
        if (CmStatus.engineState==EngineState.Communicating):
            break

    # Import and set all the preset motion parameters.
    ret=Wmx3Lib_cm.config.ImportAndSetAll("C:\\Program Files\\SoftServo\\WMX3\\wmx_parameters.xml")
    if ret != 0:
        print('ImportAndSetAll Parameters error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
    sleep(0.5)

    ret = Wmx3Lib_cm.axisControl.SetServoOn(axis, 1)
    while True:
        # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
        ret, CmStatus = Wmx3Lib_cm.GetStatus()
        if (CmStatus.GetAxesStatus(axis).servoOn):
            break
        sleep(0.1)
        # Homing
    homeParam = Config_HomeParam()
    ret, homeParam = Wmx3Lib_cm.config.GetHomeParam(axis)
    homeParam.homeType = Config_HomeType.CurrentPos
    # SetHomeParam -> First return value: Error code, Second return value: param error
    ret, homeParamError = Wmx3Lib_cm.config.SetHomeParam(axis, homeParam)

    ret = Wmx3Lib_cm.home.StartHome(axis)
    if ret != 0:
        print('StartHome error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
    Wmx3Lib_cm.motion.Wait(axis)

    ret = Wmx_Softland.SoftLandInit(0)
    if ret != 0:
        print('SoftLandInit error code is ' + str(ret) )
    # Record a soft landing process with the following parameters: Starting point is 0, deceleration point is 400, target point is 500, high speed is 1000, low speed is 100, and the acceleration and deceleration are the same at 10000, with a torque limit of 30.
    Wmx_Softland.SoftLandApibufferData(0,axis,0,400,500,1000,100,10000,30,2)
    ret = Wmx_Softland.SoftLandStart(0)
    if ret != 0:
        print('SoftLandStart error code is ' + str(ret) )
    while True:
        cutter = Wmx_Softland.GetApiBufferStu(0)
        if (cutter<=0):
            break
        sleep(0.01)
    Wmx3Lib_cm.motion.Wait(axis)

    Wmx_Softland.SoftLandClose(0)
    # Set servo off.
    ret = Wmx3Lib_cm.axisControl.SetServoOn(axis, 0)
    if ret != 0:
        print('SetServoOn to off error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))

    # Stop Communication.
    ret = Wmx3Lib.StopCommunication(INFINITE)
    if ret != 0:
        print('StopCommunication error code is ' + str(ret) + ': ' + Wmx3Lib.ErrorToString(ret))

    # Close Device.
    ret = Wmx3Lib.CloseDevice()
    if ret != 0:
        print('CloseDevice error code is ' + str(ret) + ': ' + Wmx3Lib.ErrorToString(ret))

    print('Program End.')

if __name__ == '__main__':
    main()


#``



