[
    {
        "No": 1,
        "Instruction": "Get a string representation of the raw data of an API log.",
        "A": "ApiLogDataToString(pLogData, logDataSize)",
        "B": "ApiLogToString(pLogData, logDataSize)",
        "C": "GetPlannedVelOverrideStatus(channel)",
        "D": "Clear(channel)",
        "Answer(s)": "B"
    },
    {
        "No": 2,
        "Instruction": "Get the version of the module library.",
        "A": "GetLibVersion()",
        "B": "GetLibraryVersion()",
        "C": "GetStatus(channel)",
        "D": "SetLogOption(channel, pOption)",
        "Answer(s)": "A"
    },
    {
        "No": 3,
        "Instruction": "Return TRUE if this class object has access to a device, and FALSE otherwise. A device is required to execute most functions in this class. If this function returns FALSE, a device can be created by calling the CreateDevice function from the WMX3Api object that was passed to the constructor of this class.",
        "A": "IsDeviceValid()",
        "B": "EndRecordBufferChannel()",
        "C": "OverridePos(pPosCommand)",
        "D": "IsValidDevice()",
        "Answer(s)": "A"
    },
    {
        "No": 4,
        "Instruction": "Get the version of the module rtdll.",
        "A": "FlowIf(condition)",
        "B": "FetchVersionInfo()",
        "C": "GetApiLogData_ApiLogInfo(pFile, buffSize)",
        "D": "GetVersion()",
        "Answer(s)": "D"
    },
    {
        "No": 5,
        "Instruction": "Create a memory space for use with the API buffer. This function must be called before the API buffer functions can be used.",
        "A": "CreateApiBuffer(channel, size)",
        "B": "FreeApiBuffer(channel)",
        "C": "FlowElse()",
        "D": "InitializeApiBuffer(channel_name, buffer_size)",
        "Answer(s)": "A"
    },
    {
        "No": 6,
        "Instruction": "Create a memory space for use with the API buffer using the default memory size.",
        "A": "GetOutputData(buff, buffSize, dataSize)",
        "B": "FreeSplineBuffer(channel)",
        "C": "ModifyApiBuffer(channel)",
        "D": "CreateApiBuffer(channel)",
        "Answer(s)": "D"
    },
    {
        "No": 7,
        "Instruction": "Create a memory space for use with the API buffer. The size of the memory space can be specified in one of several units.",
        "A": "Wait_AxisSel(pAxisSelection)",
        "B": "UpdateApiBufferParameters(endpoint, bufferSize, units)",
        "C": "CreateApiBuffer(channel, size, sizeUnit)",
        "D": "CreateApiBuffer(channel, size)",
        "Answer(s)": "C"
    },
    {
        "No": 8,
        "Instruction": "Close an API buffer memory space",
        "A": "FreeChannelBuffer(api)",
        "B": "FreeApiBuffer(channel)",
        "C": "CreateApiBuffer(channel)",
        "D": "CreateApiBuffer(channel, size)",
        "Answer(s)": "B"
    },
    {
        "No": 9,
        "Instruction": "Start recording APIs to the API buffer channel.",
        "A": "StartChannelBufferRecording(channel)",
        "B": "Sleep(milliseconds)",
        "C": "StartRecordBufferChannel(channel)",
        "D": "CloseMemoryLogBuffer(channel)",
        "Answer(s)": "C"
    },
    {
        "No": 10,
        "Instruction": "End recording APIs to the API buffer channel.",
        "A": "Clear(channel)",
        "B": "EndRecordBufferChannel()",
        "C": "OpenMemoryLogBuffer(channel)",
        "D": "EndRecordBufferChannelV2()",
        "Answer(s)": "B"
    },
    {
        "No": 11,
        "Instruction": "Get the currently recording API buffer channel, if any",
        "A": "OpenMemoryLogBuffer(channel)",
        "B": "EndRecordBufferChannel()",
        "C": "GetRecordingBufferChannel()",
        "D": "GetRecordingBufferChannel(int channelIndex)",
        "Answer(s)": "C"
    },
    {
        "No": 12,
        "Instruction": "Execute an API buffer.",
        "A": "GetECAM(channel)",
        "B": "performTask(task_channel)",
        "C": "Execute(channel)",
        "D": "Wait_ApiBufferCondition(condition)",
        "Answer(s)": "C"
    },
    {
        "No": 13,
        "Instruction": "Halt an API buffer.",
        "A": "FlowIf(condition)",
        "B": "Terminate(channel)",
        "C": "StartLog(channel)",
        "D": "Halt(channel)",
        "Answer(s)": "D"
    },
    {
        "No": 14,
        "Instruction": "Clear an API buffer.",
        "A": "Clear(channel)",
        "B": "Rewind(channel)",
        "C": "ClearChannel(channel)",
        "D": "Halt(channel)",
        "Answer(s)": "A"
    },
    {
        "No": 15,
        "Instruction": "Rewind an API buffer.",
        "A": "Rewind(channel)",
        "B": "ReplayPrevious(channel)",
        "C": "SetOutputData(moduleId, data, dataSize)",
        "D": "GetOptions(channel)",
        "Answer(s)": "A"
    },
    {
        "No": 16,
        "Instruction": "Get the current status of an API buffer.",
        "A": "GetWatch(channel)",
        "B": "GetOutputModuleId()",
        "C": "CheckChannelStatus(channel_id)",
        "D": "GetStatus(channel)",
        "Answer(s)": "D"
    },
    {
        "No": 17,
        "Instruction": "Set options for an API buffer.",
        "A": "SetOptions(channel, pOptions)",
        "B": "SetChannelOptions(channel, options)",
        "C": "Execute(channel)",
        "D": "SetLogOption(channel, pOption)",
        "Answer(s)": "A"
    },
    {
        "No": 18,
        "Instruction": "Get the currently applied options for an API buffer.",
        "A": "GetChannelOptions(channel_id)",
        "B": "GetOptions(channel)",
        "C": "StartRecordBufferChannel(channel)",
        "D": "GetLogOption(channel)",
        "Answer(s)": "B"
    },
    {
        "No": 19,
        "Instruction": "Set watch options for an API buffer. The watch function will stop the buffer execution when an error is detected.",
        "A": "SetWatchChannel(channelID, watchObject)",
        "B": "SetWatchdog(deviceId, watchdog)",
        "C": "SetWatch(channel, pWatch)",
        "D": "EndRecordBufferChannel()",
        "Answer(s)": "C"
    },
    {
        "No": 20,
        "Instruction": "Get watch options for an API buffer. The watch function will stop the buffer execution when an error is detected.",
        "A": "CreateApiBuffer(channel)",
        "B": "GetECAM(channel)",
        "C": "GetChannelWatch(channel_id)",
        "D": "GetWatch(channel)",
        "Answer(s)": "D"
    },
    {
        "No": 21,
        "Instruction": "Add a sleep command to an API buffer.",
        "A": "Wait_ApiBufferCondition(condition)",
        "B": "SleepForDuration(duration)",
        "C": "SimulatePos(pSimulatePosCommand)",
        "D": "Sleep(milliseconds)",
        "Answer(s)": "D"
    },
    {
        "No": 22,
        "Instruction": "Add a wait command to an API buffer.",
        "A": "Wait(axis)",
        "B": "IsDeviceValid()",
        "C": "WaitForAxis(int axis)",
        "D": "Wait(int axis)",
        "Answer(s)": "D"
    },
    {
        "No": 23,
        "Instruction": "Add a wait command to an API buffer.",
        "A": "Wait_AxisSel(pAxisSelection)",
        "B": "GetOutputModuleId()",
        "C": "Pause_AxisSel(pAxisSelection)",
        "D": "Wait_AxisSelection(pAxes)",
        "Answer(s)": "A"
    },
    {
        "No": 24,
        "Instruction": "Add a wait command to an API buffer.",
        "A": "Wait_ApiBufferConditionWithTimeout(condition, timeout)",
        "B": "Wait_ApiBufferCondition(condition)",
        "C": "CreateApiBuffer(channel, size, sizeUnit)",
        "D": "Wait_WaitCondition(pWaitCondition)",
        "Answer(s)": "B"
    },
    {
        "No": 25,
        "Instruction": "Add an If command to an API buffer.",
        "A": "FlowIf(condition)",
        "B": "ApiLogToString(pLogData, logDataSize)",
        "C": "StopCommunication()",
        "D": "CheckConditionFlowIf(condition)",
        "Answer(s)": "A"
    },
    {
        "No": 26,
        "Instruction": "Add an Else If command to an API buffer.",
        "A": "FlowElseIf(condition)",
        "B": "GetOutputModuleId()",
        "C": "FlowIfElse(condition)",
        "D": "FlowEndIf()",
        "Answer(s)": "A"
    },
    {
        "No": 27,
        "Instruction": "Add an Else command to an API buffer.",
        "A": "ReleaseEStop()",
        "B": "FlowIfElse()",
        "C": "FlowElse()",
        "D": "Sleep(milliseconds)",
        "Answer(s)": "C"
    },
    {
        "No": 28,
        "Instruction": "Add an End If command to an API buffer.",
        "A": "FlowElseIf(condition)",
        "B": "Execute(channel)",
        "C": "FlowEndIf()",
        "D": "FlowEndIf(condition: bool)",
        "Answer(s)": "C"
    },
    {
        "No": 29,
        "Instruction": "Get a string representation of the specified error code.",
        "A": "ErrorToString(errCode)",
        "B": "IsDeviceValid()",
        "C": "ConvertErrorCodeToString(code)",
        "D": "EnablePitchErrorCompensation(axis)",
        "Answer(s)": "A"
    },
    {
        "No": 30,
        "Instruction": "Get a string representation of the raw data of an API log.",
        "A": "SetEventInput(id, pEventInput)",
        "B": "ApiLogDataToString(logData, dataSize)",
        "C": "GetLibVersion()",
        "D": "ApiLogToString(pLogData, logDataSize)",
        "Answer(s)": "D"
    },
    {
        "No": 31,
        "Instruction": "Get the version of the module library.",
        "A": "GetLibVersion()",
        "B": "GetLibraryVersion()",
        "C": "SetBacklashCompensation(axis, pBacklashCompData)",
        "D": "StartAxisHM(slaveId, axisIndex, method, switchSpeed, zeroSpeed, hmAcc)",
        "Answer(s)": "A"
    },
    {
        "No": 32,
        "Instruction": "Return TRUE if this class object has access to a device, and FALSE otherwise. A device is required to execute most functions in this class. If this function returns FALSE, a device can be created by calling the CreateDevice function from the WMX3Api object that was passed to the constructor of this class.",
        "A": "EnableBacklashCompensation(axis)",
        "B": "IsDeviceValid()",
        "C": "SetOutBytesEx(addr, size, pData)",
        "D": "isValidDevice()",
        "Answer(s)": "B"
    },
    {
        "No": 33,
        "Instruction": "Get the version of the module rtdll.",
        "A": "GetVersion()",
        "B": "ErrorToString(errCode)",
        "C": "Get2DPitchErrorCompensationAtPosition(channel, refPos1, refPos2)",
        "D": "GetSoftwareVersion()",
        "Answer(s)": "A"
    },
    {
        "No": 34,
        "Instruction": "Set pitch error compensation parameters.",
        "A": "SetPitchErrorCompensation(axis, pitchErrCompData)",
        "B": "GetPitchErrorCompensationAtPosition(axis, pos)",
        "C": "SetPitchErrorCompensationParameters(axis, pitchErrCompData)",
        "D": "Set2DPitchErrorCompensation_FreePosition(channel, pitchErrCompData2D)",
        "Answer(s)": "A"
    },
    {
        "No": 35,
        "Instruction": "Set free position mode pitch error compensation parameters.",
        "A": "EnablePitchErrorCompensation(axis)",
        "B": "SetPitchErrorCompensation_FreePosition(axis, pitchErrCompData)",
        "C": "GetPitchErrorCompensation_FreePosition(axis)",
        "D": "SetPitchErrorCompensation(axis, pitchErrorCompensationData)",
        "Answer(s)": "B"
    },
    {
        "No": 36,
        "Instruction": "Get pitch error compensation parameters.",
        "A": "GetLibVersion()",
        "B": "DisablePitchErrorCompensation(axis)",
        "C": "GetPitchErrorCompensation(axis)",
        "D": "GetPitchErrorCompensation(axis_name)",
        "Answer(s)": "C"
    },
    {
        "No": 37,
        "Instruction": "Get free position mode pitch error compensation parameters.",
        "A": "Get2DPitchErrorCompensation_FreePosition(channel)",
        "B": "DisableBacklashCompensation(axis)",
        "C": "GetPitchErrorCompensation_FreePosition(axis)",
        "D": "EstimatePitchErrorCompensation_AxisPosition(axis)",
        "Answer(s)": "C"
    },
    {
        "No": 38,
        "Instruction": "Enable pitch error compensation.",
        "A": "RenewPitchErrorCorrection(axis)",
        "B": "Disable2DPitchErrorCompensation(channel)",
        "C": "EnablePitchErrorCompensation(axis)",
        "D": "EnableBacklashCompensation(axis)",
        "Answer(s)": "C"
    },
    {
        "No": 39,
        "Instruction": "Disable pitch error compensation.",
        "A": "DisablePitchCompensation(axis)",
        "B": "EnablePitchErrorCompensation(axis)",
        "C": "EnablePitchErrorCompensation(axis)",
        "D": "DisablePitchErrorCompensation(axis)",
        "Answer(s)": "D"
    },
    {
        "No": 40,
        "Instruction": "Obtain the pitch error compensation amount at the specified position.",
        "A": "Get2DPitchErrorCompensation_FreePosition(channel)",
        "B": "GetPitchErrorCompensationAtPosition(axis, pos)",
        "C": "GetPitchErrorCompensationValue(axis, position)",
        "D": "ErrorToString(errCode)",
        "Answer(s)": "B"
    },
    {
        "No": 41,
        "Instruction": "Set two-dimensional (2D) pitch error compensation parameters.",
        "A": "Set2DPitchErrorCompensation(channel, pitchErrCompData2D)",
        "B": "ApiLogToString(pLogData, logDataSize)",
        "C": "Set2DPitchErrorCompensation(channelNumber, pitchErrorDataMatrix)",
        "D": "SetPitchErrorCompensation(axis, pitchErrCompData)",
        "Answer(s)": "A"
    },
    {
        "No": 42,
        "Instruction": "Set free position two-dimensional (2D) pitch error compensation parameters.",
        "A": "GetPitchErrorCompensation(axis)",
        "B": "Set2DPitchErrorCompensation_FreePosition(channel, pitchErrCompData2D)",
        "C": "Set2DPitchErrorCompensationByPosition(channel, pitchErrCompData2D)",
        "D": "SetPitchErrorCompensation_FreePosition(axis, pitchErrCompData)",
        "Answer(s)": "B"
    },
    {
        "No": 43,
        "Instruction": "Get two-dimensional (2D) pitch error compensation parameters.",
        "A": "DisableBacklashCompensation(axis)",
        "B": "Disable2DPitchErrorCompensation(channel)",
        "C": "Get2DPitchErrorCorrection(channel)",
        "D": "Get2DPitchErrorCompensation(channel)",
        "Answer(s)": "D"
    },
    {
        "No": 44,
        "Instruction": "Get free position two-dimensional (2D) pitch error compensation parameters.",
        "A": "GetPitchErrorCompensation(axis)",
        "B": "Get2DPitchErrorCompensationAtPosition(channel, refPos1, refPos2)",
        "C": "Get2DPitchErrorCompensation_FreePosition(channel)",
        "D": "Get2DPitchErrorCompensation(channel, position)",
        "Answer(s)": "C"
    },
    {
        "No": 45,
        "Instruction": "Enable two-dimensional (2D) pitch error compensation.",
        "A": "Disable2DPitchErrorCompensation(channel)",
        "B": "Disable2DPitchErrorCompensation(channel)",
        "C": "Update2DPitchErrorCompensation(channel)",
        "D": "Enable2DPitchErrorCompensation(channel)",
        "Answer(s)": "D"
    },
    {
        "No": 46,
        "Instruction": "Disable two-dimensional (2D) pitch error compensation.",
        "A": "GetPitchErrorCompensationAtPosition(axis, pos)",
        "B": "Disable2DPitchErrorCompensation(channel)",
        "C": "Get2DPitchErrorCompensation_FreePosition(channel)",
        "D": "disable_2d_pitch_error_compensation(channel_id):",
        "Answer(s)": "B"
    },
    {
        "No": 47,
        "Instruction": "Obtain the two-dimensional (2D) pitch error compensation amount at the specified position.",
        "A": "Get2DPitchErrorAtPosition(channel, position1, position2)",
        "B": "Get2DPitchErrorCompensationAtPosition(channel, refPos1, refPos2)",
        "C": "Get2DPitchErrorCompensation(channel)",
        "D": "Disable2DPitchErrorCompensation(channel)",
        "Answer(s)": "B"
    },
    {
        "No": 48,
        "Instruction": "Set backlash compensation parameters.",
        "A": "SetBacklashCompensationParams(axis, pBacklashCompData)",
        "B": "SetBacklashCompensation(axis, pBacklashCompData)",
        "C": "Set2DPitchErrorCompensation(channel, pitchErrCompData2D)",
        "D": "DisableBacklashCompensation(axis)",
        "Answer(s)": "B"
    },
    {
        "No": 49,
        "Instruction": "Get backlash compensation parameters.",
        "A": "Set2DPitchErrorCompensation_FreePosition(channel, pitchErrCompData2D)",
        "B": "EnableBacklashCompensation(axis)",
        "C": "ApplyBacklashCompensation(axis)",
        "D": "GetBacklashCompensation(axis)",
        "Answer(s)": "D"
    },
    {
        "No": 50,
        "Instruction": "Enable backlash compensation.",
        "A": "EnableCompensateBacklash(axis)",
        "B": "SetBacklashCompensation(axis, pBacklashCompData)",
        "C": "EnableBacklashCompensation(axis)",
        "D": "DisableBacklashCompensation(axis)",
        "Answer(s)": "C"
    },
    {
        "No": 51,
        "Instruction": "Disable backlash compensation.",
        "A": "CancelBacklashCompensation(axis)",
        "B": "ErrorToString(errCode)",
        "C": "DisableBacklashCompensation(axis)",
        "D": "EnablePitchErrorCompensation(axis)",
        "Answer(s)": "C"
    },
    {
        "No": 52,
        "Instruction": "Get a string representation of the specified error code.",
        "A": "StartVT(pVTCommand)",
        "B": "Import_AxisPrm_Axis(pPath, axis, copyParamToAxes)",
        "C": "ErrorMessage(errCode)",
        "D": "ErrorToString(errCode)",
        "Answer(s)": "D"
    },
    {
        "No": 53,
        "Instruction": "Get a string representation of the raw data of an API log.",
        "A": "ExecTimedStop_AxisSel(pAxisSelection, timeMilliseconds)",
        "B": "ApiLogDataToString(logData, dataSize)",
        "C": "ApiLogToString(pLogData, logDataSize)",
        "D": "OverrideDec(pPosCommand)",
        "Answer(s)": "C"
    },
    {
        "No": 54,
        "Instruction": "Get the version of the module library.",
        "A": "GetLibVersionInfo()",
        "B": "StartTrqToMov_TriggerEvents(pPosCommand, pTriggerEvents)",
        "C": "ClearAxisAlarm(axis)",
        "D": "GetLibVersion()",
        "Answer(s)": "D"
    },
    {
        "No": 55,
        "Instruction": "Return TRUE if this class object has access to a device, and FALSE otherwise. A device is required to execute most functions in this class. If this function returns FALSE, a device can be created by calling the CreateDevice function from the WMX3Api object that was passed to the constructor of this class.",
        "A": "RemoveAxisFromSyncGroup(groupId, axis)",
        "B": "IsDeviceValid(device_id)",
        "C": "GetOutByteEx(addr)",
        "D": "IsDeviceValid()",
        "Answer(s)": "D"
    },
    {
        "No": 56,
        "Instruction": "Get the version of the module rtdll.",
        "A": "GetVersion()",
        "B": "SetOutBits(pByte, pBit, pData, count)",
        "C": "StartMov(pPosCommand)",
        "D": "FetchVersionInfo()",
        "Answer(s)": "A"
    },
    {
        "No": 57,
        "Instruction": "Read the current system status from the engine.",
        "A": "SetAbsoluteEncoderHomeOffset(axis, offset)",
        "B": "CheckConnectionStatus()",
        "C": "GetStatistic()",
        "D": "GetStatus()",
        "Answer(s)": "D"
    },
    {
        "No": 58,
        "Instruction": "Initiate an emergency stop to stop the motion of all axes.",
        "A": "ExecStartEmergencyStop(priorityLevel)",
        "B": "StartCircularIntplMov_ThroughAndEnd(pCircularIntplCommand)",
        "C": "ExecEStop(level)",
        "D": "ExecQuickStop(axis)",
        "Answer(s)": "C"
    },
    {
        "No": 59,
        "Instruction": "Clear the emergency stop state to allow the axes to be controlled again.",
        "A": "ReleaseStdOut()",
        "B": "ReleaseEStop()",
        "C": "ReleaseSafetyStop()",
        "D": "StartLinearIntplMov_TriggerEvents(pLinearIntplCommand, pTriggerEvents)",
        "Answer(s)": "B"
    },
    {
        "No": 60,
        "Instruction": "Trigger the flight recorder to write the flight recorder data to file.",
        "A": "RecordFlightData()",
        "B": "TriggerFlightRecorder()",
        "C": "GetFlightRecorderParam()",
        "D": "Resume_AxisSel(pAxisSelection)",
        "Answer(s)": "B"
    },
    {
        "No": 61,
        "Instruction": "Reset the flight recorder so that it may be triggered again.",
        "A": "ClearFlightDataRecorder()",
        "B": "SetFlightRecorderParam(axis, pParam)",
        "C": "ResetFlightRecorder()",
        "D": "StartMov_Trigger(pPosCommand)",
        "Answer(s)": "C"
    },
    {
        "No": 62,
        "Instruction": "Return TRUE if this class object has access to a device, and FALSE otherwise. A device is required to execute most functions in this class. If this function returns FALSE, a device can be created by calling the CreateDevice function from the WMX3Api object that was passed to the constructor of this class.",
        "A": "CheckDeviceValidity()",
        "B": "StartHelicalIntplPos_Trigger(pHelicalIntplCommand, pTrigger)",
        "C": "IsDeviceValid()",
        "D": "GetInputModuleId()",
        "Answer(s)": "C"
    },
    {
        "No": 63,
        "Instruction": "Start an absolute position command.",
        "A": "StartPos(pPosCommand)",
        "B": "OverrideDec(pPosCommand)",
        "C": "StartPosition(pPositionCommand)",
        "D": "StopJogAtPos(pPosCommand)",
        "Answer(s)": "A"
    },
    {
        "No": 64,
        "Instruction": "Start a relative position command.",
        "A": "StartLinearIntplMov_Trigger(pLinearIntplCommand, pTrigger)",
        "B": "StartMovToJog(pPosToJogCommand)",
        "C": "MoveStart(pStartPosition)",
        "D": "StartMov(pPosCommand)",
        "Answer(s)": "D"
    },
    {
        "No": 65,
        "Instruction": "Start an absolute triggered position command.",
        "A": "newStartPos_Trigger(pCmdPosition)",
        "B": "StartPos_Trigger(pPosCommand)",
        "C": "StartCircularIntplMov_LengthAndEnd(pCircularIntplCommand)",
        "D": "StartMov_Trigger(pPosCommand)",
        "Answer(s)": "B"
    },
    {
        "No": 66,
        "Instruction": "Start a relative triggered position command.",
        "A": "StartVelToMov(pTriggerPosCommand)",
        "B": "ActionTrigger_Start(pCommandPos)",
        "C": "StartMov_Trigger(pPosCommand)",
        "D": "StartVel_TimedVel(numCommands, pTimedVelCommand)",
        "Answer(s)": "C"
    },
    {
        "No": 67,
        "Instruction": "Start an absolute triggered position command with multiple trigger events.",
        "A": "Initialize_PositionAndTrigger(pPositionCommand, pTriggerEvents)",
        "B": "Stop(axis)",
        "C": "StartPos_TriggerEvents(pPosCommand, pTriggerEvents)",
        "D": "StartTrqToPos_TriggerEvents(pPosCommand, pTriggerEvents)",
        "Answer(s)": "C"
    },
    {
        "No": 68,
        "Instruction": "Start a relative triggered position command with multiple trigger events.",
        "A": "OverrideJerkAcc(pPosCommand)",
        "B": "StartTrqToPos_TriggerEvents(pPosCommand, pTriggerEvents)",
        "C": "StartMov_TriggerEvents(pPosCommand, pTriggerEvents)",
        "D": "TriggerEventsOnMovement(pMovementCommand, pTriggerEvents).",
        "Answer(s)": "C"
    },
    {
        "No": 69,
        "Instruction": "Start absolute position commands for multiple axes.",
        "A": "StartCommandExecution(numCommands, initialPosition)",
        "B": "StartCircularIntplMov_RadiusAndEnd_Trigger(pCircularIntplCommand, pTrigger)",
        "C": "StartPos(numCommands, pPosCommand)",
        "D": "StartCoordinatedPos(numCommands, pPosCommand)",
        "Answer(s)": "C"
    },
    {
        "No": 70,
        "Instruction": "Start relative position commands for multiple axes.",
        "A": "StopJogAtPos(numCommands, pPosCommand)",
        "B": "OverrideJerkAcc(pPosCommand)",
        "C": "StartMov(numCommands, pPosCommand)",
        "D": "StartMoving(numCommands, playerPosition)",
        "Answer(s)": "C"
    },
    {
        "No": 71,
        "Instruction": "Start absolute triggered position commands for multiple axes.",
        "A": "StartPos_Trigger(numCommands, pPosCommand)",
        "B": "SetInitialPosition(triggerCount, initialPositionCommand)",
        "C": "StartVelToPos_TriggerEvents(numCommands, pPosCommand, pTriggerEvents)",
        "D": "StopJogAtPos(numCommands, pPosCommand)",
        "Answer(s)": "A"
    },
    {
        "No": 72,
        "Instruction": "Start relative triggered position commands for multiple axes.",
        "A": "StopMovementTrigger(numCommands, pausePositionCommand)",
        "B": "StartMov_Trigger(numCommands, pPosCommand)",
        "C": "AddRelativeSyncPhase(slaveAxis, phase, pProfile)",
        "D": "StartMov(numCommands, pPosCommand)",
        "Answer(s)": "B"
    },
    {
        "No": 73,
        "Instruction": "Start absolute triggered position commands with multiple trigger events for multiple axes.",
        "A": "UpdateStartPositionTriggerEvents(numCommands, startingPosCommand, triggerEventsList)",
        "B": "StartPos_TriggerEvents(numCommands, pPosCommand, pTriggerEvents)",
        "C": "StopTrq(axis)",
        "D": "StartVelToMov_TriggerEvents(numCommands, pPosCommand, pTriggerEvents)",
        "Answer(s)": "B"
    },
    {
        "No": 74,
        "Instruction": "Start relative triggered position commands with multiple trigger events for multiple axes.",
        "A": "StartModifiedMov_TriggerEvents(numMovCommands, pPosCommandList, pTriggerEvents)",
        "B": "StartTrqToPos_TriggerEvents(numCommands, pPosCommand, pTriggerEvents)",
        "C": "OverridePos(pPosCommand)",
        "D": "StartMov_TriggerEvents(numCommands, pPosCommand, pTriggerEvents)",
        "Answer(s)": "D"
    },
    {
        "No": 75,
        "Instruction": "Start an absolute position linear interpolation motion command.",
        "A": "StartHelicalIntplMov(pHelicalIntplCommand)",
        "B": "GetEmergencyStopParam()",
        "C": "StartLinearInterpolationPosition(p_linear_interpolation_command)",
        "D": "StartLinearIntplPos(pLinearIntplCommand)",
        "Answer(s)": "D"
    },
    {
        "No": 76,
        "Instruction": "Start a relative position linear interpolation motion command.",
        "A": "StartLinearIntplMov(pLinearIntplCommand)",
        "B": "StartHelicalIntplMov(pHelicalIntplCommand)",
        "C": "StartLinearInterpolatedMovement(pLinearIntplCommand)",
        "D": "StartPVT_Intpl(pPVTCommand, numAddlCommands, PyObject *pPVTAddlCommand)",
        "Answer(s)": "A"
    },
    {
        "No": 77,
        "Instruction": "Start an absolute position triggered linear interpolation motion command.",
        "A": "StartLinearIntplPos_Trigger(pLinearIntplCommand, pTrigger)",
        "B": "StartLinearIntplPos_TriggerWithDelay(pLinearIntplCommand, pTrigger, delayTime)",
        "C": "StartPosToTrq(numCommands, pTriggerTrqCommand)",
        "D": "StartLinearIntplMov_Trigger(pLinearIntplCommand, pTrigger)",
        "Answer(s)": "A"
    },
    {
        "No": 78,
        "Instruction": "Start a relative position triggered linear interpolation motion command.",
        "A": "StartMov(pPosCommand)",
        "B": "StartHelicalIntplMov_Trigger(pHelicalIntplCommand, pTrigger)",
        "C": "StartLinearIntplMov_Trigger(pLinearIntplCommand, pTrigger)",
        "D": "EditLinearIntplMov_Trigger(pLinearIntplCommand, pTrigger)",
        "Answer(s)": "C"
    },
    {
        "No": 79,
        "Instruction": "Start an absolute position triggered linear interpolation motion command with multiple trigger events.",
        "A": "StartLinearIntplPos_TriggerEvents(pLinearIntplCommand, pTriggerEvents)",
        "B": "StartHelicalIntplPos_TriggerEvents(pHelicalIntplCommand, pTriggerEvents)",
        "C": "SuperimposeMov(pPosCommand)",
        "D": "StopLinearIntplPos_TriggerEvents(pLinearIntplCommand, pTriggerEvents)",
        "Answer(s)": "A"
    },
    {
        "No": 80,
        "Instruction": "Start a relative position triggered linear interpolation motion command with multiple trigger events.",
        "A": "StartHelicalIntplMov_TriggerEvents(pHelicalIntplCommand, pTriggerEvents)",
        "B": "RespondToLinearIntplMov_TriggeredEvents(pLinearIntplCmd, pTriggeredEvents)",
        "C": "StartPos(pPosCommand)",
        "D": "StartLinearIntplMov_TriggerEvents(pLinearIntplCommand, pTriggerEvents)",
        "Answer(s)": "D"
    },
    {
        "No": 81,
        "Instruction": "Start a circular interpolation motion command. The arc is specified by the absolute center position of the arc and the arc length.",
        "A": "StartCircularIntplPos_CenterAndLength(pCircularIntplCommand)",
        "B": "StartPosToJog_Trigger(pTriggerJogCommand)",
        "C": "StartCircularIntplPos_LengthAndEnd(pCircularIntplCommand)",
        "D": "StartCircularIntplPos_CenterAndRadius(pCircularIntplCommand)",
        "Answer(s)": "A"
    },
    {
        "No": 82,
        "Instruction": "Start a circular interpolation motion command. The arc is specified by the relative center position of the arc and the arc length.",
        "A": "StopCircularIntplMov_CenterAndLength(pCircularIntplCommand)",
        "B": "GetSingleTurn(axis)",
        "C": "StartCircularIntplMov_CenterAndEnd(pCircularIntplCommand)",
        "D": "StartCircularIntplMov_CenterAndLength(pCircularIntplCommand)",
        "Answer(s)": "D"
    },
    {
        "No": 83,
        "Instruction": "Start a circular interpolation motion command. The arc is specified by the absolute center and end positions of the arc.",
        "A": "StartCircularIntplPos_CenterAndEnd(pCircularIntplSegment)",
        "B": "StartCircularIntplPos_CenterAndEnd(pCircularIntplCommand)",
        "C": "OverrideAcc(pPosCommand)",
        "D": "StartCircularIntplPos_LengthAndEnd(pCircularIntplCommand)",
        "Answer(s)": "B"
    },
    {
        "No": 84,
        "Instruction": "Start a circular interpolation motion command. The arc is specified by the relative center and end positions of the arc.",
        "A": "StartCircularIntplPos_CenterAndLength(pCircularIntplCommand)",
        "B": "StartCircularIntplMov_CenterAndEnd(pCircularIntplCommand)",
        "C": "StartMovToJog(pPosToJogCommand)",
        "D": "UpdateCircularIntplMov_CenterAndEnd(pUpdatedCircularIntplCommand)",
        "Answer(s)": "B"
    },
    {
        "No": 85,
        "Instruction": "Start a circular interpolation motion command. The arc is specified by an absolute through point on the arc that the axes pass through during the interpolation, and the absolute end position of the arc.",
        "A": "EndCircularInterpolation_PositionThroughTo(pCircularInterpolationCommand)",
        "B": "StartCircularIntplPos_ThroughAndEnd3D(pCircularIntplCommand)",
        "C": "StartCircularIntplMov_RadiusAndEnd_Trigger(pCircularIntplCommand, pTrigger)",
        "D": "StartCircularIntplPos_ThroughAndEnd(pCircularIntplCommand)",
        "Answer(s)": "D"
    },
    {
        "No": 86,
        "Instruction": "Start a circular interpolation motion command. The arc is specified by a relative through point on the arc that the axes pass through during the interpolation, and the relative end position of the arc.",
        "A": "StartCircularIntplMotion_ThroughAndUpdate(pCircularIntplCommand)",
        "B": "StartCircularIntplMov_CenterAndEnd(pCircularIntplCommand)",
        "C": "SimulateLinearIntplPos(pSimulateLinearIntplCommand)",
        "D": "StartCircularIntplMov_ThroughAndEnd(pCircularIntplCommand)",
        "Answer(s)": "D"
    },
    {
        "No": 87,
        "Instruction": "Start a circular interpolation motion command. The arc is specified by the arc length and the absolute end position of the arc.",
        "A": "StartPVT(AdvMotion_PVTCommand pPVTCommand)",
        "B": "StartCircularIntplMov_CenterAndEnd(pCircularIntplCommand)",
        "C": "StartCircularIntplPos_LengthAndEnd(pCircularIntplCommand)",
        "D": "EndCircularIntplPos_LengthAndStart(pCircularIntplCommand)",
        "Answer(s)": "C"
    },
    {
        "No": 88,
        "Instruction": "Start a circular interpolation motion command. The arc is specified by the arc length and the relative end position of the arc.",
        "A": "ReleaseEStop()",
        "B": "StartCircularIntplMov_LengthAndEnd(pCircularIntplCommand)",
        "C": "StartCircularIntplMov_CenterAndEnd(pCircularIntplCommand)",
        "D": "ExecuteCircularIntplMov_WithCommandOptions(commandOptions)",
        "Answer(s)": "B"
    },
    {
        "No": 89,
        "Instruction": "Start a circular interpolation motion command. The arc is specified by the arc radius and the absolute end position of the arc.",
        "A": "StopCircularIntplPos_SpeedAndDuration(pCircularIntplCommand)",
        "B": "StartVel_MaxTrq(pVelCommand, maxTrqLimit)",
        "C": "StartCircularIntplPos_CenterAndEnd(pCircularIntplCommand)",
        "D": "StartCircularIntplPos_RadiusAndEnd(pCircularIntplCommand)",
        "Answer(s)": "D"
    },
    {
        "No": 90,
        "Instruction": "Start a circular interpolation motion command. The arc is specified by the arc radius and the absolute end position of the arc.",
        "A": "StartCircularIntplMov_RadiusAndEnd(pCircularIntplCommand)",
        "B": "Import_AxisPrm(pPath)",
        "C": "StartCircularIntplMov_LengthAndEnd(pCircularIntplCommand)",
        "D": "EndCircularIntplMov_RadiusAndFinish(pCircularIntplCommand)",
        "Answer(s)": "A"
    },
    {
        "No": 91,
        "Instruction": "Start a three-dimensional circular interpolation motion command. The arc is specified by an absolute through point on the arc that the axes pass through during the interpolation, and the absolute end position of the arc.",
        "A": "StartCircularIntplPos_ThroughAndEnd(pCircularIntplCommand)",
        "B": "StartCircularIntplPos_ThroughAndEnd3D(pCircularIntplCommand)",
        "C": "InitiateCircularInterpolationAroundEnd3D(pCircularInterpolationCommand)",
        "D": "OverridePos(numCommands, pPosCommand)",
        "Answer(s)": "B"
    },
    {
        "No": 92,
        "Instruction": "Start a three-dimensional circular interpolation motion command. The arc is specified by a relative through point on the arc that the axes pass through during the interpolation, and the relative end position of the arc.",
        "A": "StartCircularIntplMov_ThroughAndEnd3D(pCircularIntplCommand)",
        "B": "InitiateCircularInterpolatedMoveIn3D(pCircularInterpolationSettings)",
        "C": "GetInputModuleId()",
        "D": "StartCircularIntplMov_LengthAndEnd(pCircularIntplCommand)",
        "Answer(s)": "A"
    },
    {
        "No": 93,
        "Instruction": "Start a triggered circular interpolation motion command. The arc is specified by the absolute center position of the arc and the arc length.",
        "A": "StartCircularIntplPos_CenterAndLength_Trigger(pCircularIntplCommand, pTrigger)",
        "B": "StartCircularIntplPos_LengthAndEnd_TriggerEvents(pCircularIntplCommand, pTriggerEvents)",
        "C": "StartCircularIntplPos_CenterAndEnd_Trigger(pCircularIntplCommand, pTrigger)",
        "D": "StartCircularIntplPos_CenterAndLength_Target(pCircularIntplCommand, pTarget)",
        "Answer(s)": "A"
    },
    {
        "No": 94,
        "Instruction": "Start a triggered circular interpolation motion command. The arc is specified by the relative center position of the arc and the arc length.",
        "A": "StartCircularIntplPos_CenterAndLength_Trigger(pCircularIntplCommand, pTrigger)",
        "B": "StartPosToJog_Trigger(pTriggerJogCommand)",
        "C": "StartCircularIntplMov_CenterAndLength_Trigger(pCircularIntplCommand, pTrigger)",
        "D": "StartCircularIntplMov_CenterLength_Trigger(pCircularIntplData, pTrigger)",
        "Answer(s)": "C"
    },
    {
        "No": 95,
        "Instruction": "Start a triggered circular interpolation motion command. The arc is specified by the absolute center and end positions of the arc.",
        "A": "StartCircularIntplPos_CenterAndEnd_Trigger(pCircularIntplCommand, pTrigger)",
        "B": "StartCircularInterpolationWithCenterAndEndTrigger(pCircularInterpolationCommand, pTrigger)",
        "C": "StartCircularIntplPos_LengthAndEnd_Trigger(pCircularIntplCommand, pTrigger)",
        "D": "GetVersion()",
        "Answer(s)": "A"
    },
    {
        "No": 96,
        "Instruction": "Start a triggered circular interpolation motion command. The arc is specified by the relative center and end positions of the arc.",
        "A": "StartCircularIntplPos_CenterAndEnd_Trigger(pCircularIntplCommand, pTrigger)",
        "B": "StartCircularIntplMov_CenterAndEnd(pCircularIntplCommand)",
        "C": "StartCircularIntplMov_CenterAndEnd_Trigger(pCircularCommand, pEndTrigger)",
        "D": "StartCircularIntplMov_CenterAndEnd_Trigger(pCircularIntplCommand, pTrigger)",
        "Answer(s)": "D"
    },
    {
        "No": 97,
        "Instruction": "Start a triggered circular interpolation motion command. The arc is specified by an absolute through point on the arc that the axes pass through during the interpolation, and the absolute end position of the arc.",
        "A": "StartCircularIntplMov_ThroughAndEnd_Trigger(pCircularIntplCommand, pTrigger)",
        "B": "StartCircularIntplPos_ThroughAndEnd_Trigger(pCommand, pTrigger)",
        "C": "OverrideJerkDec(numCommands, pPosCommand)",
        "D": "StartCircularIntplPos_ThroughAndEnd_Trigger(pCircularIntplCommand, pTrigger)",
        "Answer(s)": "D"
    },
    {
        "No": 98,
        "Instruction": "Start a triggered circular interpolation motion command. The arc is specified by a relative through point on the arc that the axes pass through during the interpolation, and the relative end position of the arc.",
        "A": "StartCircularIntplPos_ThroughAndEnd(pCircularIntplCommand)",
        "B": "StartCircularIntplMov_ThroughAndEnd_Trigger(pCircularIntplCommand, pTrigger)",
        "C": "StartCircularIntplMov_StopAtEnd_Trigger(pCircularIntplCommand, pTrigger)",
        "D": "StartCircularIntplMov_ThroughAndEnd3D_Trigger(pCircularIntplCommand, pTrigger)",
        "Answer(s)": "B"
    },
    {
        "No": 99,
        "Instruction": "Start a triggered circular interpolation motion command. The arc is specified by the arc length and the absolute end position of the arc.",
        "A": "StartCircularIntplPos_LengthAndEnd_Trigger(pCmd, pTrig)",
        "B": "StartCircularIntplPos_ThroughAndEnd3D_Trigger(pCircularIntplCommand, pTrigger)",
        "C": "StartCircularIntplPos_LengthAndEnd_Trigger(pCircularIntplCommand, pTrigger)",
        "D": "StartRampRateTrq(pTrqCommand, rampRate)",
        "Answer(s)": "C"
    },
    {
        "No": 100,
        "Instruction": "Start a triggered circular interpolation motion command. The arc is specified by the arc length and the relative end position of the arc.",
        "A": "StartCircularIntplMov_ThroughAndEnd3D_Trigger(pCircularIntplCommand, pTrigger)",
        "B": "StartCircularIntplMov_LengthAndEnd_Trigger(pCircularIntplCommand, pTrigger)",
        "C": "StartCircularInterpolatedMovement_LengthAndEnd_Trigger(pCircularInterpolatedCommand, pTrigger)",
        "D": "StartLinearIntplPos_Trigger(pLinearIntplCommand, pTrigger)",
        "Answer(s)": "B"
    },
    {
        "No": 101,
        "Instruction": "Start a triggered circular interpolation motion command. The arc is specified by the arc radius and the absolute end position of the arc.",
        "A": "StartCircularIntplPos_RadiusAndEnd_Trigger(pCircleInterpolationCmd, pTriggerSignal)",
        "B": "GetPosFeedback(axis)",
        "C": "StartCircularIntplPos_ThroughAndEnd_Trigger(pCircularIntplCommand, pTrigger)",
        "D": "StartCircularIntplPos_RadiusAndEnd_Trigger(pCircularIntplCommand, pTrigger)",
        "Answer(s)": "D"
    },
    {
        "No": 102,
        "Instruction": "Start a triggered circular interpolation motion command. The arc is specified by the arc radius and the relative end position of the arc.",
        "A": "StartCircularInterpolationWithinRadiusAndEndOnTrigger(pCommand, pTrigger)",
        "B": "StartPosToTrq_TriggerEvents(numCommands, pTrqCommand, pTriggerEvents)",
        "C": "StartCircularIntplMov_RadiusAndEnd_Trigger(pCircularIntplCommand, pTrigger)",
        "D": "StartCircularIntplPos_RadiusAndEnd_Trigger(pCircularIntplCommand, pTrigger)",
        "Answer(s)": "C"
    },
    {
        "No": 103,
        "Instruction": "Start a triggered three-dimensional circular interpolation motion command. The arc is specified by an absolute through point on the arc that the axes pass through during the interpolation, and the absolute end position of the arc.",
        "A": "StartCircularIntplPos_LengthAndEnd_Trigger(pCircularIntplCommand, pTrigger)",
        "B": "EndCircularIntplPos_ThroughAndEnd3D_Trigger(pCircularIntplCommand, pTrigger)",
        "C": "StartCircularIntplPos_ThroughAndEnd3D_Trigger(pCircularIntplCommand, pTrigger)",
        "D": "GetSyncGroup(groupId)",
        "Answer(s)": "C"
    },
    {
        "No": 104,
        "Instruction": "Start a triggered three-dimensional circular interpolation motion command. The arc is specified by a relative through point on the arc that the axes pass through during the interpolation, and the relative end position of the arc.",
        "A": "StartCircularIntplMov_ThroughAndEnd3D_Trigger(pCircularIntplCommand, pTrigger)",
        "B": "StartCircularInterpolationMovement_ThroughEndTrigger(pCircularInterpolationCmd, pEndTrigger).",
        "C": "StartCircularIntplPos_ThroughAndEnd3D_Trigger(pCircularIntplCommand, pTrigger)",
        "D": "SetFeedbackParam(axis, pParam)",
        "Answer(s)": "A"
    },
    {
        "No": 105,
        "Instruction": "Start a triggered circular interpolation motion command with multiple trigger events. The arc is specified by the absolute center position of the arc and the arc length.",
        "A": "SetParam(pParam)",
        "B": "StartCircularIntplPos_CenterAndLength_TriggerEvents(pCircularIntplCommand, pTriggerEvents)",
        "C": "StartCircularInterpolation_CenterLength_TriggerEvents(pInterpolationCommand, pTriggerEvents)",
        "D": "StartCircularIntplMov_CenterAndEnd_TriggerEvents(pCircularIntplCommand, pTriggerEvents)",
        "Answer(s)": "B"
    },
    {
        "No": 106,
        "Instruction": "Start a triggered circular interpolation motion command with multiple trigger events. The arc is specified by the relative center position of the arc and the arc length.",
        "A": "StartCircularIntplPos_CenterAndEnd(pCircularIntplCommand)",
        "B": "StartCircularIntplMov_CenterAndLength_TriggerEvents(pCircularIntplCommand, pTriggerEvents)",
        "C": "UpdateCircularIntplMov_CenterAndLength_TriggerEvents(pCommand, pEvents)",
        "D": "StartCircularIntplMov_CenterAndEnd_TriggerEvents(pCircularIntplCommand, pTriggerEvents)",
        "Answer(s)": "B"
    },
    {
        "No": 107,
        "Instruction": "Start a triggered circular interpolation motion command with multiple trigger events. The arc is specified by the absolute center and end positions of the arc.",
        "A": "StartCircularIntplPos_LengthAndEnd_TriggerEvents(pCircularIntplCommand, pTriggerEvents)",
        "B": "ReleaseEStop()",
        "C": "StartCircularIntplPos_CenterAndEnd_TriggerEvents(command, triggerEvents)",
        "D": "StartCircularIntplPos_CenterAndEnd_TriggerEvents(pCircularIntplCommand, pTriggerEvents)",
        "Answer(s)": "D"
    },
    {
        "No": 108,
        "Instruction": "Start a triggered circular interpolation motion command with multiple trigger events. The arc is specified by the relative center and end positions of the arc.",
        "A": "StartCircularIntplMov_CenterAndEnd_TriggerEvents(pCircularIntplCommand, pTriggerEvents)",
        "B": "StartCircularIntplMov_TriggerEventsCenterAndEnd(pCircularIntplCommand, pTriggerEvents)",
        "C": "IsDeviceValid()",
        "D": "StartCircularIntplMov_LengthAndEnd_TriggerEvents(pCircularIntplCommand, pTriggerEvents)",
        "Answer(s)": "A"
    },
    {
        "No": 109,
        "Instruction": "Start a triggered circular interpolation motion command with multiple trigger events. The arc is specified by an absolute through point on the arc that the axes pass through during the interpolation, and the absolute end position of the arc.",
        "A": "StartJog(pJogCommand)",
        "B": "StartCircularIntplPos_ThroughAndEnd_TriggerEvents(pCircularIntplCommand, pTriggerEvents)",
        "C": "UpdateCircularIntplPos_WithTriggerEvents(pCircularIntplCommand, pTriggerEvents)",
        "D": "StartCircularIntplPos_ThroughAndEnd3D_TriggerEvents(pCircularIntplCommand, pTriggerEvents)",
        "Answer(s)": "B"
    },
    {
        "No": 110,
        "Instruction": "Start a triggered circular interpolation motion command with multiple trigger events. The arc is specified by a relative through point on the arc that the axes pass through during the interpolation, and the relative end position of the arc.",
        "A": "StartCircularIntplMov_ThroughAndEnd_TriggerEvents(pCircularIntplCommand, pTriggerEvents)",
        "B": "StartCircularIntplMov_ThroughAndEnd3D_TriggerEvents(pCircularIntplCommand, pTriggerEvents)",
        "C": "SetHomeDone(axis, value)",
        "D": "StartCircularInterpolationWithTriggerEvents(commandParameters, triggerEvents)",
        "Answer(s)": "A"
    },
    {
        "No": 111,
        "Instruction": "Start a triggered circular interpolation motion command with multiple trigger events. The arc is specified by the arc length and the absolute end position of the arc.",
        "A": "StartCircularInterpolation_LoopAndExecute_TriggerEvents(pCircularInterpolation, pTriggerEvents)",
        "B": "StartJog_TimedJog(numCommands, pTimedJogCommand)",
        "C": "StartCircularIntplPos_LengthAndEnd_TriggerEvents(pCircularIntplCommand, pTriggerEvents)",
        "D": "StartCircularIntplPos_ThroughAndEnd_TriggerEvents(pCircularIntplCommand, pTriggerEvents)",
        "Answer(s)": "C"
    },
    {
        "No": 112,
        "Instruction": "Start a triggered circular interpolation motion command with multiple trigger events. The arc is specified by the arc length and the relative end position of the arc.",
        "A": "StartCircularIntplMov_ThroughAndEnd3D_TriggerEvents(pCircularIntplCommand, pTriggerEvents)",
        "B": "BeginCircularInterpolatedMovement_WithLengthAndStopTrigger(pCircularInterpolationCommand, pStopTriggerEvents)",
        "C": "StartCircularIntplMov_LengthAndEnd_TriggerEvents(pCircularIntplCommand, pTriggerEvents)",
        "D": "StartPosToVel_TriggerVel(pTriggerVelCommand)",
        "Answer(s)": "C"
    },
    {
        "No": 113,
        "Instruction": "Start a triggered circular interpolation motion command with multiple trigger events. The arc is specified by the arc radius and the absolute end position of the arc.",
        "A": "StartCircularIntplPos_CenterAndEnd_TriggerEvents(pCircularIntplCommand, pTriggerEvents)",
        "B": "StartCircularIntplPos_RadiusAndEnd_TriggerEvents(pCircularIntplCommand, pTriggerEvents)",
        "C": "StartCircularInterpolation_Pos_Radius_AndEnd_WatchdogEvents(pCircularInterpolationCommand, pWatchdogEvents)",
        "D": "StartCircularIntplPos_LengthAndEnd(pCircularIntplCommand)",
        "Answer(s)": "B"
    },
    {
        "No": 114,
        "Instruction": "Start a triggered circular interpolation motion command with multiple trigger events. The arc is specified by the arc radius and the relative end position of the arc.",
        "A": "StartCircularIntplMov_LengthAndEnd_TriggerEvents(pCircularIntplCommand, pTriggerEvents)",
        "B": "ExecTimedStop_TimeCmd(numCommands, pTimeCommand)",
        "C": "startCircularInterpolationWithRadiusAndTriggers(pCircularInterpolationCommand, pTriggerEvents)",
        "D": "StartCircularIntplMov_RadiusAndEnd_TriggerEvents(pCircularIntplCommand, pTriggerEvents)",
        "Answer(s)": "D"
    },
    {
        "No": 115,
        "Instruction": "Start a three-dimensional triggered circular interpolation motion command with multiple trigger events. The arc is specified by an absolute through point on the arc that the axes pass through during the interpolation, and the absolute end position of the arc.",
        "A": "StartCircularIntplPos_ThroughAndEnd3D_TriggerEvents(pCircularIntplCommand, pTriggerEvents)",
        "B": "StartIntplPos_ThroughEnd3D_TriggerEvents(pInterpolatedPosCommand, pEventTriggers)",
        "C": "SetAxisParam_Axis(axis, pParam)",
        "D": "StartCircularIntplMov_ThroughAndEnd3D_TriggerEvents(pCircularIntplCommand, pTriggerEvents)",
        "Answer(s)": "A"
    },
    {
        "No": 116,
        "Instruction": "Start a three-dimensional triggered circular interpolation motion command with multiple trigger events. The arc is specified by a relative through point on the arc that the axes pass through during the interpolation, and the relative end position of the arc.",
        "A": "StartCircularIntplMov_LengthAndEnd_TriggerEvents(pCircularIntplCommand, pTriggerEvents)",
        "B": "StartCircularIntplMov_ThroughAndEnd3D_TriggerEvents(pCircularIntplCommand, pTriggerEvents)",
        "C": "Stop_Dec(axis, dec)",
        "D": "StartCircularIntplMov_WithEvents3D_Trigger(pCircularIntplCommand, pEventsTrigger)",
        "Answer(s)": "B"
    },
    {
        "No": 117,
        "Instruction": "Start a helical interpolation motion command. The helix is specified by the absolute center position of the helix, the rotation amount in degrees, and the absolute end position of the linear axis.",
        "A": "StartLinearIntplPos(pLinearIntplCommand)",
        "B": "StartTrq(numCommands, pTrqCommand)",
        "C": "StartHelicalInterpolationPosition(pHelicalInterpolationParams)",
        "D": "StartHelicalIntplPos(pHelicalIntplCommand)",
        "Answer(s)": "D"
    },
    {
        "No": 118,
        "Instruction": "Start a helical interpolation motion command. The helix is specified by the relative center position of the helix, the rotation amount in degrees, and the relative end position of the linear axis.",
        "A": "SetSyncGearRatio(masterAxis, slaveAxis, gearRatio, pProfile)",
        "B": "StartHelicalInterpolatedMovement(helical_interpolation_command):",
        "C": "StartLinearIntplMov(pLinearIntplCommand)",
        "D": "StartHelicalIntplMov(pHelicalIntplCommand)",
        "Answer(s)": "D"
    },
    {
        "No": 119,
        "Instruction": "Start a triggered helical interpolation motion command. The helix is specified by the absolute center position of the helix, the rotation amount in degrees, and the absolute end position of the linear axis.",
        "A": "StartHelicalIntplMov_Trigger(pHelicalIntplCommand, pTrigger)",
        "B": "SetupHelicalIntplPos(pHelicalIntplConfig, pTriggerSource)",
        "C": "StartHelicalIntplPos_Trigger(pHelicalIntplCommand, pTrigger)",
        "D": "StartMovToJog(pPosToJogCommand)",
        "Answer(s)": "C"
    },
    {
        "No": 120,
        "Instruction": "Start a triggered helical interpolation motion command. The helix is specified by the relative center position of the helix, the rotation amount in degrees, and the relative end position of the linear axis.",
        "A": "OverrideDec(numCommands, pPosCommand)",
        "B": "StartHelicalIntplMov_Trigger(pHelicalIntplCommand, pTrigger)",
        "C": "TriggerHelicalMovement(pHelicalCommand, pTrigger)",
        "D": "StartLinearIntplPos_Trigger(pLinearIntplCommand, pTrigger)",
        "Answer(s)": "B"
    },
    {
        "No": 121,
        "Instruction": "Start a triggered helical interpolation motion command with multiple trigger events. The helix is specified by the absolute center position of the helix, the rotation amount in degrees, and the absolute end position of the linear axis.",
        "A": "StartMov_Trigger(numCommands, pPosCommand)",
        "B": "StartHelicalIntplPos_TriggerEvents(pHelicalIntplCommand, pTriggerEvents)",
        "C": "StartHelicalInterpolationWithTriggers(pHelicalInterpolationCommand, pTriggerEvents)",
        "D": "StartHelicalIntplMov_TriggerEvents(pHelicalIntplCommand, pTriggerEvents)",
        "Answer(s)": "B"
    },
    {
        "No": 122,
        "Instruction": "Start a triggered helical interpolation motion command with multiple trigger events. The helix is specified by the relative center position of the helix, the rotation amount in degrees, and the relative end position of the linear axis.",
        "A": "StartHelicalInterpolatedMovementWithTriggers(pInterpolatedMovementCommand, pTriggerEvents)",
        "B": "StartHelicalIntplMov_TriggerEvents(pHelicalIntplCommand, pTriggerEvents)",
        "C": "Export_AxisPrm_Axis(pPath, pAxisParam, axis)",
        "D": "StartLinearIntplPos_TriggerEvents(pLinearIntplCommand, pTriggerEvents)",
        "Answer(s)": "B"
    },
    {
        "No": 123,
        "Instruction": "Start an absolute triggered position command for an axis that is currently executing a velocity command.",
        "A": "StartTrqToPos(pTriggerPosCommand)",
        "B": "StartVelToPos(pTriggerPosCommand)",
        "C": "StartTrqToPos(pTriggerPosCommand)",
        "D": "UpdateTriggerPosition(pTriggerPosCommand)",
        "Answer(s)": "B"
    },
    {
        "No": 124,
        "Instruction": "Start a relative triggered position command for an axis that is currently executing a velocity command.",
        "A": "IsDeviceValid()",
        "B": "StartMov_Trigger(pPosCommand)",
        "C": "UpdateCommandedMovement(pTriggerPosition)",
        "D": "StartVelToMov(pTriggerPosCommand)",
        "Answer(s)": "D"
    },
    {
        "No": 125,
        "Instruction": "Start absolute triggered position commands for multiple axes that are currently executing velocity commands.",
        "A": "StartVelToMov(numCommands, pTriggerPosCommand)",
        "B": "UpdateStartVelToPos(numCommands, pStartingPosCmd)",
        "C": "StartVelToPos(numCommands, pTriggerPosCommand)",
        "D": "Import_AxisPrm_Axis(pPath, axis, copyParamToAxes)",
        "Answer(s)": "C"
    },
    {
        "No": 126,
        "Instruction": "Start relative triggered position commands for multiple axes that are currently executing velocity commands.",
        "A": "OverrideVel(numCommands, pVelCommand)",
        "B": "StartVelToMov(numCommands, pTriggerPosCommand)",
        "C": "StartVelToPos(numCommands, pTriggerPosCommand)",
        "D": "StartMovementFromVelocity(numCommands, triggerPositionCommand)",
        "Answer(s)": "B"
    },
    {
        "No": 127,
        "Instruction": "Start an absolute triggered position command for an axis that is currently executing a velocity command. The trigger condition can have multiple trigger events.",
        "A": "StartTrqToPos_TriggerEvents(pPosCommand, pTriggerEvents)",
        "B": "ClearAxisAlarm(axis)",
        "C": "StartVelToPos_TriggerEvents(pPosCommand, pTriggerEvents)",
        "D": "ConvertPosToVel_withTriggers(posCommand, triggerEvents)",
        "Answer(s)": "C"
    },
    {
        "No": 128,
        "Instruction": "Start a relative triggered position command for an axis that is currently executing a velocity command. The trigger condition can have multiple trigger events.",
        "A": "StartPos_TriggerEvents(pPosCommand, pTriggerEvents)",
        "B": "InitializeMotionWithTriggers(pStartPosition, pTriggerEvents)",
        "C": "StartVelToMov_TriggerEvents(pPosCommand, pTriggerEvents)",
        "D": "StartCircularIntplPos_LengthAndEnd_Trigger(pCircularIntplCommand, pTrigger)",
        "Answer(s)": "C"
    },
    {
        "No": 129,
        "Instruction": "Start absolute triggered position commands for multiple axes that are currently executing velocity commands. The trigger conditions can have multiple trigger events.",
        "A": "StartMov_Trigger(pPosCommand)",
        "B": "TransformVelToPos_TriggerEvents(numCommands, pVelCommand, pTriggerEvents)",
        "C": "StartVelToPos_TriggerEvents(numCommands, pPosCommand, pTriggerEvents)",
        "D": "StartTrqToPos_TriggerEvents(numCommands, pPosCommand, pTriggerEvents)",
        "Answer(s)": "C"
    },
    {
        "No": 130,
        "Instruction": "Start relative triggered position commands for multiple axes that are currently executing velocity commands. The trigger conditions can have multiple trigger events.",
        "A": "StartVelToMov_TriggerEvents(numCommands, pPosCommand, pTriggerEvents)",
        "B": "StartMov(pPosCommand)",
        "C": "StartVelToPos_TriggerEvents(numCommands, pPosCommand, pTriggerEvents)",
        "D": "StartVelToMov_TriggerEventsV2(numCommands, posCommands, triggerEvents)",
        "Answer(s)": "A"
    },
    {
        "No": 131,
        "Instruction": "Start an absolute triggered position command for an axis that is currently executing a torque command.",
        "A": "GetFeedbackParam(axis)",
        "B": "StartTrqToPos(pTriggerPosCommand)",
        "C": "ConvertStartTrqToPos(triggerPosition)",
        "D": "StartVelToMov(pTriggerPosCommand)",
        "Answer(s)": "B"
    },
    {
        "No": 132,
        "Instruction": "Start a relative triggered position command for an axis that is currently executing a torque command.",
        "A": "UpdateTrqForMovement(pTriggerPosition)",
        "B": "StartMov_Trigger(pPosCommand)",
        "C": "Export_SysPrm(pPath, pParam)",
        "D": "StartTrqToMov(pTriggerPosCommand)",
        "Answer(s)": "D"
    },
    {
        "No": 133,
        "Instruction": "Start absolute triggered position commands for multiple axes that are currently executing torque commands.",
        "A": "StartTrqToPos(numCommands, pTriggerPosCommand)",
        "B": "StartVT(pVTCommand, numAddlCommands, pVTAddlCommand)",
        "C": "StartVelToPos(numCommands, pTriggerPosCommand)",
        "D": "StartTrqToPosition(numCommands, initialPositionCommand)",
        "Answer(s)": "A"
    },
    {
        "No": 134,
        "Instruction": "Start relative triggered position commands for multiple axes that are currently executing torque commands.",
        "A": "StartMov(numCommands, pPosCommand)",
        "B": "StartTrqToMov(numCommands, pTriggerPosCommand)",
        "C": "InitializeMovementFromPosition(numCommands, initialTriggerPosition)",
        "D": "SetAxisUnit(axis, unit)",
        "Answer(s)": "B"
    },
    {
        "No": 135,
        "Instruction": "Start an absolute triggered position command for an axis that is currently executing a torque command. The trigger condition can have multiple trigger events.",
        "A": "StartPos_TriggerEvents(pPosCommand, pTriggerEvents)",
        "B": "StartTrqToPos_TriggerEvents(pPosCommand, pTriggerEvents)",
        "C": "StartVel_MaxTrq(pVelCommand, maxTrqLimit)",
        "D": "SetPositionAndTriggerEvents(positionValue, triggerEvents)",
        "Answer(s)": "B"
    },
    {
        "No": 136,
        "Instruction": "Start a relative triggered position command for an axis that is currently executing a torque command. The trigger condition can have multiple trigger events.",
        "A": "StopTrq(axis)",
        "B": "StartTrqToMov_TriggerEvents(pPosCommand, pTriggerEvents)",
        "C": "StartPos_TriggerEvents(pPosCommand, pTriggerEvents)",
        "D": "DetectMovementandTriggerEvents(pNewPosition, pTriggerEvents)",
        "Answer(s)": "B"
    },
    {
        "No": 137,
        "Instruction": "Start absolute triggered position commands for multiple axes that are currently executing torque commands. The trigger conditions can have multiple trigger events.",
        "A": "StartMovToJog(numCommands, pPosToJogCommand)",
        "B": "StartTrqToPoint_TriggerEvents(numInputs, pPointInput, pTriggerEvents)",
        "C": "StartVelToMov_TriggerEvents(numCommands, pPosCommand, pTriggerEvents)",
        "D": "StartTrqToPos_TriggerEvents(numCommands, pPosCommand, pTriggerEvents)",
        "Answer(s)": "D"
    },
    {
        "No": 138,
        "Instruction": "Start relative triggered position commands for multiple axes that are currently executing torque commands. The trigger conditions can have multiple trigger events.",
        "A": "StartTorqueToMovement_TriggerEvents(numCommands, positionCommands, triggerEvents)",
        "B": "StartTrqToMov_TriggerEvents(numCommands, pPosCommand, pTriggerEvents)",
        "C": "Cancel(axis)",
        "D": "StartVelToMov_TriggerEvents(numCommands, pPosCommand, pTriggerEvents)",
        "Answer(s)": "B"
    },
    {
        "No": 139,
        "Instruction": "Start a jog command.",
        "A": "StartJog(pJogCommand)",
        "B": "StartJog(numCommands, pJogCommand)",
        "C": "GetHomeParam(axis)",
        "D": "BeginRunning(pRunningCommand)",
        "Answer(s)": "A"
    },
    {
        "No": 140,
        "Instruction": "Start a timed jog command.",
        "A": "Export_AxisPrm(pPath, pAxisParam)",
        "B": "StartJog_TimedJog_v2(pTimedJogCommand)",
        "C": "StartJog_TimedJog(pTimedJogCommand)",
        "D": "StartVel_TimedVel(pTimedVelCommand)",
        "Answer(s)": "C"
    },
    {
        "No": 141,
        "Instruction": "Start jog commands for multiple axes.",
        "A": "StartMovToJog(numCommands, pPosToJogCommand)",
        "B": "BeginJog(numCommands, jogSettings)",
        "C": "StartPosToJog_Trigger(pTriggerJogCommand)",
        "D": "StartJog(numCommands, pJogCommand)",
        "Answer(s)": "D"
    },
    {
        "No": 142,
        "Instruction": "Start timed jog commands for multiple axes.",
        "A": "Pause_AxisSel(pAxisSelection)",
        "B": "StartJog_TimedJog(numCommands, pTimedJogCommand)",
        "C": "StartTimedJog(numCommands, timedJogCommandList)",
        "D": "StartPosToJog_Trigger(numCommands, pTriggerJogCommand)",
        "Answer(s)": "B"
    },
    {
        "No": 143,
        "Instruction": "Start a triggered jog command for an axis that is currently executing a position command.",
        "A": "SendStartPosToJogTrigger(pJogStartPosCommand)",
        "B": "StartPosToJog_Trigger(pTriggerJogCommand)",
        "C": "StartVelToMov_TriggerEvents(pPosCommand, pTriggerEvents)",
        "D": "StartTrqToVel_TriggerVel(pTriggerVelCommand)",
        "Answer(s)": "B"
    },
    {
        "No": 144,
        "Instruction": "Start a triggered jog command for an axis that is currently executing a position command. The trigger condition can have multiple trigger events.",
        "A": "Wait_WaitCondition_TimeMilli(pWaitCondition, waitTimeMilliseconds)",
        "B": "StartPos_Trigger(numCommands, pPosCommand)",
        "C": "StartPosToJog_Trigger(numCommands, pTriggerJogCommand)",
        "D": "StartJog_Trigger(numCommands, pJogTriggerCommand)",
        "Answer(s)": "C"
    },
    {
        "No": 145,
        "Instruction": "Start triggered jog commands for multiple axes that are currently executing position commands.",
        "A": "StartPosToJog_TriggerEvents(pJogCommand, pTriggerEvents)",
        "B": "StartPosToJog_TriggerEvents(numCommands, pJogCommand, pTriggerEvents)",
        "C": "SetNegativeTrqLimit(axis, torque)",
        "D": "InitiateJogWithTriggers(pJogCommand, pTriggerEvents)",
        "Answer(s)": "A"
    },
    {
        "No": 146,
        "Instruction": "Start a triggered jog command for an axis that is currently executing a position command. The trigger condition can have multiple trigger events.",
        "A": "StartPosToJog_TriggerEvents(numJogCommands, pJogCommands, pTriggerEvents)",
        "B": "StartPosToJog_TriggerEvents(numCommands, pJogCommand, pTriggerEvents)",
        "C": "StartPos_TriggerEvents(numCommands, pPosCommand, pTriggerEvents)",
        "D": "ResolveSync(slaveAxis)",
        "Answer(s)": "B"
    },
    {
        "No": 147,
        "Instruction": "Start an absolute position command and a triggered jog command simultaneously. The position command will be overridden by the jog command when the trigger condition is satisfied.",
        "A": "PosToJog_StartPosToJog(pPosToJogCommand)",
        "B": "StartCircularIntplPos_CenterAndLength(pCircularIntplCommand)",
        "C": "StartPosToJog_Trigger(pTriggerJogCommand)",
        "D": "StartPosToJog_PosToJog(pPosToJogCommand)",
        "Answer(s)": "D"
    },
    {
        "No": 148,
        "Instruction": "Start an absolute position command and a triggered jog command simultaneously for multiple axes. The position command will be overridden by the jog command when the trigger condition is satisfied.",
        "A": "StartPosToJog_PosToJogCommands(numCommands, pPosToJogCommands)",
        "B": "StartPosToJog_PosToJog(numCommands, pPosToJogCommand)",
        "C": "StartPosToJog_Trigger(numCommands, pTriggerJogCommand)",
        "D": "SimulateLinearIntplPos(pSimulateLinearIntplCommand)",
        "Answer(s)": "B"
    },
    {
        "No": 149,
        "Instruction": "Start a relative position command and a triggered jog command simultaneously. The position command will be overridden by the jog command when the trigger condition is satisfied.",
        "A": "StartMovToJog(pPosToJogCommand)",
        "B": "StartHelicalIntplPos_TriggerEvents(pHelicalIntplCommand, pTriggerEvents)",
        "C": "MoveToJogStartPosition(pStartPositionToJog)",
        "D": "StartMov_Trigger(pPosCommand)",
        "Answer(s)": "A"
    },
    {
        "No": 150,
        "Instruction": "Start a relative position command and a triggered jog command simultaneously for multiple axes. The position command will be overridden by the jog command when the trigger condition is satisfied.",
        "A": "StartMovToJog(numCommands, pPosToJogCommand)",
        "B": "StartJog(numCommands, pJogCommand)",
        "C": "StartMovementToJog(numCommands, initialPositionToJogFrom)",
        "D": "SyncToJog(slaveAxis)",
        "Answer(s)": "A"
    },
    {
        "No": 151,
        "Instruction": "Stop the motion of an axis.",
        "A": "SetParam_Axis(axis, pParam)",
        "B": "StopEngine(axis)",
        "C": "Stop(axis)",
        "D": "StartHome(axis)",
        "Answer(s)": "C"
    },
    {
        "No": 152,
        "Instruction": "Stop the motion of multiple axes.",
        "A": "StartHome_AxisSel(pAxisSelection)",
        "B": "Stop_AxisSel(pAxisSelection)",
        "C": "StartCircularIntplMov_ThroughAndEnd(pCircularIntplCommand)",
        "D": "Stop_AxisSelection(pSelectedAxis)",
        "Answer(s)": "B"
    },
    {
        "No": 153,
        "Instruction": "Stop the motion of an axis using the specified deceleration and a trapezoidal profile.",
        "A": "Stop_Deceleration(axis, dec)",
        "B": "StartPosToVel_TriggerEvents(pVelCommand, pTriggerEvents)",
        "C": "SetHomeDone(axis, value)",
        "D": "Stop_Dec(axis, dec)",
        "Answer(s)": "D"
    },
    {
        "No": 154,
        "Instruction": "Stop the motion of multiple axes using the specified decelerations and trapezoidal profiles.",
        "A": "StartMovToJog(numCommands, pPosToJogCommand)",
        "B": "Stop_StopCommand(numCommands, pStopCommand)",
        "C": "StopCommand(numCommands, stopCommandParameters)",
        "D": "StartCircularIntplPos_ThroughAndEnd3D(pCircularIntplCommand)",
        "Answer(s)": "B"
    },
    {
        "No": 155,
        "Instruction": "Stop execution of the cyclic position command buffer of an axis and decelerate the axis to a stop using the quick stop deceleration.",
        "A": "Stop(axis)",
        "B": "ExecQuickStop(axis)",
        "C": "ExecQuickStopCommand(axis)",
        "D": "Stop_AxisSel(pAxisSelection)",
        "Answer(s)": "B"
    },
    {
        "No": 156,
        "Instruction": "Stop execution of the cyclic position command buffer of multiple axes and decelerate the axes to a stop using the quick stop deceleration.",
        "A": "Stop_AxisSel(pAxisSelection)",
        "B": "ExecQuickStop_AxisSel(pAxisSelection)",
        "C": "StartVelToTrq_TriggerEvents(pTrqCommand, pTriggerEvents)",
        "D": "ExecuteQuickStop_AxisSelection(axisSelection)",
        "Answer(s)": "B"
    },
    {
        "No": 157,
        "Instruction": "Stop an axis that is currently in motion in the specified amount of time using a trapezoidal profile.",
        "A": "Export_SysPrm_Axis(pPath, pParam, axis)",
        "B": "ExecuteWithTimeout(axis, timeoutMillis)",
        "C": "ExecTimedStop_TimeMilli(axis, timeMilliseconds)",
        "D": "ExecTimedStop_AxisSel(pAxisSelection, timeMilliseconds)",
        "Answer(s)": "C"
    },
    {
        "No": 158,
        "Instruction": "Stop multiple axes that are currently in motion in the specified amount of time using a trapezoidal profile",
        "A": "ExecQuickStop_AxisSel(pAxisSelection)",
        "B": "ExecTimedOperation_AxisSelection(pSelectedAxis, nTimeMs)",
        "C": "ExecTimedStop_AxisSel(pAxisSelection, timeMilliseconds)",
        "D": "GetPVTBytesPerPoint(pBytes)",
        "Answer(s)": "C"
    },
    {
        "No": 159,
        "Instruction": "Stop multiple axes that are currently in motion in the specified amounts of time using a trapezoidal profile.",
        "A": "IsDeviceValid()",
        "B": "ExecTimedStop_TimeCmd(numCommands, pTimeCommand)",
        "C": "StartVel_TimedVel(numCommands, pTimedVelCommand)",
        "D": "ExecuteWithTimeout(numCommands, commandExecutionTime)",
        "Answer(s)": "B"
    },
    {
        "No": 160,
        "Instruction": "Add a wait command to an API buffer.",
        "A": "Wait(axis)",
        "B": "Await(axis_to_wait)",
        "C": "GetOutputData(buff, buffSize, dataSize)",
        "D": "GetAxisUnit(axis)",
        "Answer(s)": "A"
    },
    {
        "No": 161,
        "Instruction": "Add a wait command to an API buffer.",
        "A": "Wait_ForAxisSelection(pAxisSelection)",
        "B": "Wait_AxisSel(pAxisSelection)",
        "C": "SetVelocityFeedforwardGain(axis, gain)",
        "D": "Stop_AxisSel(pAxisSelection)",
        "Answer(s)": "B"
    },
    {
        "No": 162,
        "Instruction": "Start a blocking wait command, returning only when the specified wait condition becomes true.",
        "A": "Wait_ForCondition(pWaitCondition)",
        "B": "WaitForDeviceWaitEvent(waitTime, errCode)",
        "C": "Wait_WaitCondition(pWaitCondition)",
        "D": "Import_SysPrm_AxisPrm_Axis(pPath, axis, copyParamToAxes)",
        "Answer(s)": "C"
    },
    {
        "No": 163,
        "Instruction": "Start a blocking wait command, returning only when the axis becomes idle or the wait time elapses.",
        "A": "ExecTimedStop_TimeMilli(axis, timeMilliseconds)",
        "B": "Export_SysPrm_Axis(pPath, pParam, axis)",
        "C": "Wait_TimeMilli(axis, waitTimeMilliseconds)",
        "D": "Wait_TimeMs(axis, delayMs)",
        "Answer(s)": "C"
    },
    {
        "No": 164,
        "Instruction": "Start a blocking wait command, returning only when the axes become idle.",
        "A": "Wait_AxisSel_TimeMilli(pAxisSelection, waitTimeMilliseconds)",
        "B": "Wait_For_Axis_Selection_Time_in_Milliseconds(AXS_Selection, time_in_ms)",
        "C": "ExecTimedStop_TimeMilli(axis, timeMilliseconds)",
        "D": "StartVT(pVTCommand, numAddlCommands, pVTAddlCommand)",
        "Answer(s)": "A"
    },
    {
        "No": 165,
        "Instruction": "Start a blocking wait command, returning only when the specified wait condition becomes true.",
        "A": "StartVelToPos_TriggerEvents(numCommands, pPosCommand, pTriggerEvents)",
        "B": "WaitForConditionTimeout(pConditionToWaitFor, timeoutMilliseconds)",
        "C": "ExecTimedStop_TimeMilli(axis, timeMilliseconds)",
        "D": "Wait_WaitCondition_TimeMilli(pWaitCondition, waitTimeMilliseconds)",
        "Answer(s)": "D"
    },
    {
        "No": 166,
        "Instruction": "Pause the execution of a position command or interpolation command.",
        "A": "StartPT(pPTCommand)",
        "B": "Execute(axis)",
        "C": "Pause(axis)",
        "D": "PauseAxis(axis_to_pause)",
        "Answer(s)": "C"
    },
    {
        "No": 167,
        "Instruction": "Pause the execution of a position command or interpolation command for multiple axes.",
        "A": "Pause_AxisSel(pAxisSelection)",
        "B": "Wait_AxisSel(pAxisSelection)",
        "C": "StartCircularIntplMov_ThroughAndEnd3D_Trigger(pCircularIntplCommand, pTrigger)",
        "D": "Pause_AxisSel(pSelectedAxis)",
        "Answer(s)": "A"
    },
    {
        "No": 168,
        "Instruction": "Resume the execution of a paused position command or interpolation command.",
        "A": "GetGearRatio(axis)",
        "B": "ResumeProcessingOnAxis(axis)",
        "C": "Execute(axis)",
        "D": "Resume(axis)",
        "Answer(s)": "D"
    },
    {
        "No": 169,
        "Instruction": "Resume the execution of a paused position command or interpolation command for multiple axes.",
        "A": "Resume_AxisSelection(pSelectedAxis)",
        "B": "StopSuperimpose_AxisSel(pAxisSelection)",
        "C": "Resume_AxisSel(pAxisSelection)",
        "D": "Execute_AxisSel(pAxisSelection)",
        "Answer(s)": "C"
    },
    {
        "No": 170,
        "Instruction": "Override the target position of an axis currently executing a position command. The target position is specified as an absolute position",
        "A": "OverridePosition(pPosInput)",
        "B": "OverridePos(pPosCommand)",
        "C": "SetSingleTurn(axis, enable. encoderCount)",
        "D": "OverrideVel(pPosCommand)",
        "Answer(s)": "B"
    },
    {
        "No": 171,
        "Instruction": "Override the target position of an axis currently executing a position command. The target position is specified as a relative position.",
        "A": "ExecEStop(level)",
        "B": "OverrideMovCommand(pPosCommand)",
        "C": "OverrideVel(pPosCommand)",
        "D": "OverrideMov(pPosCommand)",
        "Answer(s)": "D"
    },
    {
        "No": 172,
        "Instruction": "Override the velocity of an axis currently executing a position, jog, or velocity command.",
        "A": "StartLinearIntplPos_Trigger(pLinearIntplCommand, pTrigger)",
        "B": "OverridePos(pPosCommand)",
        "C": "OverrideVel(pPosCommand)",
        "D": "UpdateVel(pPosCommand):",
        "Answer(s)": "C"
    },
    {
        "No": 173,
        "Instruction": "Override the acceleration of an axis currently executing a position, jog, or velocity command",
        "A": "OverrideAcc(pPosCommand)",
        "B": "OverrideMov(pPosCommand)",
        "C": "StartCircularIntplPos_ThroughAndEnd(pCircularIntplCommand)",
        "D": "OverrideAccessPointCommand(pAccessPointCommand)",
        "Answer(s)": "A"
    },
    {
        "No": 174,
        "Instruction": "Override the deceleration of an axis currently executing a position, jog, or velocity command.",
        "A": "GetAxisParam_Axis(axis)",
        "B": "UpdateDec(pUpdatedCommand)",
        "C": "OverrideDec(pPosCommand)",
        "D": "OverrideVel(pPosCommand)",
        "Answer(s)": "C"
    },
    {
        "No": 175,
        "Instruction": "Override the acceleration jerk of an axis currently executing a position, jog, or velocity command.",
        "A": "OverrideVel(pPosCommand)",
        "B": "AdjustJerkAcceleration(pTargetPosition)",
        "C": "OverrideJerkAcc(pPosCommand)",
        "D": "StartHelicalIntplMov_TriggerEvents(pHelicalIntplCommand, pTriggerEvents)",
        "Answer(s)": "C"
    },
    {
        "No": 176,
        "Instruction": "Override the deceleration jerk of an axis currently executing a position, jog, or velocity command.",
        "A": "OverrideJerkDec(pPosCommand)",
        "B": "OverrideJerkDec(pPositionCommand)",
        "C": "OverrideDec(pPosCommand)",
        "D": "StartTrqToVel_TriggerEvents(numCommands, pVelCommand, pTriggerEvents)",
        "Answer(s)": "A"
    },
    {
        "No": 177,
        "Instruction": "Override the entire profile of an axis currently executing a position, jog, or velocity command.",
        "A": "OverrideProfile(pPosCommand)",
        "B": "UpdateUserProfile(userProfileData)",
        "C": "OverrideMov(pPosCommand)",
        "D": "OverrideJerkDec(pPosCommand)",
        "Answer(s)": "A"
    },
    {
        "No": 178,
        "Instruction": "Override the target positions of multiple axes currently executing position commands. The target positions are specified as absolute positions.",
        "A": "OverridePosition(numCommands, newPositionCommand)",
        "B": "Continue(axis)",
        "C": "OverridePos(numCommands, pPosCommand)",
        "D": "OverrideVel(numCommands, pPosCommand)",
        "Answer(s)": "C"
    },
    {
        "No": 179,
        "Instruction": "Override the target positions of multiple axes currently executing position commands. The target positions are specified as relative positions.",
        "A": "OverridePos(numCommands, pPosCommand)",
        "B": "OverrideMov(numCommands, pPosCommand)",
        "C": "StartPosToJog_PosToJog(numCommands, pPosToJogCommand)",
        "D": "ModifyMove(numCommands, newPosition)",
        "Answer(s)": "B"
    },
    {
        "No": 180,
        "Instruction": "Override the velocities of multiple axes currently executing position, jog, or velocity commands.",
        "A": "SetMovingAverageProfileTime(axis, milliseconds)",
        "B": "UpdateVel(numOfCommands, pPositionCommand)",
        "C": "OverrideMov(numCommands, pPosCommand)",
        "D": "OverrideVel(numCommands, pPosCommand)",
        "Answer(s)": "D"
    },
    {
        "No": 181,
        "Instruction": "Override the accelerations of multiple axes currently executing position, jog, or velocity commands.",
        "A": "OverrideAccumulator(numCommands, positionAtIndex)",
        "B": "OverrideMov(numCommands, pPosCommand)",
        "C": "OverrideAcc(numCommands, pPosCommand)",
        "D": "StartRampTimeTrq(pTrqCommand, rampCycleTime, maxMotorSpeed)",
        "Answer(s)": "C"
    },
    {
        "No": 182,
        "Instruction": "Override the decelerations of multiple axes currently executing position, jog, or velocity commands.",
        "A": "OverrideDec(numCommands, pPosCommand)",
        "B": "OverrideDecr(numCommands, firstPositiveCommand)",
        "C": "Stop_StopCommand(numCommands, pStopCommand)",
        "D": "OverrideVel(numCommands, pPosCommand)",
        "Answer(s)": "A"
    },
    {
        "No": 183,
        "Instruction": "Override the acceleration jerks of multiple axes currently executing position, jog, or velocity commands.",
        "A": "updateJerkAcceleration(numUpdates, newJerkValues):",
        "B": "OverrideJerkAcc(numCommands, pPosCommand)",
        "C": "OverridePos(numCommands, pPosCommand)",
        "D": "StopJogAtPos(pPosCommand)",
        "Answer(s)": "B"
    },
    {
        "No": 184,
        "Instruction": "Override the deceleration jerks of multiple axes currently executing position, jog, or velocity commands.",
        "A": "ClearAmpAlarm(axis)",
        "B": "UpdateJerkDec(numCommands, pPosCommand)",
        "C": "OverrideJerkDec(numCommands, pPosCommand)",
        "D": "OverridePos(numCommands, pPosCommand)",
        "Answer(s)": "C"
    },
    {
        "No": 185,
        "Instruction": "Override the entire profiles of multiple axes currently executing position, jog, or velocity commands.",
        "A": "OverrideProfile(numCommands, pPosCommand)",
        "B": "OverrideJerkDec(numCommands, pPosCommand)",
        "C": "OverrideProfile(numCommands, positionToOverride)",
        "D": "StartPVT(pPVTCommand, numAddlCommands, pPVTAddlCommand)",
        "Answer(s)": "A"
    },
    {
        "No": 186,
        "Instruction": "Stop an axis executing a jog command at a timing that will cause the axis to stop at exactly the specified position.",
        "A": "StopJogAtPos(pPosCommand)",
        "B": "PauseRunningAtPosition(pPositionCommand)",
        "C": "StopJogAtPos(numCommands, pPosCommand)",
        "D": "ClearAxisAlarm_AxisSel(axisSel)",
        "Answer(s)": "A"
    },
    {
        "No": 187,
        "Instruction": "Stop multiple axes executing jog commands at timing that wil cause the axes to stop at exactly the specified positions.",
        "A": "StopJogAtPos(numCommands, pPosCommand)",
        "B": "StartPos_Trigger(numCommands, pPosCommand)",
        "C": "ExecTimedStop_AxisSel(pAxisSelection, timeMilliseconds)",
        "D": "StopJogAtPosition(numCommands, targetPosition)",
        "Answer(s)": "A"
    },
    {
        "No": 188,
        "Instruction": "Start a relative position superimposed motion command. The superimposed motion command will execute on top of any other motion that the axis may already be executing.",
        "A": "EnableSyncGroup(groupId, enable)",
        "B": "SuperimposeMovWithOffset(pPosCommand, offset)",
        "C": "SuperimposeMov(numCommands, pPosCommand)",
        "D": "SuperimposeMov(pPosCommand)",
        "Answer(s)": "D"
    },
    {
        "No": 189,
        "Instruction": "Start superimposed relative position commands for multiple axes. The superimposed motion commands will execute on top of any other motion that the axes may already be executing.",
        "A": "OverrideMov(numCommands, pPosCommand)",
        "B": "SuperimposeMov(numCommands, pPosCommand)",
        "C": "SuperimposeMovement(numCommands, playerPositionCommand)",
        "D": "SetFlightRecorderParam(axis, pParam)",
        "Answer(s)": "B"
    },
    {
        "No": 190,
        "Instruction": "Stop a superimposed motion.",
        "A": "GetParam()",
        "B": "Stop(axis)",
        "C": "StopSuperimpose(axis)",
        "D": "StopSuperimposeOnAxis(axis)",
        "Answer(s)": "C"
    },
    {
        "No": 191,
        "Instruction": "Stop the superimposed motion of multiple axes.",
        "A": "StopSuperimpose_AxisSel(pAxisSelection)",
        "B": "Stop_AxisSel(pAxisSelection)",
        "C": "StopSuperimpose_AxisSel(virtualAxisSelection)",
        "D": "StartRampRateTrq(pTrqCommand, rampRate)",
        "Answer(s)": "A"
    },
    {
        "No": 192,
        "Instruction": "Simulate a position command without moving any axes. The peak velocity, acceleration time, cruise time (the time the axis velocity is constant), deceleration time, and total profile time of the position command are returned.",
        "A": "StopJogAtPos(pPosCommand)",
        "B": "SimulatePos(pSimulatePosCommand)",
        "C": "Stop(axis)",
        "D": "SimulatePosition(pSimulatePositionCommand)",
        "Answer(s)": "B"
    },
    {
        "No": 193,
        "Instruction": "Simulate a linear interpolation motion command without moving any axes. The peak velocity, acceleration time, cruise time (the time the axis velocity is constant), deceleration time, and total profile time of the linear interpolation motion command are returned.",
        "A": "SimulateLinearInterpolatedPosition(simulationCommand)",
        "B": "SimulateTimeAtDist_LinearIntpl(pSimulateLinearIntplCommand, specificDistance)",
        "C": "StartCircularIntplMov_ThroughAndEnd_Trigger(pCircularIntplCommand, pTrigger)",
        "D": "SimulateLinearIntplPos(pSimulateLinearIntplCommand)",
        "Answer(s)": "D"
    },
    {
        "No": 194,
        "Instruction": "Simulate a position command without moving any axes. The position and velocity of the axis after the motion command runs for the specified time are returned.",
        "A": "SimulatePosAtTime(pSimulatePosCommand, int returnType, double timeMilliseconds)",
        "B": "Stop_Dec(axis, dec)",
        "C": "SimulatePosAtTimeExtended(pExtendedSimulatePosCommand, int extendedReturnType, double newTimeMilliseconds)",
        "D": "SimulatePosAtTime_LinearIntpl(pSimulateLinearIntplCommand, timeMilliseconds)",
        "Answer(s)": "A"
    },
    {
        "No": 195,
        "Instruction": "Simulate a linear interpolation motion command without moving any axes. The move distance, remain distance, and total distance after the linear interpolation runs for a specified amount of time are returned.",
        "A": "GetParam()",
        "B": "SimulateLinearIntplPos(pSimulateLinearIntplCommand)",
        "C": "SimulatePositionAtTime_LinearInterpolation(pLinearInterpolationSimulationCommand, timeMilliseconds)",
        "D": "SimulatePosAtTime_LinearIntpl(pSimulateLinearIntplCommand, timeMilliseconds)",
        "Answer(s)": "D"
    },
    {
        "No": 196,
        "Instruction": "Simulate a position command without moving any axes. The elapsed time and remaining time after the axis reaches the specified position are returned.",
        "A": "SimulateLinearIntplPos(pSimulateLinearIntplCommand)",
        "B": "SimulateTimeAtPos(pSimulatePosCommand, specificPos)",
        "C": "SetCommandPos(axis, position)",
        "D": "SimulateTimeAtSpecificPos(specificPos)",
        "Answer(s)": "B"
    },
    {
        "No": 197,
        "Instruction": "Simulate a linear interpolation motion command without moving any axes. The move time, remain time, and total time after the linear interpolation runs for a specified distance are returned.",
        "A": "SimulateTimeAtDist_LinearIntpl(pSimulateLinearIntplCommand, specificDistance)",
        "B": "SimulateTimeAtDist(pPathIntplCommand, specificDistance)",
        "C": "SimulateTimeAtDistance_LinearInterpolation(pLinearInterpolationSimulationCommand, distance)",
        "D": "AddRelativeSyncPhase(slaveAxis, phase, pProfile)",
        "Answer(s)": "A"
    },
    {
        "No": 198,
        "Instruction": "Allocate buffer memory to an axis for the execution of PVT motion commands.",
        "A": "CalculatePVTProfile(axis, points):",
        "B": "CreatePVTBuffer(axis, points)",
        "C": "SetMovingAverageProfileTime(axis, milliseconds)",
        "D": "FreePVTBuffer(axis)",
        "Answer(s)": "B"
    },
    {
        "No": 199,
        "Instruction": "Free PVT buffer memory for an axis.",
        "A": "FreePVTBuffer(axis)",
        "B": "StartCircularIntplMov_RadiusAndEnd_Trigger(pCircularIntplCommand, pTrigger)",
        "C": "FreePrivateBuffer(device)",
        "D": "FreePathIntplBuffer(axis)",
        "Answer(s)": "A"
    },
    {
        "No": 200,
        "Instruction": "Get the amount of PVT buffer memory currently allocated to an axis.",
        "A": "GetPathIntplBufferPoints(axis, pPoints)",
        "B": "FetchPVTBufferPoints(axis, pPoints)",
        "C": "StartVT(pVTCommand, numAddlCommands, pVTAddlCommand)",
        "D": "GetPVTBufferPoints(axis, pPoints)",
        "Answer(s)": "D"
    },
    {
        "No": 201,
        "Instruction": "Get the number of bytes required per point data in the PVT buffer memory.",
        "A": "GetPVTBytesPerPoint(pBytes)",
        "B": "GetPathIntplLookaheadBytesPerPoint()",
        "C": "GetPVTBytesPerPoint(pvtBytes)",
        "D": "StartCircularIntplMov_RadiusAndEnd(pCircularIntplCommand)",
        "Answer(s)": "A"
    },
    {
        "No": 202,
        "Instruction": "Start executing a PVT motion command.",
        "A": "StartPVT(AdvMotion_PVTCommand pPVTCommand)",
        "B": "StartTrq(numCommands, pTrqCommand)",
        "C": "UpdatePVT(AdvancedMotion_Command pCommand)",
        "D": "SetFeedbackParam(axis, pParam)",
        "Answer(s)": "A"
    },
    {
        "No": 203,
        "Instruction": "Start executing a PVT interpolation motion command.",
        "A": "Import_AxisPrm_Axis(pPath, axis, copyParamToAxes)",
        "B": "StartPVT_Interpolation(pPVTCommand)",
        "C": "StartPVT_Intpl(pPVTCommand)",
        "D": "StartVT(pVTCommand)",
        "Answer(s)": "C"
    },
    {
        "No": 204,
        "Instruction": "Start executing a PT motion command.",
        "A": "SetFlightRecorderParam(axis, pParam)",
        "B": "StartPT(pPTCommand)",
        "C": "StartPTCommand(pPTCommand: PTCommand)",
        "D": "StartAT(pATCommand)",
        "Answer(s)": "B"
    },
    {
        "No": 205,
        "Instruction": "Start executing a VT motion command.",
        "A": "StartVTCommand(pVTCommand, configuration)",
        "B": "StartAT(pATCommand)",
        "C": "StartVT(pVTCommand)",
        "D": "ExecTimedStop_TimeMilli(axis, timeMilliseconds)",
        "Answer(s)": "C"
    },
    {
        "No": 206,
        "Instruction": "Start executing a AT motion command.",
        "A": "StartAT(pATCommand)",
        "B": "StartATCommand(pATCommand)",
        "C": "StartMov(pPosCommand)",
        "D": "IsDeviceValid()",
        "Answer(s)": "A"
    },
    {
        "No": 207,
        "Instruction": "Start executing a PVT motion command.",
        "A": "StartPVTExecution(pInitialCommand, numAdditionalCommands, pAdditionalCommands)",
        "B": "StartPVT(pPVTCommand, numAddlCommands, pPVTAddlCommand)",
        "C": "StartPathIntplPos(pPathIntplCommand, numAddlCommands, pPathIntplAddlCommand)",
        "D": "GetAxisUnit(axis)",
        "Answer(s)": "B"
    },
    {
        "No": 208,
        "Instruction": "Start executing a PVT interpolation motion command.",
        "A": "StartPVT_Intpl(pPVTCommand, numAddlCommands, PyObject *pPVTAddlCommand)",
        "B": "StartPVT_Interpolate(pPVTCommand, numAdditionalCommands, PyObject *pPVTAdditionalCommand)",
        "C": "StartPathIntplPos(pPathIntplCommand, numAddlCommands, pPathIntplAddlCommand)",
        "D": "SetMaxTrqLimit(axis, torque)",
        "Answer(s)": "A"
    },
    {
        "No": 209,
        "Instruction": "Start executing a PT motion command.",
        "A": "StartPTWithAdditionalCommands(pPTCommand, numAdditionalCommands, pPTAdditionalCommand)",
        "B": "StartAT(pATCommand, numAddlCommands, pATAddlCommand)",
        "C": "StartLinearIntplPos(pLinearIntplCommand)",
        "D": "StartPT(pPTCommand, numAddlCommands, pPTAddlCommand)",
        "Answer(s)": "D"
    },
    {
        "No": 210,
        "Instruction": "Start executing a VT motion command.",
        "A": "StartPos_TriggerEvents(pPosCommand, pTriggerEvents)",
        "B": "StartVirtualTerminal(pVTCommand, numAdditionalCommands, pVTAdditionalCommand)",
        "C": "StartVT(pVTCommand, numAddlCommands, pVTAddlCommand)",
        "D": "StartAT(pATCommand, numAddlCommands, pATAddlCommand)",
        "Answer(s)": "C"
    },
    {
        "No": 211,
        "Instruction": "Start executing a AT motion command.",
        "A": "StartPosToVel_TriggerEvents(pVelCommand, pTriggerEvents)",
        "B": "StartAT(pATCommand, numAddlCommands, pATAddlCommand)",
        "C": "StartATCommand(pATCommand, numAdditionalCommands, pATAddlCommand)",
        "D": "StartPathIntplPos(pPathIntplCommand, numAddlCommands, pPathIntplAddlCommand)",
        "Answer(s)": "B"
    },
    {
        "No": 212,
        "Instruction": "Return TRUE if this class object has access to a device, and FALSE otherwise. A device is required to execute most functions in this class. If this function returns FALSE, a device can be created by calling the CreateDevice function from the WMX3Api object that was passed to the constructor of this class.",
        "A": "IsDeviceValid()",
        "B": "GetMByteEx(addr)",
        "C": "CheckDeviceValidity()",
        "D": "Stop_StopCommand(numCommands, pStopCommand)",
        "Answer(s)": "A"
    },
    {
        "No": 213,
        "Instruction": "Start homing an axis. The axis will search for the home position. If found, the home position will become the zero position for that axis.",
        "A": "GetHomeParam(axis)",
        "B": "IsDeviceValid()",
        "C": "InitializeHome(axis)",
        "D": "StartHome(axis)",
        "Answer(s)": "D"
    },
    {
        "No": 214,
        "Instruction": "Start homing multiple axes. The axes will search for the home positions. If found, the home position will become the zero position for that axis",
        "A": "StartHome_AxisSel(pAxisSelection)",
        "B": "GetVelCommand(axis)",
        "C": "StartHome_AxisSelect(pAxis)",
        "D": "Stop_AxisSel(pAxisSelection)",
        "Answer(s)": "A"
    },
    {
        "No": 215,
        "Instruction": "Continue homing an axis that has been paused during the homing operation.",
        "A": "Resume(axis)",
        "B": "ContinueAxis(axis):",
        "C": "StartTrq(pTrqCommand)",
        "D": "Continue(axis)",
        "Answer(s)": "D"
    },
    {
        "No": 216,
        "Instruction": "Continue homing multiple axes that have been paused during the homing operation.",
        "A": "SetSyncMasterSlave(masterAxis, slaveAxis)",
        "B": "Revise_AxisSelParams(pAxisSelection)",
        "C": "Pause_AxisSel(pAxisSelection)",
        "D": "Continue_AxisSel(pAxisSelection)",
        "Answer(s)": "D"
    },
    {
        "No": 217,
        "Instruction": "Cancel the homing operation for an axis that has been paused during homing operation.",
        "A": "StartMov_TriggerEvents(pPosCommand, pTriggerEvents)",
        "B": "Cancel(axis)",
        "C": "Wait(axis)",
        "D": "Stop(axis)",
        "Answer(s)": "B"
    },
    {
        "No": 218,
        "Instruction": "Cancel the homing procedure for multiple axes that have been paused during homing operation",
        "A": "Cancel_AxisSel(pAxisSelection)",
        "B": "Update_AxisSelection(pUpdatedSelection)",
        "C": "Wait_AxisSel(pAxisSelection)",
        "D": "StartRampRateTrq(pTrqCommand, rampRate, maxMotorSpeed)",
        "Answer(s)": "A"
    },
    {
        "No": 219,
        "Instruction": "Set the current command position of the axis to the specified value.",
        "A": "StartMov_TriggerEvents(pPosCommand, pTriggerEvents)",
        "B": "SetCommandPos(axis, position)",
        "C": "UpdateCommandLocation(axis, new_position)",
        "D": "GetVelCommand(axis)",
        "Answer(s)": "B"
    },
    {
        "No": 220,
        "Instruction": "Set the current feedback position of the axis to the specified value.",
        "A": "SetFeedbackPosition(axis, newPosition)",
        "B": "SetFeedbackParam(axis, pParam)",
        "C": "SetFeedbackPos(axis, position)",
        "D": "StartPosToJog_Trigger(pTriggerJogCommand)",
        "Answer(s)": "C"
    },
    {
        "No": 221,
        "Instruction": "Set the home done state.",
        "A": "SetHomeDoneV2(axis_number, is_complete)",
        "B": "SetAxisCommandMode(axis, mode)",
        "C": "SetHomeDone(axis, value)",
        "D": "StartPVT_Intpl(pPVTCommand, numAddlCommands, PyObject *pPVTAddlCommand)",
        "Answer(s)": "C"
    },
    {
        "No": 222,
        "Instruction": "Set the current cyclic command position equal to the feedback position.",
        "A": "StartVel(pVelCommand)",
        "B": "SetCommandPos(axis, position)",
        "C": "SetCommandPosToFeedbackPos(axis)",
        "D": "SetCommandPositionToFeedbackPosition(axis)",
        "Answer(s)": "C"
    },
    {
        "No": 223,
        "Instruction": "Get the homing related data for all axes.",
        "A": "GetUserData()",
        "B": "GetHomeData()",
        "C": "GetModuleId()",
        "D": "GetSyncParam(axis)",
        "Answer(s)": "B"
    },
    {
        "No": 224,
        "Instruction": "Return TRUE if this class object has access to a device, and FALSE otherwise. A device is required to execute most functions in this class. If this function returns FALSE, a device can be created by calling the CreateDevice function from the WMX3Api object that was passed to the constructor of this class.",
        "A": "isDeviceValid(device: Device)",
        "B": "StartJog(pJogCommand)",
        "C": "IsDeviceValid()",
        "D": "ClearSyncGroupError(groupId)",
        "Answer(s)": "C"
    },
    {
        "No": 225,
        "Instruction": "Establish synchronous control between a master axis and a slave axis.",
        "A": "SetFeedbackParam(axis, pParam)",
        "B": "SetSyncMasterSlave(masterAxis, slaveAxis)",
        "C": "SetSynchronizationMasterSlave(masterAxis, slaveAxis)",
        "D": "SetSyncGearRatio(masterAxis, slaveAxis, gearRatio, pProfile)",
        "Answer(s)": "B"
    },
    {
        "No": 226,
        "Instruction": "Combine the position commands of two master axes and set it as the position command of a slave axis.",
        "A": "SetSyncCombineWithDelay(masterAxis1, masterAxis2, slaveAxis, delayTime)",
        "B": "StartCircularIntplMov_ThroughAndEnd3D_TriggerEvents(pCircularIntplCommand, pTriggerEvents)",
        "C": "CloseCyclicBuffer_AxisSel(pAxisSelection)",
        "D": "SetSyncCombine(masterAxis1, masterAxis2, slaveAxis)",
        "Answer(s)": "D"
    },
    {
        "No": 227,
        "Instruction": "Set the absolute sync phase of a slave axis.",
        "A": "SetSyncPhaseAbsolute(slaveAxis, phase, profileParams)",
        "B": "SetAbsoluteSyncPhase(slaveAxis, phase, pProfile)",
        "C": "ExecQuickStop_AxisSel(pAxisSelection)",
        "D": "SyncToJog(slaveAxis, pProfile)",
        "Answer(s)": "B"
    },
    {
        "No": 228,
        "Instruction": "Add a relative sync phase to a slave axis.",
        "A": "AddRelativeSyncPhase(slaveAxis, phase, pProfile)",
        "B": "SetSyncGroup(groupId, pSyncGroup)",
        "C": "SetSyncGearRatio(slaveAxis, gearRatio, pProfile)",
        "D": "UpdateRelativeSyncPhase(slaveAxis, newPhase, pProfile)",
        "Answer(s)": "A"
    },
    {
        "No": 229,
        "Instruction": "Set the sync gear ratio between a sync slave axis and the master axis.",
        "A": "SetSyncGearRatioV2(slaveAxis, updatedGearRatio, motionProfile)",
        "B": "SetMaxTrqLimit(axis, torque)",
        "C": "SetSyncGearRatio(slaveAxis, gearRatio, pProfile)",
        "D": "SyncToJog(slaveAxis, pProfile)",
        "Answer(s)": "C"
    },
    {
        "No": 230,
        "Instruction": "Establish sync control between two axes, and set the sync gear ratio between a sync slave axis and the master axis.",
        "A": "SetAbsoluteSyncPhase(slaveAxis, phase, pProfile)",
        "B": "SetSyncGearRatioWithProfile(masterAxis, slaveAxis, gearRatio, pProfile)",
        "C": "SetSyncGearRatio(masterAxis, slaveAxis, gearRatio, pProfile)",
        "D": "Export_SysPrm(pPath, pParam)",
        "Answer(s)": "C"
    },
    {
        "No": 231,
        "Instruction": "Resolve sync control for a slave axis, and immediately start a jog command for the slave axis.",
        "A": "SyncToJog(slaveAxis, pProfile)",
        "B": "SyncToJog(slaveAxisID, jogProfile)",
        "C": "AddRelativeSyncPhase(slaveAxis, phase, pProfile)",
        "D": "SetEmergencyStopParam(pParam)",
        "Answer(s)": "A"
    },
    {
        "No": 232,
        "Instruction": "Resolve sync control for a slave axis, and immediately start a jog command for the slave axis with the velocity equal to the velocity that the slave axis was moving at",
        "A": "SyncToJog(slaveAxis)",
        "B": "StartVelToPos(pTriggerPosCommand)",
        "C": "SyncToJogController(joggingAxis)",
        "D": "StopTrq(axis)",
        "Answer(s)": "A"
    },
    {
        "No": 233,
        "Instruction": "Release the specified slave axis from synchronous control.",
        "A": "RemoveAxisFromSyncGroup(groupId, axis)",
        "B": "ResolveSlaveAxisSync(slaveAxis)",
        "C": "ResolveSync(slaveAxis)",
        "D": "Resume(axis)",
        "Answer(s)": "C"
    },
    {
        "No": 234,
        "Instruction": "Set the axes and parameters of a synchronization group.",
        "A": "OverrideMov(pPosCommand)",
        "B": "GetSyncGroupStatus(groupId)",
        "C": "SetSyncGroup(groupId, pSyncGroup)",
        "D": "SetSyncGroupById(groupId, syncGroupId)",
        "Answer(s)": "C"
    },
    {
        "No": 235,
        "Instruction": "Get the axes and parameters of a sync group.",
        "A": "GetSyncGroupStatus(groupId)",
        "B": "GetSyncGroup(groupId)",
        "C": "GetSyncGroupInfo(GroupID)",
        "D": "StopTrq_AxisSel(pAxisSelection)",
        "Answer(s)": "B"
    },
    {
        "No": 236,
        "Instruction": "Add another axis to an existing sync group.",
        "A": "AddAxisToSyncGroup(groupId, axis, isMaster)",
        "B": "AddAxisToSyncGroupV2(groupId, axis, isMaster)",
        "C": "OverrideJerkAcc(pPosCommand)",
        "D": "SetSyncGroup(groupId, pSyncGroup)",
        "Answer(s)": "A"
    },
    {
        "No": 237,
        "Instruction": "Remove an axis from an existing sync group.",
        "A": "Pause_AxisSel(pAxisSelection)",
        "B": "RemoveAxisFromSyncGroup(groupId, axis)",
        "C": "ClearSyncGroupError(groupId)",
        "D": "ChangeAxisInSyncGroup(groupId, currentAxis, newAxis)",
        "Answer(s)": "B"
    },
    {
        "No": 238,
        "Instruction": "Enable or disable a sync group.",
        "A": "GetSyncGroup(groupId)",
        "B": "EnableGroupSync(groupId, isEnabled)",
        "C": "EnableSyncGroup(groupId, enable)",
        "D": "SetMovingAverageProfileTime(axis, milliseconds)",
        "Answer(s)": "C"
    },
    {
        "No": 239,
        "Instruction": "Read the current status of the specified sync group.",
        "A": "RemoveAxisFromSyncGroup(groupId, axis)",
        "B": "SetServoOn(axis, newStatus)",
        "C": "GetSyncGroupStatus(groupId)",
        "D": "GetSyncGroupInfo(groupID)",
        "Answer(s)": "C"
    },
    {
        "No": 240,
        "Instruction": "Clear all sync group errors of the specified sync group.",
        "A": "GetSyncGroupStatus(groupId)",
        "B": "Stop(axis)",
        "C": "UpdateSyncGroupError(groupId)",
        "D": "ClearSyncGroupError(groupId)",
        "Answer(s)": "D"
    },
    {
        "No": 241,
        "Instruction": "Return TRUE if this class object has access to a device, and FALSE otherwise. A device is required to execute most functions in this class. If this function returns FALSE, a device can be created by calling the CreateDevice function from the WMX3Api object that was passed to the constructor of this class.",
        "A": "IsDeviceValid(device_id: str)",
        "B": "CompareWindowsUpdates()",
        "C": "GetHomeData()",
        "D": "IsDeviceValid()",
        "Answer(s)": "D"
    },
    {
        "No": 242,
        "Instruction": "Turn a servo drive in the servo network on or off.",
        "A": "StartCircularIntplPos_LengthAndEnd(pCircularIntplCommand)",
        "B": "GetEngineStatus()",
        "C": "SetServoOn(axis, newStatus)",
        "D": "SetAxisServoStatus(axisNumber, isEnabled)",
        "Answer(s)": "C"
    },
    {
        "No": 243,
        "Instruction": "Turn multiple servo drives in the servo network on or off.",
        "A": "StopTrq_AxisSel(pAxisSelection)",
        "B": "SetServoStatus(axisSelection, isEnabled)",
        "C": "SetServoOn_AxisSel(axisSel, newStatus)",
        "D": "StartCircularIntplPos_RadiusAndEnd_TriggerEvents(pCircularIntplCommand, pTriggerEvents)",
        "Answer(s)": "C"
    },
    {
        "No": 244,
        "Instruction": "Clear the servo drive amp alarm on the specified axis.",
        "A": "ClearAmpAlarm(axis)",
        "B": "SetAxisUnit(axis, unit)",
        "C": "GetAlarmParam(axis)",
        "D": "ClearAmpAlarm(axis, alarm_id)",
        "Answer(s)": "A"
    },
    {
        "No": 245,
        "Instruction": "Clear the servo drive amp alarms on multiple axes.",
        "A": "ClearAmpAlarm_Axis(axisNum)",
        "B": "ClearAmpAlarm_AxisSel(axisSel)",
        "C": "GetParam_Axis(axis)",
        "D": "AddAxisToSyncGroup(groupId, axis, isMaster)",
        "Answer(s)": "B"
    },
    {
        "No": 246,
        "Instruction": "Clear any axis alarms on the specified axis.",
        "A": "Wait_TimeMilli(axis, waitTimeMilliseconds)",
        "B": "ResetAxisAlarm(axis)",
        "C": "ClearAxisAlarm(axis)",
        "D": "GetParam_Axis(axis)",
        "Answer(s)": "C"
    },
    {
        "No": 247,
        "Instruction": "Clear any axis alarms on multiple axes.",
        "A": "GetAxisParam_Axis(axis)",
        "B": "ClearAxisAlarm_AxisSel(axisSel)",
        "C": "StartCircularIntplPos_LengthAndEnd(pCircularIntplCommand)",
        "D": "ResetAxisAlarm_SelectedAxis(axis)",
        "Answer(s)": "B"
    },
    {
        "No": 248,
        "Instruction": "Set the command mode of the axis.",
        "A": "SetAxisCommandMode(axis, mode)",
        "B": "SetAxisControlMode(axis, control_mode)",
        "C": "GetPVTBufferPoints(axis, pPoints)",
        "D": "AddCommand(axis, pCmd)",
        "Answer(s)": "A"
    },
    {
        "No": 249,
        "Instruction": "Set the command mode of multiple axes.",
        "A": "SetAxisCommandMode_AxisSel(axisSel, mode)",
        "B": "Export_SysPrm_AxisPrm_Axis(pPath, pParam, pAxisParam, axis)",
        "C": "AddCommand_AxisSel(pAxisSelection, pCmds)",
        "D": "SetAxisCommandMode_SelectedAxis(axis, commandMode)",
        "Answer(s)": "A"
    },
    {
        "No": 250,
        "Instruction": "Get the command mode of the axis.",
        "A": "GetAxisCommandMode(axis)",
        "B": "GetAxisState(axis)",
        "C": "GetPosCommand(axis)",
        "D": "StartCircularIntplMov_ThroughAndEnd_TriggerEvents(pCircularIntplCommand, pTriggerEvents)",
        "Answer(s)": "A"
    },
    {
        "No": 251,
        "Instruction": "Get the current cycle position command of the axis.",
        "A": "GetPosCommand(axis)",
        "B": "SetAxisCommandMode(axis, mode)",
        "C": "GetPositionCommand(axis)",
        "D": "StartTrqToPos_TriggerEvents(pPosCommand, pTriggerEvents)",
        "Answer(s)": "A"
    },
    {
        "No": 252,
        "Instruction": "Get the current cycle position feedback of the axis.",
        "A": "StartPosToVel_TriggerEvents(pVelCommand, pTriggerEvents)",
        "B": "GetPosCommand(axis)",
        "C": "GetPosFeedback(axis)",
        "D": "GetAxisPosFeedback(axis_name)",
        "Answer(s)": "C"
    },
    {
        "No": 253,
        "Instruction": "Get the current cycle velocity command of the axis",
        "A": "AddCommand(axis, pCmd)",
        "B": "GetVelocityCommand(axis):",
        "C": "GetVelCommand(axis)",
        "D": "SyncToJog(slaveAxis, pProfile)",
        "Answer(s)": "C"
    },
    {
        "No": 254,
        "Instruction": "Get the current cycle velocity feedback of the axis",
        "A": "GetPosFeedback(axis)",
        "B": "SetServoOn_AxisSel(axisSel, newStatus)",
        "C": "GetVelFeedback(axis)",
        "D": "GetAxisVelFeedback(axis_id)",
        "Answer(s)": "C"
    },
    {
        "No": 255,
        "Instruction": "Return TRUE if this class object has access to a device, and FALSE otherwise. A device is required to execute most functions in this class. If this function returns FALSE, a device can be created by calling the CreateDevice function from the WMX3Api object that was passed to the constructor of this class.",
        "A": "GetSingleTurn(axis)",
        "B": "SetOutputData(moduleId, data, dataSize)",
        "C": "IsDeviceValid()",
        "D": "IsDeviceConnectionValid()",
        "Answer(s)": "C"
    },
    {
        "No": 256,
        "Instruction": "Start a velocity command.",
        "A": "StartPT(pPTCommand)",
        "B": "InitiateVelocity(previousVelocity_command)",
        "C": "StartVel(pVelCommand)",
        "D": "StartAT(pATCommand, numAddlCommands, pATAddlCommand)",
        "Answer(s)": "C"
    },
    {
        "No": 257,
        "Instruction": "Start a timed velocity command.",
        "A": "StartTrqToPos_TriggerEvents(pPosCommand, pTriggerEvents)",
        "B": "StartTrqToVel_TriggerVel(pTriggerVelCommand)",
        "C": "StartVel_TimedVel(pTimedVelCommand)",
        "D": "EndVel_TimedVel(pTimedVelCommand)",
        "Answer(s)": "C"
    },
    {
        "No": 258,
        "Instruction": "Start a velocity command and set the maximum torque limit.",
        "A": "StartVel_MaxTrq(pVelCommand, maxTrqLimit)",
        "B": "StopSuperimpose(axis)",
        "C": "StartVelocity_MaxTorque(velocityCommand, maxTorqueLimit)",
        "D": "StartPosToVel_TriggerEvents(pVelCommand, pTriggerEvents)",
        "Answer(s)": "A"
    },
    {
        "No": 259,
        "Instruction": "Start velocity commands for multiple axes.",
        "A": "StartVel(numCommands, pVelCommand)",
        "B": "LaunchSequence(numEvents, launchCommands)",
        "C": "IsDeviceValid()",
        "D": "StartVel_TimedVel(numCommands, pTimedVelCommand)",
        "Answer(s)": "A"
    },
    {
        "No": 260,
        "Instruction": "Start timed velocity commands for multiple axes",
        "A": "StartVel_TimedVel(numCommands, pTimedVelCommand)",
        "B": "StartPosToVel_TriggerVel(numCommands, pTriggerVelCommand)",
        "C": "SimulateTimeAtDist_LinearIntpl(pSimulateLinearIntplCommand, specificDistance)",
        "D": "InitiateMotion(TotalCommands, arrayMotionCommands)",
        "Answer(s)": "A"
    },
    {
        "No": 261,
        "Instruction": "Stop the motion of an axis.",
        "A": "StartMovToJog(pPosToJogCommand)",
        "B": "Halt(axis):",
        "C": "Stop_Dec(axis, dec)",
        "D": "Stop(axis)",
        "Answer(s)": "D"
    },
    {
        "No": 262,
        "Instruction": "Stop the motion of multiple axes.",
        "A": "Stop_AxisSel(pAxisSelection)",
        "B": "Stop_AxisSelection(pSelectedAxis)",
        "C": "Wait_AxisSel(pAxisSelection)",
        "D": "StartPVT_Intpl(pPVTCommand, numAddlCommands, PyObject *pPVTAddlCommand)",
        "Answer(s)": "A"
    },
    {
        "No": 263,
        "Instruction": "Stop execution of the cyclic position command buffer of an axis and decelerate the axis to a stop using the quick stop deceleration.",
        "A": "Stop(axis)",
        "B": "ExecQuickStop(axis)",
        "C": "StopAxisQuickly(axis)",
        "D": "StartCircularIntplPos_LengthAndEnd_TriggerEvents(pCircularIntplCommand, pTriggerEvents)",
        "Answer(s)": "B"
    },
    {
        "No": 264,
        "Instruction": "Stop execution of the cyclic position command buffer of multiple axes and decelerate the axes to a stop using the quick stop deceleration.",
        "A": "ExecQuickStop_AxisSel(pAxisSelection)",
        "B": "Execute_AxisSel(pAxisSelection)",
        "C": "ExecCriticalStop_AxisSel(pSelectedAxis)",
        "D": "SyncToJog(slaveAxis)",
        "Answer(s)": "A"
    },
    {
        "No": 265,
        "Instruction": "Stop an axis that is currently in motion in the specified amount of time using a trapezoidal profile.",
        "A": "SetServoOn(axis, newStatus)",
        "B": "ExecTimedStop_TimeLimit(axis, timeLimitMilliseconds)",
        "C": "ExecTimedStop_AxisSel(pAxisSelection, timeMilliseconds)",
        "D": "ExecTimedStop_TimeMilli(axis, timeMilliseconds)",
        "Answer(s)": "D"
    },
    {
        "No": 266,
        "Instruction": "Stop multiple axes that are currently in motion in the specified amount of time using a trapezoidal profile",
        "A": "ExecTimedStop_AxisSel(pAxisSelection, timeMilliseconds)",
        "B": "ExecTimedStop_AxisSel(pSelectedAxis, durationMs)",
        "C": "ExecTimedStop_TimeMilli(axis, timeMilliseconds)",
        "D": "StartCircularIntplPos_LengthAndEnd(pCircularIntplCommand)",
        "Answer(s)": "A"
    },
    {
        "No": 267,
        "Instruction": "Stop multiple axes that are currently in motion in the specified amounts of time using a trapezoidal profile.",
        "A": "ExecTimedStop_CommandTime(numCommands, pTimeCommand)",
        "B": "OverridePos(numCommands, pPosCommand)",
        "C": "ExecTimedStop_TimeMilli(axis, timeMilliseconds)",
        "D": "ExecTimedStop_TimeCmd(numCommands, pTimeCommand)",
        "Answer(s)": "D"
    },
    {
        "No": 268,
        "Instruction": "Set the maximum motor speed of an axis.",
        "A": "StartTrq_MaxMotorSpeed(pTrqCommand, maxMotorSpeed)",
        "B": "SetMotorLimit(axis, max_speed)",
        "C": "GetFlightRecorderParam()",
        "D": "SetMaxMotorSpeed(axis, speed)",
        "Answer(s)": "D"
    },
    {
        "No": 269,
        "Instruction": "Get the maximum motor speed of an axis.",
        "A": "SetParam(pParam)",
        "B": "GetMotionParam(axis)",
        "C": "GetMaxMotorSpeed(axis)",
        "D": "GetMaxMotorRPM(axis)",
        "Answer(s)": "C"
    },
    {
        "No": 270,
        "Instruction": "Set an override velocity for a single axis that is currently executing a velocity command.",
        "A": "AdjustVelocity(pVelocityCommand)",
        "B": "OverrideVel(pVelCommand)",
        "C": "OverrideVel(pPosCommand)",
        "D": "StartLinearIntplPos_TriggerEvents(pLinearIntplCommand, pTriggerEvents)",
        "Answer(s)": "B"
    },
    {
        "No": 271,
        "Instruction": "Set override velocities for multiple axes that are currently executing velocity commands.",
        "A": "OverrideVel(numCommands, pVelCommand)",
        "B": "OverrideVel(numCommands, pPosCommand)",
        "C": "RevisedOverrideVel(numCommands, newVelCommand)",
        "D": "GetMaxTrqLimit(axis)",
        "Answer(s)": "A"
    },
    {
        "No": 272,
        "Instruction": "Start a triggered velocity command for an axis that is currently executing a position command.",
        "A": "StartPosToVel_TriggerVel(numCommands, pTriggerVelCommand)",
        "B": "SetHomeParam(axis, pParam)",
        "C": "StartPosToVel_TriggerVel(pTriggerVelCommand)",
        "D": "SetInitialPosition_And_TriggerVelocity(pTriggerVelocityCommand)",
        "Answer(s)": "C"
    },
    {
        "No": 273,
        "Instruction": "Start triggered velocity commands for multiple axes that are currently executing position commands.",
        "A": "ResetFlightRecorder()",
        "B": "StartPosToVel_PulseVel(numCommands, pPulseVelCommand)",
        "C": "StartPosToVel_TriggerVel(pTriggerVelCommand)",
        "D": "StartPosToVel_TriggerVel(numCommands, pTriggerVelCommand)",
        "Answer(s)": "D"
    },
    {
        "No": 274,
        "Instruction": "Start a triggered velocity command for an axis that is currently executing a position command. The trigger condition can have multiple trigger events.",
        "A": "StartTrqToVel_TriggerEvents(pVelCommand, pTriggerEvents)",
        "B": "StartPosToVel_TriggerEvents(pVelocityCommand, pEventTriggers)",
        "C": "SetSyncParam(axis, pParam)",
        "D": "StartPosToVel_TriggerEvents(pVelCommand, pTriggerEvents)",
        "Answer(s)": "D"
    },
    {
        "No": 275,
        "Instruction": "Start triggered velocity commands for multiple axes that are currently executing position commands. The trigger conditions can have multiple trigger events",
        "A": "GetInputModuleId()",
        "B": "StartTrqToVel_TriggerEvents(numCommands, pVelCommand, pTriggerEvents)",
        "C": "StartPosToVel_TriggerEvents(numCommands, pVelCommand, pTriggerEvents)",
        "D": "UpdatePosToVel_TriggerEvents(numChanges, pUpdatedVelCommand, pTriggerEvents)",
        "Answer(s)": "C"
    },
    {
        "No": 276,
        "Instruction": "Start a triggered velocity command for an axis that is currently executing a torque command. The trigger condition can have multiple trigger events.",
        "A": "GetVelFeedback(axis)",
        "B": "StartPosToVel_TriggerVel(numCommands, pTriggerVelCommand)",
        "C": "StartTrqToVel_TriggerVel(pTriggerVelCommand)",
        "D": "StartTrqToVel_CheckForTriggerVelCommand(triggerVelocity)",
        "Answer(s)": "C"
    },
    {
        "No": 277,
        "Instruction": "Start triggered velocity commands for multiple axes that are currently executing torque commands. The trigger conditions can have multiple trigger events.",
        "A": "StartTrqToVel_TriggerVel(numCommands, pTriggerVelCommand)",
        "B": "StopJogAtPos(numCommands, pPosCommand)",
        "C": "StartTrqToVel_TriggerVel(numTriggerVelCommands, pTriggerVelCommands)",
        "D": "StartPosToVel_TriggerVel(numCommands, pTriggerVelCommand)",
        "Answer(s)": "A"
    },
    {
        "No": 278,
        "Instruction": "Start a triggered velocity command for an axis that is currently executing a torque command. The trigger condition can have multiple trigger events.",
        "A": "StartPos_Trigger(pPosCommand)",
        "B": "StartTrqToVel_TriggerEvents(pVelCommand, pTriggerEvents)",
        "C": "StartTrqToMov_TriggerEvents(pPosCommand, pTriggerEvents)",
        "D": "UpdateTrqToVel_TriggerEvents(pVelSetpoint, pTriggerEvents)",
        "Answer(s)": "B"
    },
    {
        "No": 279,
        "Instruction": "Start triggered velocity commands for multiple axes that are currently executing torque commands. The trigger conditions can have multiple trigger events.",
        "A": "ModifyTrqToVel_TriggerEvents(numCommands, pVelCommands, pTriggerEvents)",
        "B": "GetAxisParam_Axis(axis)",
        "C": "StartTrqToVel_TriggerEvents(numCommands, pVelCommand, pTriggerEvents)",
        "D": "StartPosToVel_TriggerEvents(numCommands, pVelCommand, pTriggerEvents)",
        "Answer(s)": "C"
    },
    {
        "No": 280,
        "Instruction": "Return TRUE if this class object has access to a device, and FALSE otherwise. A device is required to execute most functions in this class. If this function returns FALSE, a device can be created by calling the CreateDevice function from the WMX3Api object that was passed to the constructor of this class.",
        "A": "ValidateDevice()",
        "B": "SetAbsoluteSyncPhase(slaveAxis, phase, pProfile)",
        "C": "IsDeviceValid()",
        "D": "GetFlightRecorderParam()",
        "Answer(s)": "C"
    },
    {
        "No": 281,
        "Instruction": "Set the maximum torque limit of an axis.",
        "A": "SetMaximumTorqueLimit(axis, max_torque)",
        "B": "StartCircularIntplMov_CenterAndLength_Trigger(pCircularIntplCommand, pTrigger)",
        "C": "SetAxisUnit(axis, unit)",
        "D": "SetMaxTrqLimit(axis, torque)",
        "Answer(s)": "D"
    },
    {
        "No": 282,
        "Instruction": "Get the maximum torque limit of an axis.",
        "A": "GetMaxTrqLimit(axis)",
        "B": "GetMaxTorqueLimit(axis_id)",
        "C": "GetNegativeTrqLimit(axis)",
        "D": "StartVelToTrq_TriggerEvents(numCommands, pTrqCommand, pTriggerEvents)",
        "Answer(s)": "A"
    },
    {
        "No": 283,
        "Instruction": "Set the maximum torque limit in the positive direction of an axis.",
        "A": "SetGearRatio(axis, numerator, denominator)",
        "B": "SetPositiveTrqLimit(axis, torque)",
        "C": "SetMaxTorqueLimit(axis, max_torque)",
        "D": "SetNegativeTrqLimit(axis, torque)",
        "Answer(s)": "B"
    },
    {
        "No": 284,
        "Instruction": "Get the maximum torque limit in the positive direction of an axis.",
        "A": "GetPositiveTrqLimit(axis)",
        "B": "GetMaxPositiveTorqueLimit(axis)",
        "C": "Wait_WaitCondition_TimeMilli(pWaitCondition, waitTimeMilliseconds)",
        "D": "SetPositiveTrqLimit(axis, torque)",
        "Answer(s)": "A"
    },
    {
        "No": 285,
        "Instruction": "Set the maximum torque limit in the negative direction of an axis.",
        "A": "SetPositiveTrqLimit(axis, torque)",
        "B": "Export_AxisPrm(pPath, pAxisParam)",
        "C": "SetNegativeTrqLimit(axis, torque)",
        "D": "SetNegativeTorqueLimit(axis, limit)",
        "Answer(s)": "C"
    },
    {
        "No": 286,
        "Instruction": "Get the maximum torque limit in the negative direction of an axis.",
        "A": "GetNegativeTrqLimit(axis)",
        "B": "SetMaxTrqLimit(axis, torque)",
        "C": "GetVelFeedback(axis)",
        "D": "GetNegativeTorqueLimit(axis)",
        "Answer(s)": "A"
    },
    {
        "No": 287,
        "Instruction": "Start a torque command.",
        "A": "StartTorque(pCommand)",
        "B": "StartTrq(pTrqCommand)",
        "C": "SetAxisPolarity(axis, polarity)",
        "D": "StartVelToTrq(pTriggerTrqCommand)",
        "Answer(s)": "B"
    },
    {
        "No": 288,
        "Instruction": "Start torque commands for multiple axes.",
        "A": "StartTrq(numCommands, pTrqCommand)",
        "B": "Export_AxisPrm(pPath, pAxisParam)",
        "C": "StartTrqToPos(numCommands, pTriggerPosCommand)",
        "D": "ExecuteCommands(numCommands, commandsList)",
        "Answer(s)": "A"
    },
    {
        "No": 289,
        "Instruction": "Start a torque command and set the maximum motor speed.",
        "A": "EnduranceMode_SetMaxSpeed(pTrqCommand, maxMotorSpeed)",
        "B": "Stop(axis)",
        "C": "StartTrq_MaxMotorSpeed(pTrqCommand, maxMotorSpeed)",
        "D": "StartVel_MaxTrq(pVelCommand, maxTrqLimit)",
        "Answer(s)": "C"
    },
    {
        "No": 290,
        "Instruction": "Start a triggered torque command in which the torque is changed over time",
        "A": "StartRampTimeTrq(pTrqCommand, rampCycleTime)",
        "B": "StartRampTimeTrq(pTrqCommand, rampCycleTime, maxMotorSpeed)",
        "C": "SetAbsoluteSyncPhase(slaveAxis, phase, pProfile)",
        "D": "UpdateRampTimeTrq(pTrqCommand, newRampCycleTime)",
        "Answer(s)": "A"
    },
    {
        "No": 291,
        "Instruction": "Start a torque command in which the torque is changed over time and set the maximum motor speed.",
        "A": "StartRampTimeTrq(pTrqOutput, rampTime, maxTorque)",
        "B": "StartJog_TimedJog(numCommands, pTimedJogCommand)",
        "C": "StartRampTimeTrq(pTrqCommand, rampCycleTime, maxMotorSpeed)",
        "D": "SetAxisPolarity(axis, polarity)",
        "Answer(s)": "C"
    },
    {
        "No": 292,
        "Instruction": "Start a torque command in which the torque is changed at a specified rate.",
        "A": "StartChangingRampTrq(pTrqSetpoint, rampRate)",
        "B": "StartTrq(pTrqCommand)",
        "C": "StartRampRateTrq(pTrqCommand, rampRate)",
        "D": "StartCircularIntplMov_ThroughAndEnd3D(pCircularIntplCommand)",
        "Answer(s)": "C"
    },
    {
        "No": 293,
        "Instruction": "Start a torque command in which the torque is changed at a specified rate and set the maximum motor speed.",
        "A": "SetMovingAverageProfileTime(axis, milliseconds)",
        "B": "StartRampRateTrq(pTrqCommand, rampRate, maxMotorSpeed)",
        "C": "UpdateRampRateTrq(pTrqCommand, newRampRate, maxMotorSpeed)",
        "D": "StartRampTimeTrq(pTrqCommand, rampCycleTime, maxMotorSpeed)",
        "Answer(s)": "B"
    },
    {
        "No": 294,
        "Instruction": "Stop a torque command.",
        "A": "StopSuperimpose(axis)",
        "B": "SimulateTimeAtPos(pSimulatePosCommand, specificPos)",
        "C": "StopTrq(axis)",
        "D": "PauseTorque(axis)",
        "Answer(s)": "C"
    },
    {
        "No": 295,
        "Instruction": "Stop torque commands for multiple axes.",
        "A": "StopTrq_AxisSel(pAxisSelection)",
        "B": "StopTrq(axis)",
        "C": "Stop_AxisSel(pAxisSelection)",
        "D": "StopAxisSelect: (axisToStop)",
        "Answer(s)": "A"
    },
    {
        "No": 296,
        "Instruction": "Start a triggered torque command for an axis that is currently executing a position command.",
        "A": "SetTrqStartPos(pCmdTriggerTrq)",
        "B": "GetAbsoluteEncoderHomeOffset(axis)",
        "C": "StartVelToTrq(pTriggerTrqCommand)",
        "D": "StartPosToTrq(pTriggerTrqCommand)",
        "Answer(s)": "D"
    },
    {
        "No": 297,
        "Instruction": "Start triggered torque commands for multiple axes that are currently executing position commands.",
        "A": "StartVelToTrq(pTriggerTrqCommand)",
        "B": "StartPosToTrq(numCommands, pTriggerTrqCommand)",
        "C": "StartVelToTrq(numCommands, pTriggerTrqCommand)",
        "D": "UpdatePosToTrq(numFunctions, pDetectedTrqCmd)",
        "Answer(s)": "B"
    },
    {
        "No": 298,
        "Instruction": "Start a triggered torque command for an axis that is currently executing a position command. The trigger condition can have multiple trigger events.",
        "A": "GetHomeData()",
        "B": "UpdateStartPosToTrq_TriggerEvents(pTrqCmd, pTrigEvents)",
        "C": "StartPosToJog_TriggerEvents(pJogCommand, pTriggerEvents)",
        "D": "StartPosToTrq_TriggerEvents(pTrqCommand, pTriggerEvents)",
        "Answer(s)": "D"
    },
    {
        "No": 299,
        "Instruction": "Start triggered torque commands for multiple axes that are currently executing position commands. The trigger conditions can have multiple trigger events.",
        "A": "GetOutputData(buff, buffSize, dataSize)",
        "B": "UpdateTrqTrigEvent(numCommands, trqCommands, triggerEvents)",
        "C": "StartPosToTrq_TriggerEvents(numCommands, pTrqCommand, pTriggerEvents)",
        "D": "StartMov_TriggerEvents(numCommands, pPosCommand, pTriggerEvents)",
        "Answer(s)": "C"
    },
    {
        "No": 300,
        "Instruction": "Start a triggered torque command for an axis that is currently executing a velocity command.",
        "A": "StartVelToTrqWithOverride(pOverrideTriggerTrq)",
        "B": "SetFlightRecorderParam(axis, pParam)",
        "C": "StartTrq(pTrqCommand)",
        "D": "StartVelToTrq(pTriggerTrqCommand)",
        "Answer(s)": "D"
    },
    {
        "No": 301,
        "Instruction": "Start triggered torque commands for multiple axes that are currently executing velocity commands.",
        "A": "StartVelToTrq(numCommands, triggerTorqueCommand)",
        "B": "StartVelToTrq(numCommands, pTriggerTrqCommand)",
        "C": "GetSyncParam(axis)",
        "D": "StartVelToTrq(pTriggerTrqCommand)",
        "Answer(s)": "B"
    },
    {
        "No": 302,
        "Instruction": "Start a triggered torque command for an axis that is currently executing a velocity command. The trigger condition can have multiple trigger events.",
        "A": "Export_SysPrm_AxisPrm_Axis(pPath, pParam, pAxisParam, axis)",
        "B": "StartVelToTrq_TriggerEvents(pTrqCommand, pTriggerEvents)",
        "C": "SetTrqCmdAndTriggerEvents(pTrqCmd, pEvents)",
        "D": "StartVelToMov_TriggerEvents(pPosCommand, pTriggerEvents)",
        "Answer(s)": "B"
    },
    {
        "No": 303,
        "Instruction": "Start triggered torque commands for multiple axes that are currently executing velocity commands. The trigger conditions can have multiple trigger events.",
        "A": "StartVelToTrq_TriggerEvents(numCommands, pTrqCommand, pTriggerEvents)",
        "B": "AdjustStartVelToTrq_TriggerEvents(numCommands, pTrqCommand, pTriggerEvents)",
        "C": "StartMovToJog(pPosToJogCommand)",
        "D": "StartVelToPos_TriggerEvents(numCommands, pPosCommand, pTriggerEvents)",
        "Answer(s)": "A"
    },
    {
        "No": 304,
        "Instruction": "Return TRUE if this class object has access to a device, and FALSE otherwise. A device is required to execute most functions in this class. If this function returns FALSE, a device can be created by calling the CreateDevice function from the WMX3Api object that was passed to the constructor of this class.",
        "A": "IsDeviceValid()",
        "B": "IsDeviceValidCheck()",
        "C": "GetMasterInfo()",
        "D": "StartVelToPos(pTriggerPosCommand)",
        "Answer(s)": "A"
    },
    {
        "No": 305,
        "Instruction": "Set system parameter settings for all axes.",
        "A": "GetDefaultParam(pParam)",
        "B": "UpdateParam(pUpdatedParam)",
        "C": "ApiLogToString(pLogData, logDataSize)",
        "D": "SetParam(pParam)",
        "Answer(s)": "D"
    },
    {
        "No": 306,
        "Instruction": "Get system parameter settings for all axes.",
        "A": "FetchParameter()",
        "B": "GetParam()",
        "C": "StartRampTimeTrq(pTrqCommand, rampCycleTime)",
        "D": "GetSyncParam(axis)",
        "Answer(s)": "B"
    },
    {
        "No": 307,
        "Instruction": "Set system parameter settings for a single axis.",
        "A": "GetParam_Axis(axis)",
        "B": "SetParam_Axis(axis, pParam)",
        "C": "SetParam_Axis(axis_index, param_value)",
        "D": "SetHomeParam(axis, pParam)",
        "Answer(s)": "B"
    },
    {
        "No": 308,
        "Instruction": "Get system parameter settings for a single axis.",
        "A": "StartPVT(AdvMotion_PVTCommand pPVTCommand)",
        "B": "GetSyncParam(axis)",
        "C": "GetParam_Axis(axis)",
        "D": "AccessAxisParam(axis)",
        "Answer(s)": "C"
    },
    {
        "No": 309,
        "Instruction": "Set axis parameters for all axes.",
        "A": "SetParam(pParam)",
        "B": "SetAxisParam(pParam)",
        "C": "SetPositiveTrqLimit(axis, torque)",
        "D": "SetParamAxis(pAxisParam)",
        "Answer(s)": "B"
    },
    {
        "No": 310,
        "Instruction": "Get axis parameters for all axes.",
        "A": "GetAxisParameters()",
        "B": "GetVersion()",
        "C": "GetAxisParam()",
        "D": "GetDefaultAxisParam()",
        "Answer(s)": "C"
    },
    {
        "No": 311,
        "Instruction": "Set axis parameters for a single axis.",
        "A": "SetAxisParam_Axis(axis, pParam)",
        "B": "ExecTimedStop_TimeMilli(axis, timeMilliseconds)",
        "C": "SetAlarmParam(axis, pParam)",
        "D": "SetAxisParameter(axis, parameter)",
        "Answer(s)": "A"
    },
    {
        "No": 312,
        "Instruction": "Get axis parameters for a single axis.",
        "A": "GetAxisParam_Axis(axis)",
        "B": "SetParam_Axis(axis, pParam)",
        "C": "StartVel(numCommands, pVelCommand)",
        "D": "GetAxisInfo_Axis(axis)",
        "Answer(s)": "A"
    },
    {
        "No": 313,
        "Instruction": "Set the gear ratio of the axis.",
        "A": "SetServoOn(axis, newStatus)",
        "B": "SetGearRatio(axis, numerator, denominator)",
        "C": "SetGearRatio(axisIndex, newNumerator, newDenominator)",
        "D": "GetOutputData(buff, buffSize, dataSize)",
        "Answer(s)": "B"
    },
    {
        "No": 314,
        "Instruction": "Set the single turn mode and single turn encoder count of an axis.",
        "A": "StartMovToJog(pPosToJogCommand)",
        "B": "SetAbsoluteEncoderMode(axis, enable)",
        "C": "SetSingleTurn(axis, enable. encoderCount)",
        "D": "SetSingleTurn(axis, enable, encoderCount)",
        "Answer(s)": "C"
    },
    {
        "No": 315,
        "Instruction": "Set the moving average profile time parameter for an axis.",
        "A": "ExecTimedStop_TimeMilli(axis, timeMilliseconds)",
        "B": "SimulatePos(pSimulatePosCommand)",
        "C": "SetRealTimeMovingAverageProfile(axis, milliseconds)",
        "D": "SetMovingAverageProfileTime(axis, milliseconds)",
        "Answer(s)": "D"
    },
    {
        "No": 316,
        "Instruction": "Set the axis unit parameter for an axis.",
        "A": "GetSyncParam(axis)",
        "B": "SetAxisUnit(axis, unit)",
        "C": "SetAxisMeasureUnit(axis, unit)",
        "D": "GetAxisPolatity(axis)",
        "Answer(s)": "B"
    },
    {
        "No": 317,
        "Instruction": "Set the velocity feedforward gain parameter for an axis.",
        "A": "SetVelocityFeedforwardGain(axis_number, new_gain)",
        "B": "SetVelocityFeedforwardGain(axis, gain)",
        "C": "GetParam()",
        "D": "SetFeedbackParam(axis, pParam)",
        "Answer(s)": "B"
    },
    {
        "No": 318,
        "Instruction": "Set the axis polarity for an axis.",
        "A": "SetSyncParam(axis, pParam)",
        "B": "StartPos_TriggerEvents(numCommands, pPosCommand, pTriggerEvents)",
        "C": "SetAxisDirection(axis, direction)",
        "D": "SetAxisPolarity(axis, polarity)",
        "Answer(s)": "D"
    },
    {
        "No": 319,
        "Instruction": "Set the absolute encoder mode for an axis.",
        "A": "SetAbsoluteEncoderMode(axis, enable)",
        "B": "Wait(axis)",
        "C": "GetAbsoluteEncoderHomeOffset(axis)",
        "D": "SetAbsoluteEncoderEnable(axis_number, is_enabled)",
        "Answer(s)": "A"
    },
    {
        "No": 320,
        "Instruction": "Set the absolute encoder home offset for an axis.",
        "A": "GetAbsoluteEncoderMode(axis)",
        "B": "TriggerFlightRecorder()",
        "C": "SetAbsoluteEncoderHomeOffset(axis, offset)",
        "D": "SetAbsoluteEncoderHomeOffsetForAxis(axis_number, new_offset_value)",
        "Answer(s)": "C"
    },
    {
        "No": 321,
        "Instruction": "Get the gear ratio of the axis.",
        "A": "GetGearRatios(vehicle)",
        "B": "GetAlarmParam(axis)",
        "C": "GetGearRatio(axis)",
        "D": "SetSingleTurn(axis, enable. encoderCount)",
        "Answer(s)": "C"
    },
    {
        "No": 322,
        "Instruction": "Get the single turn mode and single turn encoder count of an axis.",
        "A": "StartCircularIntplPos_ThroughAndEnd(pCircularIntplCommand)",
        "B": "ReadAxisRotation()",
        "C": "GetSingleTurn(axis)",
        "D": "GetAxisUnit(axis)",
        "Answer(s)": "C"
    },
    {
        "No": 323,
        "Instruction": "Get the moving average profile time parameter of an axis.",
        "A": "CalculateAverageProfileTime(axis, window_size)",
        "B": "GetMovingAverageProfileTime(axis)",
        "C": "Resume_AxisSel(pAxisSelection)",
        "D": "GetGearRatio(axis)",
        "Answer(s)": "B"
    },
    {
        "No": 324,
        "Instruction": "Get the axis unit parameter of an axis.",
        "A": "ExecTimedStop_TimeMilli(axis, timeMilliseconds)",
        "B": "GetAxisPolatity(axis)",
        "C": "GetNormalizedAxis(axis)",
        "D": "GetAxisUnit(axis)",
        "Answer(s)": "D"
    },
    {
        "No": 325,
        "Instruction": "Get the velocity feedforward gain of an axis.",
        "A": "CalculateVelocityFeedforwardGainOnAxis(axis)",
        "B": "GetPosFeedback(axis)",
        "C": "ClearSyncGroupError(groupId)",
        "D": "GetVelocityFeedforwardGain(axis)",
        "Answer(s)": "D"
    },
    {
        "No": 326,
        "Instruction": "Get the axis polarity of an axis.",
        "A": "GetAxisParam_Axis(axis)",
        "B": "GetAxisPolarity(axis_number)",
        "C": "GetAxisPolatity(axis)",
        "D": "SetLimitParam(axis, pParam)",
        "Answer(s)": "C"
    },
    {
        "No": 327,
        "Instruction": "Get the absolute encoder mode of an axis.",
        "A": "SetAbsoluteEncoderHomeOffset(axis, offset)",
        "B": "GetAbsoluteEncoderHomeOffset(axis)",
        "C": "GetAbsoluteEncoderModeForAxis(axis_id)",
        "D": "GetAbsoluteEncoderMode(axis)",
        "Answer(s)": "D"
    },
    {
        "No": 328,
        "Instruction": "Get the absolute encoder home offset of an axis.",
        "A": "GetIntegratedEncoderZeroOffset(axis)",
        "B": "SetAbsoluteEncoderHomeOffset(axis, offset)",
        "C": "GetAbsoluteEncoderHomeOffset(axis)",
        "D": "Wait_TimeMilli(axis, waitTimeMilliseconds)",
        "Answer(s)": "C"
    },
    {
        "No": 329,
        "Instruction": "Set feedback parameter settings for an axis.",
        "A": "GetMotionParam(axis)",
        "B": "GetFeedbackParam(axis)",
        "C": "SetFeedbackParam(axis, pParam)",
        "D": "SetAxisParam(axis, newParam)",
        "Answer(s)": "C"
    },
    {
        "No": 330,
        "Instruction": "Set home parameter settings for an axis.",
        "A": "StartCircularIntplMov_ThroughAndEnd(pCircularIntplCommand)",
        "B": "SetHomeParameter(axis, newParam)",
        "C": "SetHomeParam(axis, pParam)",
        "D": "SetParam_Axis(axis, pParam)",
        "Answer(s)": "C"
    },
    {
        "No": 331,
        "Instruction": "Set limit parameter settings for an axis.",
        "A": "SetAxisLimitParameter(axis, newParam)",
        "B": "SuperimposeMov(pPosCommand)",
        "C": "SetLimitParam(axis, pParam)",
        "D": "SetMotionParam(axis, pParam)",
        "Answer(s)": "C"
    },
    {
        "No": 332,
        "Instruction": "Set motion parameter settings for an axis.",
        "A": "SetMotionParam(axis, pParam)",
        "B": "SetLimitParam(axis, pParam)",
        "C": "StartPosToTrq_TriggerEvents(pTrqCommand, pTriggerEvents)",
        "D": "SetMotionParameters(axis, newParams)",
        "Answer(s)": "A"
    },
    {
        "No": 333,
        "Instruction": "Set alarm parameter settings for an axis.",
        "A": "IsDeviceValid()",
        "B": "SetLimitParam(axis, pParam)",
        "C": "SetAlarmConfiguration(axis, params)",
        "D": "SetAlarmParam(axis, pParam)",
        "Answer(s)": "D"
    },
    {
        "No": 334,
        "Instruction": "Set sync parameter settings for an axis.",
        "A": "SetLimitParam(axis, pParam)",
        "B": "SetAxisSyncParam(axis, newParam)",
        "C": "SetSyncParam(axis, pParam)",
        "D": "StartTrqToMov_TriggerEvents(pPosCommand, pTriggerEvents)",
        "Answer(s)": "C"
    },
    {
        "No": 335,
        "Instruction": "Set flight recorder parameters.",
        "A": "SetFlightRecorderParamNew(axis, newParam)",
        "B": "StartMov_TriggerEvents(numCommands, pPosCommand, pTriggerEvents)",
        "C": "SetHomeParam(axis, pParam)",
        "D": "SetFlightRecorderParam(axis, pParam)",
        "Answer(s)": "D"
    },
    {
        "No": 336,
        "Instruction": "Set the file path to save the flight recorder data to.",
        "A": "SetFlightRecorderPath(pPath)",
        "B": "SetParam(pParam)",
        "C": "SetFlightRecorderPath(path)",
        "D": "ResetFlightRecorder()",
        "Answer(s)": "A"
    },
    {
        "No": 337,
        "Instruction": "Set emergency stop parameters.",
        "A": "SetEmergencyStopParam(pParam)",
        "B": "Export_SysPrm_Axis(pPath, pParam, axis)",
        "C": "SetHomeParam(axis, pParam)",
        "D": "SetEmergencyStopParameter(pParameter)",
        "Answer(s)": "A"
    },
    {
        "No": 338,
        "Instruction": "Get feedback parameter settings for an axis.",
        "A": "GetFeedbackAxisParam(feedback_axis)",
        "B": "SetFeedbackParam(axis, pParam)",
        "C": "StartPVT_Intpl(pPVTCommand, numAddlCommands, PyObject *pPVTAddlCommand)",
        "D": "GetFeedbackParam(axis)",
        "Answer(s)": "D"
    },
    {
        "No": 339,
        "Instruction": "Get home parameter settings for an axis.",
        "A": "GetHomeParamsByAxis(axis)",
        "B": "GetAlarmParam(axis)",
        "C": "GetStatus()",
        "D": "GetHomeParam(axis)",
        "Answer(s)": "D"
    },
    {
        "No": 340,
        "Instruction": "Get limit switch parameter settings for an axis",
        "A": "SetLimitParam(axis, pParam)",
        "B": "OverrideVel(numCommands, pVelCommand)",
        "C": "GetLimitParam(axis)",
        "D": "GetAxisLimit(axis_length)",
        "Answer(s)": "C"
    },
    {
        "No": 341,
        "Instruction": "Get motion parameter settings for an axis.",
        "A": "GetMotionParam(axis)",
        "B": "GetMotionParamsForAxis(axis)",
        "C": "StartPosToJog_PosToJog(numCommands, pPosToJogCommand)",
        "D": "SetMotionParam(axis, pParam)",
        "Answer(s)": "A"
    },
    {
        "No": 342,
        "Instruction": "Get alarm parameter settings for an axis.",
        "A": "GetPosFeedback(axis)",
        "B": "GetAlarmParam(axis)",
        "C": "SetAlarmParam(axis, pParam)",
        "D": "DisarmAlarmParam(axis)",
        "Answer(s)": "B"
    },
    {
        "No": 343,
        "Instruction": "Get the sync parameters of the axis.",
        "A": "ClearSyncGroupError(groupId)",
        "B": "GetMotionParam(axis)",
        "C": "FetchSyncParam(axis)",
        "D": "GetSyncParam(axis)",
        "Answer(s)": "D"
    },
    {
        "No": 344,
        "Instruction": "Get flight recorder parameters.",
        "A": "GetFlightRecorderParam()",
        "B": "GetFlightRecorderParameters()",
        "C": "SetFlightRecorderPath(pPath)",
        "D": "StartVel(numCommands, pVelCommand)",
        "Answer(s)": "A"
    },
    {
        "No": 345,
        "Instruction": "Get emergency stop parameters.",
        "A": "GetEmergencyStopParams()",
        "B": "GetHomeParam(axis)",
        "C": "GetEmergencyStopParam()",
        "D": "StartLinearIntplPos(pLinearIntplCommand)",
        "Answer(s)": "C"
    },
    {
        "No": 346,
        "Instruction": "Get the default system parameters.",
        "A": "GetDefaultParamValue(paramName)",
        "B": "GetDefaultParam(pParam)",
        "C": "GetDefaultAxisParam()",
        "D": "Wait_WaitCondition_TimeMilli(pWaitCondition, waitTimeMilliseconds)",
        "Answer(s)": "B"
    },
    {
        "No": 347,
        "Instruction": "Get the default axis parameters.",
        "A": "GetDefaultAxisParams()",
        "B": "GetParam_Axis(axis)",
        "C": "GetDefaultAxisParam()",
        "D": "GetAlarmParam(axis)",
        "Answer(s)": "C"
    },
    {
        "No": 348,
        "Instruction": "Export system parameters to an xml file.",
        "A": "Export_SysPrm(pPath, pParam)",
        "B": "GetFeedbackParam(axis)",
        "C": "Export_SysPrm_Axis(pPath, pParam, axis)",
        "D": "Update_SysPrm(pConfigPath, pParameters)",
        "Answer(s)": "A"
    },
    {
        "No": 349,
        "Instruction": "Export axis parameters to an xml file.",
        "A": "Export_AxisParameters(path, axis_parameters)",
        "B": "SetAxisUnit(axis, unit)",
        "C": "Export_SysPrm_Axis(pPath, pParam, axis)",
        "D": "Export_AxisPrm(pPath, pAxisParam)",
        "Answer(s)": "D"
    },
    {
        "No": 350,
        "Instruction": "Export system and axis parameters to an xml file.",
        "A": "Export_SystemParameter_AxisParameter(filePath, paramValue, axisParameterValue)",
        "B": "StartPVT(AdvMotion_PVTCommand pPVTCommand)",
        "C": "Export_SysPrm_AxisPrm(pPath, pParam, pAxisParam)",
        "D": "Export_SysPrm(pPath, pParam)",
        "Answer(s)": "C"
    },
    {
        "No": 351,
        "Instruction": "Export system parameters of one axis to an xml file.",
        "A": "StartRampRateTrq(pTrqCommand, rampRate)",
        "B": "Update_SysPrm_Axis_Path(pNewPath, pParam, newAxis)",
        "C": "Export_AxisPrm_Axis(pPath, pAxisParam, axis)",
        "D": "Export_SysPrm_Axis(pPath, pParam, axis)",
        "Answer(s)": "D"
    },
    {
        "No": 352,
        "Instruction": "Export axis parameters of one axis to an xml file.",
        "A": "Export_AxisParam_and_Axis_Params(path, axis_parameters, axis_value)",
        "B": "OverrideVel(pPosCommand)",
        "C": "Export_AxisPrm_Axis(pPath, pAxisParam, axis)",
        "D": "Export_SysPrm_AxisPrm_Axis(pPath, pParam, pAxisParam, axis)",
        "Answer(s)": "C"
    },
    {
        "No": 353,
        "Instruction": "Export system parameters to an xml file.",
        "A": "ExecTimedStop_TimeMilli(axis, timeMilliseconds)",
        "B": "Export_SysPrm_AxisPrm_Axis(pPath, pParam, pAxisParam, axis)",
        "C": "Export_SysPrm_AxisPrm_ByAxis(pPath, pParam, pAxisParam, axis)",
        "D": "Export_AxisPrm(pPath, pAxisParam)",
        "Answer(s)": "B"
    },
    {
        "No": 354,
        "Instruction": "Import system parameters from an xml file.",
        "A": "Export_SysPrm(pPath, pParam)",
        "B": "Import_SysPrm(pPath)",
        "C": "StartJog_TimedJog(pTimedJogCommand)",
        "D": "Load_System_Params(path_name)",
        "Answer(s)": "B"
    },
    {
        "No": 355,
        "Instruction": "Import axis parameters from an xml file.",
        "A": "SetFlightRecorderParam(axis, pParam)",
        "B": "Import_AxisPrm(pPath)",
        "C": "Update_AxisParms(path)",
        "D": "Export_AxisPrm(pPath, pAxisParam)",
        "Answer(s)": "B"
    },
    {
        "No": 356,
        "Instruction": "Import system and axis parameters from an xml file.",
        "A": "GetFeedbackParam(axis)",
        "B": "Import_SysPrm_AxisPrm(pPath)",
        "C": "Export_SysParam_AxisParam(pPath)",
        "D": "Import_SysPrm_AxisPrm_Axis(pPath, axis, copyParamToAxes)",
        "Answer(s)": "B"
    },
    {
        "No": 357,
        "Instruction": "Import system parameters of one axis from an xml file.",
        "A": "Update_SysPrm_Axis(pPath, axisName, newParamValues)",
        "B": "ReleaseEStop()",
        "C": "Export_SysPrm_Axis(pPath, pParam, axis)",
        "D": "Import_SysPrm_Axis(pPath, axis, copyParamToAxes)",
        "Answer(s)": "D"
    },
    {
        "No": 358,
        "Instruction": "Import axis parameters of one axis from an xml file.",
        "A": "Export_AxisPrm_Axis(pPath, axis, updateParamOnAxes):",
        "B": "Import_AxisPrm_Axis(pPath, axis, copyParamToAxes)",
        "C": "OverrideVel(pPosCommand)",
        "D": "Export_AxisPrm_Axis(pPath, pAxisParam, axis)",
        "Answer(s)": "B"
    },
    {
        "No": 359,
        "Instruction": "Import system and axis parameters of one axis from an xml file.",
        "A": "Continue_AxisSel(pAxisSelection)",
        "B": "Import_System_Parameters_Axis_Parameters(axisPath, axisName, copyParametersToAllAxes)",
        "C": "Import_AxisPrm_Axis(pPath, axis, copyParamToAxes)",
        "D": "Import_SysPrm_AxisPrm_Axis(pPath, axis, copyParamToAxes)",
        "Answer(s)": "D"
    },
    {
        "No": 360,
        "Instruction": "Get the current parameters for all axes and export them to an xml file.",
        "A": "FetchAndSaveAllData(pDirectory)",
        "B": "StartCircularIntplPos_ThroughAndEnd3D_TriggerEvents(pCircularIntplCommand, pTriggerEvents)",
        "C": "GetDefaultParam(pParam)",
        "D": "GetAndExportAll(pPath)",
        "Answer(s)": "D"
    },
    {
        "No": 361,
        "Instruction": "Imports parameters from an xml file and set them as the current parameters for all axes.",
        "A": "ImportAndSetAll(path)",
        "B": "Import_SysPrm(pPath)",
        "C": "loadAndInitializeAll(path)",
        "D": "StartPos(numCommands, pPosCommand)",
        "Answer(s)": "A"
    },
    {
        "No": 362,
        "Instruction": "Get a string representation of the specified error code.",
        "A": "CreatePathIntplWithRotationBuffer(channel, points)",
        "B": "ErrorToDescription(code)",
        "C": "ErrorToString(errCode)",
        "D": "StartPosToJog_PosToJog(pPosToJogCommand)",
        "Answer(s)": "C"
    },
    {
        "No": 363,
        "Instruction": "Get a string representation of the raw data of an API log.",
        "A": "SetLogOption(channel, pOption)",
        "B": "ApiLogToString(pLogData, logDataSize)",
        "C": "ApiLogDataToString(pApiLogData, apiLogDataSize)",
        "D": "FreeSplineBuffer(channel)",
        "Answer(s)": "B"
    },
    {
        "No": 364,
        "Instruction": "Get the version of the module library.",
        "A": "StartCBSplinePos_TotalTime (channel, pSplineCommand, numPoints, pPoint)",
        "B": "GetLibVersion()",
        "C": "FetchLibraryVersion():",
        "D": "GetMaxMotorSpeed(axis)",
        "Answer(s)": "B"
    },
    {
        "No": 365,
        "Instruction": "Return TRUE if this class object has access to a device, and FALSE otherwise. A device is required to execute most functions in this class. If this function returns FALSE, a device can be created by calling the CreateDevice function from the WMX3Api object that was passed to the constructor of this class.",
        "A": "GetInAnalogDataUInt(addr)",
        "B": "IsDeviceValid()",
        "C": "IsDeviceValid(deviceID: string): boolean",
        "D": "StartPathIntpl3DPos_Trigger(pPathIntplCommand, pTrigger, numAddlCommands, pPathIntplAddlCommand)",
        "Answer(s)": "B"
    },
    {
        "No": 366,
        "Instruction": "Get the version of the module rtdll.",
        "A": "SetConstantLinearVel(masterAxis, slaveAxis, centerPos, minR,positiveMaxR, negativeMaxR, constLinVel, initVelVariance)",
        "B": "GetAppVersion()",
        "C": "IsDeviceValid()",
        "D": "GetVersion()",
        "Answer(s)": "D"
    },
    {
        "No": 367,
        "Instruction": "Return TRUE if this class object has access to a device, and FALSE otherwise. A device is required to execute most functions in this class. If this function returns FALSE, a device can be created by calling the CreateDevice function from the WMX3Api object that was passed to the constructor of this class.",
        "A": "IsDeviceValid(device_id)",
        "B": "StartTwoLinkLinearMov(pTwoLinkCommand)",
        "C": "SetSyncMasterSlave(masterAxis, slaveAxis)",
        "D": "IsDeviceValid()",
        "Answer(s)": "D"
    },
    {
        "No": 368,
        "Instruction": "Allocate buffer memory for a spline execution channel.",
        "A": "CreateSplineBuffer(channel, points)",
        "B": "CreatePathIntplWithRotationBuffer(channel, points)",
        "C": "CreateSplineStructure(channel, points)",
        "D": "GetSplineBufferPoints(channel)",
        "Answer(s)": "A"
    },
    {
        "No": 369,
        "Instruction": "Free buffer memory for a spline execution channel.",
        "A": "FreeSplineBuffer(channel_id)",
        "B": "FreePathIntplWithRotationBuffer(channel)",
        "C": "CreateSplineBuffer(channel, points)",
        "D": "FreeSplineBuffer(channel)",
        "Answer(s)": "D"
    },
    {
        "No": 370,
        "Instruction": "Get the amount of buffer memory currently allocated to a spline execution channel.",
        "A": "AddPathIntplWithRotationCommand(channel, pCommand)",
        "B": "FreeSplineBuffer(channel)",
        "C": "GetSplineBufferPoints(channel)",
        "D": "GetSplineBufferPoints(channel_name)",
        "Answer(s)": "C"
    },
    {
        "No": 371,
        "Instruction": "Get the number of bytes required per point data in the spline execution buffer memory.",
        "A": "GetSplineBytesPerPointV2()",
        "B": "GetSplineBytesPerPoint()",
        "C": "StartCBSplineMov_Profile (channel, pSplineCommand, numPoints, pPoint)",
        "D": "GetPathIntplWithRotationBytesPerPoint()",
        "Answer(s)": "B"
    },
    {
        "No": 372,
        "Instruction": "Start a cubic spline motion command in which the time at each point is specified. The point positions are specified as absolute positions.",
        "A": "StartCSplinePos_PointTime (channel, pSplineCommand, numPoints, pPoint, pPointTimeMilliseconds)",
        "B": "StartCBSplinePos_PointTime (channel, pSplineCommand, numPoints, pPoint, pPointTimeMilliseconds)",
        "C": "StartTwoLinkLinearPos(pTwoLinkCommand)",
        "D": "StartCSplinePos_PointTime_v2(channel, pSplineCommand, numPoints, pPoint, pTimeMilliseconds)",
        "Answer(s)": "A"
    },
    {
        "No": 373,
        "Instruction": "Start a cubic spline motion command in which the total time to complete the spline is specified. The point positions are specified as absolute positions.",
        "A": "StartCSplinePos_Profile (channel, pSplineCommand, numPoints, pPoint)",
        "B": "StartPathIntplPos_TriggerEvents(pPathIntplCommand, pTriggerEvents, numAddlCommands, pPathIntplAddlCommand)",
        "C": "UpdateCSplineTotalTime(channel, pSplineCommand, numPoints, pPoint)",
        "D": "StartCSplinePos_TotalTime (channel, pSplineCommand, numPoints, pPoint)",
        "Answer(s)": "D"
    },
    {
        "No": 374,
        "Instruction": "Start a cubic spline motion command in which the spline is traversed using a motion profile. The point positions are specified as absolute positions.",
        "A": "InitiateCubicSplinePositionProfile(channel, splineCommand, numPoints, points)",
        "B": "SetPathIntplWithRotationConfiguration(channel, AdvMotion_PathIntplWithRotationConfiguration pConfig)",
        "C": "StartCSplinePos_Profile (channel, pSplineCommand, numPoints, pPoint)",
        "D": "StartCSplineMov_Profile (channel, pSplineCommand, numPoints, pPoint)",
        "Answer(s)": "C"
    },
    {
        "No": 375,
        "Instruction": "Start a cubic spline motion command in which the spline is traversed while staying within the specified velocity and acceleration limits for each axis. The point positions are specified as absolute positions.",
        "A": "StartCubicSplineWithLimitedAcc(channel, pSplineCommand, numPoints, pPoint)",
        "B": "StartCSplinePos_VelAccLimited (channel, pSplineCommand, numPoints, pPoint)",
        "C": "StartPathIntplWithRotation_Pos(channel, double pos)",
        "D": "StartCSplinePos_TotalTime (channel, pSplineCommand, numPoints, pPoint)",
        "Answer(s)": "B"
    },
    {
        "No": 376,
        "Instruction": "Start a cubic spline motion command in which the time at each point is specified. The point positions are specified as relative positions.",
        "A": "StartTwoLinkLinearMov(pTwoLinkCommand)",
        "B": "StartCSplineMov_PointTime (channel, pSplineCommand, numPoints, pPoint, pPointTimeMilliseconds)",
        "C": "StartCSplineMov_PointTimeFromPointsList (channel, pSplineCommand, numPoints, pointsList, pointsTimeMilliseconds)",
        "D": "StartCBSplinePos_PointTime (channel, pSplineCommand, numPoints, pPoint, pPointTimeMilliseconds)",
        "Answer(s)": "B"
    },
    {
        "No": 377,
        "Instruction": "Start a cubic spline motion command in which the total time to complete the spline is specified. The point positions are specified as relative positions.",
        "A": "StartCBSplineMov_PointTime (channel, pSplineCommand, numPoints, pPoint, pPointTimeMilliseconds)",
        "B": "StartCSplineMov_TotalTime (channel, pSplineCommand, numPoints, pPoint)",
        "C": "StartCSplineMov_Profile (channel, pSplineCommand, numPoints, pPoint)",
        "D": "CalculateCSplineMov_TimeRemaining (channel, pSplineCommand, numPoints, pPoint)",
        "Answer(s)": "B"
    },
    {
        "No": 378,
        "Instruction": "Start a cubic spline motion command in which the spline is traversed using a motion profile. The point positions are specified as relative positions.",
        "A": "StartCSplineMov_Profile (channel, pSplineCommand, numPoints, pPoint)",
        "B": "StartCSplinePos_Profile (channel, pSplineCommand, numPoints, pPoint)",
        "C": "StartCSplineMov_ProfileChanged(channel, pSplineCommand, numPoints, pPoint)",
        "D": "CreateSplineBuffer(channel, points)",
        "Answer(s)": "A"
    },
    {
        "No": 379,
        "Instruction": "Start a cubic spline motion command in which the spline is traversed while staying within the specified velocity and acceleration limits for each axis. The point positions are specified as relative positions.",
        "A": "StartCSplineMovement_VelocityAccelerationLimited(channel, pSplineCmd, numPts, pPts)",
        "B": "StartCBSplinePos_VelAccLimited(channel, pSplineCommand, numPoints, pPoint)",
        "C": "StartCSplineMov_VelAccLimited (channel, pSplineCommand, numPoints, pPoint)",
        "D": "GetPathIntplWithRotationBytesPerPoint()",
        "Answer(s)": "C"
    },
    {
        "No": 380,
        "Instruction": "Start a cubic basis spline motion command in which the time at each point is specified. The point positions are specified as absolute positions.",
        "A": "StartCBSplinePos_PointTime (channel, pSplineCommand, numPoints, pPoint, pPointTimeMilliseconds)",
        "B": "StartCSplineMov_PointTime (channel, pSplineCommand, numPoints, pPoint, pPointTimeMilliseconds)",
        "C": "StartCSplinePos_PointTime (channel, pSplineCommand, numPoints, pPoint, pPointTimeMilliseconds)",
        "D": "StartCubicSplinePositionWithTime (channel, splineCommand, numControlPoints, controlPointCoordinates, controlPointTimeArray)",
        "Answer(s)": "A"
    },
    {
        "No": 381,
        "Instruction": "Start a cubic basis spline motion command in which the total time to complete the spline is specified. The point positions are specified as absolute positions.",
        "A": "SetupCBSplineMotion_TotalDuration(channel, pSplineCommand, numPoints, pPoint)",
        "B": "StartCBSplineMov_TotalTime (channel, pSplineCommand, numPoints, pPoint)",
        "C": "StartCBSplinePos_TotalTime (channel, pSplineCommand, numPoints, pPoint)",
        "D": "StartPathIntplMov_Trigger(pPathIntplCommand, pTrigger)",
        "Answer(s)": "C"
    },
    {
        "No": 382,
        "Instruction": "Start a cubic basis spline motion command in which the spline is traversed using a motion profile. The point positions are specified as absolute positions.",
        "A": "StartCBSplinePos_Profile (channel, pSplineCommand, numPoints, pPoint)",
        "B": "GetPathIntplWithRotationStatus(channel)",
        "C": "InitializeCBSplinePositionProfile(channel, splineType, numPositions, positions)",
        "D": "StartCSplineMov_Profile (channel, pSplineCommand, numPoints, pPoint)",
        "Answer(s)": "A"
    },
    {
        "No": 383,
        "Instruction": "Start a cubic basis spline motion command in which the spline is traversed while staying within the specified velocity and acceleration limits for each axis. The point positions are specified as absolute positions.",
        "A": "StartCSplinePos_TotalTime (channel, pSplineCommand, numPoints, pPoint)",
        "B": "StartCubicSplinePosVelAccLimited(channel, pSplineCommand, numPoints, pPoint)",
        "C": "StartCBSplinePos_VelAccLimited(channel, pSplineCommand, numPoints, pPoint)",
        "D": "StartPathIntplMov_Trigger(pPathIntplCommand, pTrigger)",
        "Answer(s)": "C"
    },
    {
        "No": 384,
        "Instruction": "Start a cubic basis spline motion command in which the time at each point is specified. The point positions are specified as relative positions.",
        "A": "UpdateCBSplineMovementTiming(channel, pSplineCommand, numPoints, pPoint, pPointTimeMilliseconds)",
        "B": "StartCBSplineMov_TotalTime (channel, pSplineCommand, numPoints, pPoint)",
        "C": "StartCBSplineMov_PointTime (channel, pSplineCommand, numPoints, pPoint, pPointTimeMilliseconds)",
        "D": "StartCSplinePos_PointTime (channel, pSplineCommand, numPoints, pPoint, pPointTimeMilliseconds)",
        "Answer(s)": "C"
    },
    {
        "No": 385,
        "Instruction": "Start a cubic basis spline motion command in which the total time to complete the spline is specified. The point positions are specified as relative positions.",
        "A": "StartCBSplineMov_TotalTime (channel, pSplineCommand, numPoints, pPoint)",
        "B": "SimulateTimeAtDist_3D(pPathIntplCommand, specificDistance)",
        "C": "EndCBSplineMov_TotalTime(channel, pSplineCommand, numPoints, pPoint)",
        "D": "StartCSplinePos_TotalTime (channel, pSplineCommand, numPoints, pPoint)",
        "Answer(s)": "A"
    },
    {
        "No": 386,
        "Instruction": "Start a cubic basis spline motion command in which the spline is traversed using a motion profile. The point positions are specified as relative positions.",
        "A": "StartCubicSplineMovementWithProfile(channel, splineCommand, numPoints, pointList)",
        "B": "StartCBSplineMov_Profile (channel, pSplineCommand, numPoints, pPoint)",
        "C": "StartCBSplinePos_Profile (channel, pSplineCommand, numPoints, pPoint)",
        "D": "StartPathIntpl3DMov(pPathIntplCommand)",
        "Answer(s)": "B"
    },
    {
        "No": 387,
        "Instruction": "Start a cubic basis spline motion command in which the spline is traversed while staying within the specified velocity and acceleration limits for each axis. The point positions are specified as relative positions.",
        "A": "StartCBSplineMov_VelAccLimited(channel, pSplineCommand, numPoints, pPoint)",
        "B": "StartTwoLinkUntetheredRotaryPos(pTwoLinkCommand)",
        "C": "StartCSplineMov_TotalTime (channel, pSplineCommand, numPoints, pPoint)",
        "D": "StartCubicSplineMovementWithLimitedVelAcc(channel, pSplineCmd, numPoints, pPoints)",
        "Answer(s)": "A"
    },
    {
        "No": 388,
        "Instruction": "Allocate buffer memory to an axis for the execution of path interpolation commands.",
        "A": "CreatePVTBuffer(axis, points)",
        "B": "StartCBSplinePos_TotalTime (channel, pSplineCommand, numPoints, pPoint)",
        "C": "CreatePathIntplBuffer(axis, unsigned points)",
        "D": "CreatePathInterpolatorBuffer(axis, unsigned int numPoints)",
        "Answer(s)": "C"
    },
    {
        "No": 389,
        "Instruction": "Free path interpolation buffer memory for an axis.",
        "A": "CreatePathIntplBuffer(axis, unsigned points)",
        "B": "FreePathIntplBuffer(axis)",
        "C": "ImproveFreePathIntplBuffer(axis)",
        "D": "StartPathIntplWithRotation_Point(channel, point)",
        "Answer(s)": "B"
    },
    {
        "No": 390,
        "Instruction": "Get the amount of path interpolation buffer memory currently allocated to an axis.",
        "A": "GetInterpolatedBufferPoints(axis, pPoints)",
        "B": "StartCBSplinePos_Profile (channel, pSplineCommand, numPoints, pPoint)",
        "C": "GetPathIntplBufferPoints(axis, pPoints)",
        "D": "GetPVTBufferPoints(axis, pPoints)",
        "Answer(s)": "C"
    },
    {
        "No": 391,
        "Instruction": "Get the number of bytes required per point data in the path interpolation buffer memory.",
        "A": "GetPathIntplLookaheadBytesPerPoint()",
        "B": "StartPathIntplMov_Trigger(pPathIntplCommand, pTrigger, numAddlCommands, pPathIntplAddlCommand)",
        "C": "GetPathIntplBytesPerPoint(pBytes)",
        "D": "GetPathInterpolatedBytesPerPoint(prevBytes, nextBytes)",
        "Answer(s)": "C"
    },
    {
        "No": 392,
        "Instruction": "Start an absolute position path interpolation motion command. This motion combines line interpolation and circular interpolation in one path.",
        "A": "StartPathIntplPos(pPathIntplCommand)",
        "B": "StopECAM(channel)",
        "C": "StartPathIntplMov(pPathIntplCommand)",
        "D": "StartPathInterpolatorPosition(pInterpolatorPathCommand)",
        "Answer(s)": "A"
    },
    {
        "No": 393,
        "Instruction": "Start a relative position path interpolation motion command. This motion combines line interpolation and circular interpolation in one path.",
        "A": "StartPathIntpl3DPos(pPathIntplCommand, numAddlCommands, pPathIntplAddlCommand)",
        "B": "StartPathInterpolateMovement(pInterpolationPathCommand)",
        "C": "StartPathIntplMov(pPathIntplCommand)",
        "D": "StartPathIntpl3DPos(pPathIntplCommand)",
        "Answer(s)": "C"
    },
    {
        "No": 394,
        "Instruction": "Start an absolute position triggered path interpolation motion command. This motion combines line interpolation and circular interpolation in one path.",
        "A": "StartPathIntplWithRotation_Point_TriggerEvents(channel, point, TriggerEvents pTriggerEvents)",
        "B": "StartPathIntplPos_Trigger(pPathIntplCommand, pTrigger)",
        "C": "StartPathIntplPosWithTrigger(pInterpolatorPath, pTrigger)",
        "D": "StartPathIntplPos_TriggerEvents(pPathIntplCommand, pTriggerEvents)",
        "Answer(s)": "B"
    },
    {
        "No": 395,
        "Instruction": "Start a relative position triggered path interpolation motion command. This motion combines line interpolation and circular interpolation in one path.",
        "A": "StartPathIntplPos_Trigger(pPathIntplCommand, pTrigger)",
        "B": "StartPathIntplMov_Trigger(pPathIntplCommand, pTrigger)",
        "C": "InitiatePathInterpolationMovement(pCommand, pTrigger)",
        "D": "StartPathIntpl3DPos_Trigger(pPathIntplCommand, pTrigger, numAddlCommands, pPathIntplAddlCommand)",
        "Answer(s)": "B"
    },
    {
        "No": 396,
        "Instruction": "Start an absolute position triggered path interpolation motion command with multiple trigger events. This motion combines line interpolation and circular interpolation in one path.",
        "A": "GetLibVersion()",
        "B": "StartPathIntplPos_Trigger(pPathIntplCommand, pTrigger)",
        "C": "StartPathInterpolationWithEventTriggers(pathInterpolationCommand, triggerEvents)",
        "D": "StartPathIntplPos_TriggerEvents(pPathIntplCommand, pTriggerEvents)",
        "Answer(s)": "D"
    },
    {
        "No": 397,
        "Instruction": "Start a relative position triggered path interpolation motion command with multiple trigger events. This motion combines line interpolation and circular interpolation in one path.",
        "A": "StartPathIntplMov_TriggerEvents(pPathIntplCommand, pTriggerEvents)",
        "B": "StartPathIntpl3DPos_TriggerEvents(pPathIntplCommand, pTriggerEvents)",
        "C": "GetLibVersion()",
        "D": "StartPathInterpolationMove_TriggerEvents(pInterpolationCommand, pTriggerEvents)",
        "Answer(s)": "A"
    },
    {
        "No": 398,
        "Instruction": "Override a path interpolation motion using a velocity multiplier.",
        "A": "OverridePathInterpolatorVelocityMultiplier(int axisIndex, double newMultiplier)",
        "B": "StartPathIntpl3DMov(pPathIntplCommand)",
        "C": "OverridePathIntplVelocityMultiplier(int axis, double multiplier)",
        "D": "GetPathIntplBufferPoints(axis, pPoints)",
        "Answer(s)": "C"
    },
    {
        "No": 399,
        "Instruction": "Start an absolute position 3D path interpolation motion. This motion command combines line interpolation and circular interpolation in one path.",
        "A": "InitializePathInterpolation3DPosition(pathInterpolationCmd)",
        "B": "FreePathIntplWithRotationBuffer(channel)",
        "C": "StartPathIntplMov(pPathIntplCommand)",
        "D": "StartPathIntpl3DPos(pPathIntplCommand)",
        "Answer(s)": "D"
    },
    {
        "No": 400,
        "Instruction": "Start a relative position 3D path interpolation motion. This motion command combines line interpolation and circular interpolation in one path.",
        "A": "StartPathIntpl3DMov(pPathIntplCommand)",
        "B": "StartPathIntplMov_TriggerEvents(pPathIntplCommand, pTriggerEvents, numAddlCommands, pPathIntplAddlCommand)",
        "C": "StartPathIntplMov(pPathIntplCommand)",
        "D": "Start3DMovementPathInterpolation(pMovementPathCommand)",
        "Answer(s)": "A"
    },
    {
        "No": 401,
        "Instruction": "Start an absolute position triggered 3D path interpolation motion. This motion command combines line interpolation and circular interpolation in one path.",
        "A": "StartPathIntpl3DPos_TriggerWithOffset(pPathCommand, pTrigger, offset)",
        "B": "StartPathIntpl3DPos_TriggerEvents(pPathIntplCommand, pTriggerEvents)",
        "C": "StartPathIntpl3DPos_Trigger(pPathIntplCommand, pTrigger)",
        "D": "SetPathIntplWithRotationConfiguration(channel, AdvMotion_PathIntplWithRotationConfiguration pConfig)",
        "Answer(s)": "C"
    },
    {
        "No": 402,
        "Instruction": "Start a relative position triggered 3D path interpolation motion. This motion command combines line interpolation and circular interpolation in one path.",
        "A": "StartPathIntpl3DMov_TriggerWithCondition(pPathIntplCommand, Trigger pTrigger, Condition pCondition)",
        "B": "StartTwoLinkUntetheredLinearMov(pTwoLinkCommand)",
        "C": "StartPathIntplMov_TriggerEvents(pPathIntplCommand, pTriggerEvents)",
        "D": "StartPathIntpl3DMov_Trigger(pPathIntplCommand, Trigger pTrigger)",
        "Answer(s)": "D"
    },
    {
        "No": 403,
        "Instruction": "Start an absolute position triggered 3D path interpolation motion command with multiple trigger events. This motion combines line interpolation and circular interpolation in one path.",
        "A": "StartPathIntplMov_TriggerEvents(pPathIntplCommand, pTriggerEvents)",
        "B": "UpdatePathIntpl3DPos_TriggerEvents(pPathIntplCommand, pTriggerEvents)",
        "C": "StartPathIntpl3DPos_TriggerEvents(pPathIntplCommand, pTriggerEvents)",
        "D": "StartPathIntpl3DMov(pPathIntplCommand, numAddlCommands, pPathIntplAddlCommand)",
        "Answer(s)": "C"
    },
    {
        "No": 404,
        "Instruction": "Start a relative position triggered 3D path interpolation motion command with multiple trigger events. This motion combines line interpolation and circular interpolation in one path.",
        "A": "StartPathInterp3DMovementWithTriggers(pPathInterpolationCommand, pTriggerEvents)",
        "B": "StartPathIntplPos_TriggerEvents(pPathIntplCommand, pTriggerEvents)",
        "C": "StartPathIntpl3DMov_TriggerEvents(pPathIntplCommand, pTriggerEvents)",
        "D": "StartPathIntpl3DPos(pPathIntplCommand, numAddlCommands, pPathIntplAddlCommand)",
        "Answer(s)": "C"
    },
    {
        "No": 405,
        "Instruction": "Start an absolute position path interpolation motion command. This motion combines line interpolation and circular interpolation in one path.",
        "A": "UpdatePathIntplCommand(pPathIntplCommand, numAddlCommands, pAddedCommands)",
        "B": "StartPathIntpl3DPos(pPathIntplCommand, numAddlCommands, pPathIntplAddlCommand)",
        "C": "StartPathIntplMov(pPathIntplCommand, numAddlCommands, pPathIntplAddlCommand)",
        "D": "StartPathIntplPos(pPathIntplCommand, numAddlCommands, pPathIntplAddlCommand)",
        "Answer(s)": "D"
    },
    {
        "No": 406,
        "Instruction": "Start a relative position path interpolation motion command. This motion combines line interpolation and circular interpolation in one path.",
        "A": "StartInterpolatedMovementWithAdditionalCommands(pStartInterpolationCommand, numAdditionalCommands, pAdditionalInterpolationCommands)",
        "B": "ErrorToString(errCode)",
        "C": "StartPathIntplMov(pPathIntplCommand, numAddlCommands, pPathIntplAddlCommand)",
        "D": "StartPathIntpl3DPos(pPathIntplCommand, numAddlCommands, pPathIntplAddlCommand)",
        "Answer(s)": "C"
    },
    {
        "No": 407,
        "Instruction": "Start an absolute position triggered path interpolation motion command. This motion combines line interpolation and circular interpolation in one path.",
        "A": "StartPathIntplMov_Trigger(pPathIntplCommand, pTrigger, numAddlCommands, pPathIntplAddlCommand)",
        "B": "SimulatePosAtTime_3D(self, pPathIntplCommand, timeMilliseconds)",
        "C": "StartNewPathTrigger(pNewPathCommand, pTrigger, numAdditionalCommands, pAdditionalPathCommand)",
        "D": "StartPathIntplPos_Trigger(pPathIntplCommand, pTrigger, numAddlCommands, pPathIntplAddlCommand)",
        "Answer(s)": "D"
    },
    {
        "No": 408,
        "Instruction": "Start a relative position triggered path interpolation motion command. This motion combines line interpolation and circular interpolation in one path.",
        "A": "StartPathIntplMov_Trigger(pPathIntplCommand, pTrigger)",
        "B": "StartPathIntplMov_Trigger(pPathIntplCommand, pTrigger, numAddlCommands, pPathIntplAddlCommand)",
        "C": "StartPathIntplMov_TriggerWithDelay(pPathIntplCommand, pTrigger, numAddlCommands, pPathIntplAddlCommand)",
        "D": "StartPathIntpl3DPos_Trigger(pPathIntplCommand, pTrigger, numAddlCommands, pPathIntplAddlCommand)",
        "Answer(s)": "B"
    },
    {
        "No": 409,
        "Instruction": "Start an absolute position triggered path interpolation motion command with multiple trigger events. This motion combines line interpolation and circular interpolation in one path.",
        "A": "StartPathIntplMov_TriggerEvents(pPathIntplCommand, pTriggerEvents, numAddlCommands, pPathIntplAddlCommand)",
        "B": "StartPathIntplPos_TriggerEvents_AdditionalCommands(pPathIntplCommand, pTriggerEvents, numAddlCommands, pPathIntplAddlCommand)",
        "C": "StartPathIntplPos_TriggerEvents(pPathIntplCommand, pTriggerEvents, numAddlCommands, pPathIntplAddlCommand)",
        "D": "StartPathIntpl3DMov(pPathIntplCommand)",
        "Answer(s)": "C"
    },
    {
        "No": 410,
        "Instruction": "Start a relative position triggered path interpolation motion command with multiple trigger events. This motion combines line interpolation and circular interpolation in one path.",
        "A": "CreatePathIntplWithRotationBuffer(channel, points)",
        "B": "UpdatePathIntplMov_TriggerEvents(pPathIntplCommand, pTriggerEventsList, numAdditionalCommands, pPathIntplAdditionalCommands)",
        "C": "StartPathIntplMov_TriggerEvents(pPathIntplCommand, pTriggerEvents, numAddlCommands, pPathIntplAddlCommand)",
        "D": "StartPathIntplMov_Trigger(pPathIntplCommand, pTrigger, numAddlCommands, pPathIntplAddlCommand)",
        "Answer(s)": "C"
    },
    {
        "No": 411,
        "Instruction": "Start an absolute position 3D path interpolation motion. This motion command combines line interpolation and circular interpolation in one path.",
        "A": "StartPathIntpl3DPosWithAdditionalCommands(pPathIntplCmd, numAddlCmds, pAddlCmd)",
        "B": "StartPathIntpl3DPos(pPathIntplCommand, numAddlCommands, pPathIntplAddlCommand)",
        "C": "StartPathIntplPos_Trigger(pPathIntplCommand, pTrigger, numAddlCommands, pPathIntplAddlCommand)",
        "D": "StartPathIntplWithRotation_Point_Trigger(channel, point, Trigger pTrigger)",
        "Answer(s)": "B"
    },
    {
        "No": 412,
        "Instruction": "Start a relative position 3D path interpolation motion. This motion command combines line interpolation and circular interpolation in one path.",
        "A": "UpdatePathIntpl3DMov(pStartCommand, numAddlCommands, pAdditionalCommands)",
        "B": "StartCoordinatedPos(numCommands, pPosCommand)",
        "C": "StartPathIntplMov_Trigger(pPathIntplCommand, pTrigger, numAddlCommands, pPathIntplAddlCommand)",
        "D": "StartPathIntpl3DMov(pPathIntplCommand, numAddlCommands, pPathIntplAddlCommand)",
        "Answer(s)": "D"
    },
    {
        "No": 413,
        "Instruction": "Start an absolute position triggered 3D path interpolation motion. This motion command combines line interpolation and circular interpolation in one path.",
        "A": "SimulatePosAtTime_3D(self, pPathIntplCommand, timeMilliseconds)",
        "B": "StartPathIntpl3DPos_Trigger(pPathIntplCommand, pTrigger, numAddlCommands, pPathIntplAddlCommand)",
        "C": "Start3DPathIntpl_PosTrigger(pPathIntplCommand, pTrigger, numAddlCommands, pPathIntplAddlCommand)",
        "D": "StartPathIntplPos_Trigger(pPathIntplCommand, pTrigger, numAddlCommands, pPathIntplAddlCommand)",
        "Answer(s)": "B"
    },
    {
        "No": 414,
        "Instruction": "Start a relative position triggered 3D path interpolation motion. This motion command combines line interpolation and circular interpolation in one path.",
        "A": "StartPathIntpl3DPos_TriggerEvents(pPathIntplCommand, pTriggerEvents, numAddlCommands, pPathIntplAddlCommand)",
        "B": "StartPathIntplMov_Trigger(pPathIntplCommand, pTrigger, numAddlCommands, pPathIntplAddlCommand)",
        "C": "StartPathIntpl3DMov_Trigger(pPathIntplCommand, pTrigger, numAddlCommands, pPathIntplAddlCommand)",
        "D": "StartPathIntpl3DMov_Trigger(pPathCommand, pTriggerData, numAdditionalCmds, pAdditionalPathCommand)",
        "Answer(s)": "C"
    },
    {
        "No": 415,
        "Instruction": "Start an absolute position triggered 3D path interpolation motion command with multiple trigger events. This motion combines line interpolation and circular interpolation in one path.",
        "A": "UpdatePathIntpl3DPos_TriggerEvents(pPathIntplCommand, pTriggerEvents, numAdditionalCommands, pPathIntplAdditionalCommand)",
        "B": "StartPathIntpl3DPos_TriggerEvents(pPathIntplCommand, pTriggerEvents, numAddlCommands, pPathIntplAddlCommand)",
        "C": "StartTwoLinkUntetheredLinearMov(pTwoLinkCommand)",
        "D": "StartPathIntplPos_Trigger(pPathIntplCommand, pTrigger, numAddlCommands, pPathIntplAddlCommand)",
        "Answer(s)": "B"
    },
    {
        "No": 416,
        "Instruction": "Start a relative position triggered 3D path interpolation motion command with multiple trigger events. This motion combines line interpolation and circular interpolation in one path.",
        "A": "StartPathIntplPos_Trigger(pPathIntplCommand, pTrigger)",
        "B": "StartPathIntpl3DMov_TriggerEvents(pPathCommand, pEventsToTrigger, numAdditionalCommands, pAdditionalPathCommand)",
        "C": "StartPathIntplPos_TriggerEvents(pPathIntplCommand, pTriggerEvents, numAddlCommands, pPathIntplAddlCommand)",
        "D": "StartPathIntpl3DMov_TriggerEvents(pPathIntplCommand, pTriggerEvents, numAddlCommands, pPathIntplAddlCommand)",
        "Answer(s)": "D"
    },
    {
        "No": 417,
        "Instruction": "Override a 3D path interpolation motion using a velocity multiplier.",
        "A": "GetPathIntplLookaheadStatus(channel)",
        "B": "OverridePathIntpl3DVelocityMultiplier(int axis, double multiplier)",
        "C": "AdjustPathInterpolation3DVelocityMultiplier(int axisToAdjust, double newMultiplier)",
        "D": "StartPathIntpl3DPos_Trigger(pPathIntplCommand, pTrigger)",
        "Answer(s)": "B"
    },
    {
        "No": 418,
        "Instruction": "Allocate buffer memory for a path interpolation with rotation channel.",
        "A": "CreatePathWithRotationBufferAndWaypoints(channel, waypoints)",
        "B": "CreatePathIntplWithRotationBuffer(channel, points)",
        "C": "StartCBSplineMov_Profile (channel, pSplineCommand, numPoints, pPoint)",
        "D": "ClearPathIntplWithRotation(channel)",
        "Answer(s)": "B"
    },
    {
        "No": 419,
        "Instruction": "Free buffer memory for a path interpolation with rotation channel.",
        "A": "StartPathIntplWithRotation(channel)",
        "B": "FreePathIntplWithRotationBuffer(channel)",
        "C": "FreePathIntplWithRotationBuffer(channel, interpolation_type)",
        "D": "StartCSplinePos_VelAccLimited (channel, pSplineCommand, numPoints, pPoint)",
        "Answer(s)": "B"
    },
    {
        "No": 420,
        "Instruction": "Get the number of bytes required per point data in the path interpolation with rotation buffer memory.",
        "A": "GetPathInterpolationWithRotationBytesPerPoint()",
        "B": "FreePathIntplWithRotationBuffer(channel)",
        "C": "GetPathIntplWithRotationBytesPerPoint()",
        "D": "ResolveConstantLinearVel(axis)",
        "Answer(s)": "C"
    },
    {
        "No": 421,
        "Instruction": "Set the configuration data for a path interpolation with rotation channel.",
        "A": "SimulatePosAtTime(self, pPathIntplCommand, timeMilliseconds)",
        "B": "SetPathIntplAndRotateConfiguration(channel, AdvMotion_PathIntplAndRotateConfiguration pConfig)",
        "C": "StartPathIntplWithRotation_Point_Trigger(channel, point, Trigger pTrigger)",
        "D": "SetPathIntplWithRotationConfiguration(channel, AdvMotion_PathIntplWithRotationConfiguration pConfig)",
        "Answer(s)": "D"
    },
    {
        "No": 422,
        "Instruction": "Add interpolation commands to a path interpolation with rotation channel.",
        "A": "StartCSplinePos_VelAccLimited (channel, pSplineCommand, numPoints, pPoint)",
        "B": "AddPathIntplWithRotationCommand(channel, pCommand)",
        "C": "AddPathWithRotationIntplCommand(channel, pCommand)",
        "D": "CreatePathIntplWithRotationBuffer(channel, points)",
        "Answer(s)": "B"
    },
    {
        "No": 423,
        "Instruction": "Execute motion for a path interpolation with rotation channel.",
        "A": "SimulateTimeAtPos_3D(pPathIntplCommand, specificPos1, specificPos2, specificPos3, minimumSearchIndex)",
        "B": "StartPathWithRotation(channel, rotation_angle)",
        "C": "ClearPathIntplWithRotation(channel)",
        "D": "StartPathIntplWithRotation(channel)",
        "Answer(s)": "D"
    },
    {
        "No": 424,
        "Instruction": "Execute triggered motion for a path interpolation with rotation channel. The motion starts when the trigger condition is satisfied.",
        "A": "StartPathIntplWithRotation_Trigger(channel_id, trigger_point)",
        "B": "StartPathIntplWithRotation_Trigger(channel, pTrigger)",
        "C": "StartPathIntplWithRotation_TriggerEvents(channel, TriggerEvents pTriggerEvents)",
        "D": "StartTwoLinkUntetheredRotaryPos(pTwoLinkCommand)",
        "Answer(s)": "B"
    },
    {
        "No": 425,
        "Instruction": "Execute triggered motion for a path interpolation with rotation channel with multiple trigger events. The motion starts when the trigger condition is satisfied.",
        "A": "StartPathIntplWithRotation_TriggerEvents(channel, TriggerEvents triggerEvents)",
        "B": "ApiLogToString(pLogData, logDataSize)",
        "C": "StartPathIntplWithRotation_Point_Trigger(channel, point, Trigger pTrigger)",
        "D": "StartPathIntplWithRotation_TriggerEvents(channel, TriggerEvents pTriggerEvents)",
        "Answer(s)": "D"
    },
    {
        "No": 426,
        "Instruction": "Execute motion to the specified position for a path interpolation with rotation channel.",
        "A": "GetLibVersion()",
        "B": "StartPathIntplWithRotation_Pos(channel, double pos)",
        "C": "InitializePathInterpolationWithRotation_Pos(channel, double initialPos)",
        "D": "StartPathIntplWithRotation_Pos_Trigger(channel, double pos, Trigger pTrigger)",
        "Answer(s)": "B"
    },
    {
        "No": 427,
        "Instruction": "Execute triggered motion to the specified position for a path interpolation with rotation channel. The motion starts when the trigger condition is satisfied.",
        "A": "PathIntplWithRotation_Pos_Trigger(channel, double targetPos, Trigger pTrigger)",
        "B": "StartPathIntplWithRotation_Point_Trigger(channel, point, Trigger pTrigger)",
        "C": "SimulateTimeAtDist(pPathIntplCommand, specificDistance)",
        "D": "StartPathIntplWithRotation_Pos_Trigger(channel, double pos, Trigger pTrigger)",
        "Answer(s)": "D"
    },
    {
        "No": 428,
        "Instruction": "Execute triggered motion to the specified position for a path interpolation with rotation channel with multiple trigger events. The motion starts when the trigger condition is satisfied.",
        "A": "StartPathIntplWithRotation_TriggerEvents(channel, TriggerEvents pTriggerEvents)",
        "B": "ResolveConstantLinearVel(axis)",
        "C": "StartPathIntplWithRotation_Pos_TriggerEvents(channel, double pos, TriggerEvents pTriggerEvents)",
        "D": "UpdatePathIntplWithRotation_Pos_TriggerEvents(channel, double position, TriggerEvents triggerEvents)",
        "Answer(s)": "C"
    },
    {
        "No": 429,
        "Instruction": "Execute motion to the specified point for a path interpolation with rotation channel.",
        "A": "StartPathIntplWithRotation_Trigger(channel, pTrigger)",
        "B": "StartPathIntplWithRotation_Point(channel, point)",
        "C": "EndPathIntplWithRotation_Point(channel, endpoint)",
        "D": "ErrorToString(errCode)",
        "Answer(s)": "B"
    },
    {
        "No": 430,
        "Instruction": "Execute triggered motion to the specified point for a path interpolation with rotation channel. The motion starts when the trigger condition is satisfied.",
        "A": "InitiatePathInterpolationWithRotation_Point_Activate(channel, point, Trigger pTrigger)",
        "B": "ErrorToString(errCode)",
        "C": "StartPathIntplWithRotation_Point_Trigger(channel, point, Trigger pTrigger)",
        "D": "StartPathIntplWithRotation_Pos_TriggerEvents(channel, double pos, TriggerEvents pTriggerEvents)",
        "Answer(s)": "C"
    },
    {
        "No": 431,
        "Instruction": "Execute triggered motion to the specified point for a path interpolation with rotation channel with multiple trigger events. The motion starts when the trigger condition is satisfied.",
        "A": "StartPathIntplWithRotation_Point_TriggerEvents(channel, point, TriggerEvents pTriggerEvents)",
        "B": "StartInterpolatorWithRotation_Point_TriggerEvents(channel, point, TriggerEvents pTriggerEvents)",
        "C": "StartPathIntplWithRotation_Pos_TriggerEvents(channel, double pos, TriggerEvents pTriggerEvents)",
        "D": "CreatePathIntplLookaheadBuffer(channel, points)",
        "Answer(s)": "A"
    },
    {
        "No": 432,
        "Instruction": "Clear all data for a path interpolation with rotation channel.",
        "A": "ClearPathIntplWithRotation(channel, enableRotation)",
        "B": "ClearPathIntplWithRotation(channel)",
        "C": "FreePathIntplWithRotationBuffer(channel)",
        "D": "StartTwoLinkUntetheredRotaryMov(pTwoLinkCommand)",
        "Answer(s)": "B"
    },
    {
        "No": 433,
        "Instruction": "Get the current status for a path inteprolation with rotation channel.",
        "A": "GetPathIntplWithRotationStatusAndTimestamp(channel, timestamp)",
        "B": "GetPathIntplWithRotationStatus(channel)",
        "C": "ClearPathIntplWithRotation(channel)",
        "D": "StartPathIntpl3DPos_Trigger(pPathIntplCommand, pTrigger, numAddlCommands, pPathIntplAddlCommand)",
        "Answer(s)": "B"
    },
    {
        "No": 434,
        "Instruction": "Allocate buffer memory for a path interpolation with look ahead channel.",
        "A": "CreatePathIntplLookaheadBuffer(channel, points)",
        "B": "GetECAM(channel)",
        "C": "CreatePathIntplWithRotationBuffer(channel, points)",
        "D": "UpdatePathInterpolationWithLookaheadBuffer(channel, points)",
        "Answer(s)": "A"
    },
    {
        "No": 435,
        "Instruction": "Free buffer memory for a path interpolation with lookahead channel.",
        "A": "FreePathIntplLookaheadBuffer_V2(channel_id)",
        "B": "ClearPathIntplLookahead(channel)",
        "C": "StartPathIntplLookahead(channel)",
        "D": "FreePathIntplLookaheadBuffer(channel)",
        "Answer(s)": "D"
    },
    {
        "No": 436,
        "Instruction": "Get the number of bytes required per point data in the path interpolation with look ahead buffer memory.",
        "A": "GetPathInterpolatedLookaheadBytesPerPoint()",
        "B": "GetSplineBytesPerPoint()",
        "C": "GetPathIntplLookaheadBytesPerPoint()",
        "D": "StartPathIntpl3DPos_Trigger(pPathIntplCommand, pTrigger)",
        "Answer(s)": "C"
    },
    {
        "No": 437,
        "Instruction": "Set the configuration data for a path interpolation with lookahead channel.",
        "A": "SetPathIntplLookaheadConfigurationV2(channel, pConfig)",
        "B": "SetPathIntplLookaheadConfiguration(channel, pConfig)",
        "C": "CreatePathIntplLookaheadBuffer(channel, points)",
        "D": "StartPathIntpl3DMov(pPathIntplCommand, numAddlCommands, pPathIntplAddlCommand)",
        "Answer(s)": "B"
    },
    {
        "No": 438,
        "Instruction": "Add interpolation commands to a path interpolation with look ahead channel.",
        "A": "AddPathIntplLookaheadCommand(channel, pCommand)",
        "B": "StartPathIntplLookahead(channel)",
        "C": "AddPathIntplLookaheadCommandWithOffset(channel, pCommand, offset)",
        "D": "FreePathIntplWithRotationBuffer(channel)",
        "Answer(s)": "A"
    },
    {
        "No": 439,
        "Instruction": "Start the motion for a path interpolation with look ahead channel.",
        "A": "StartPathIntplWithRotation(channel)",
        "B": "IsDeviceValid()",
        "C": "StartPathIntplLookahead(channel)",
        "D": "InitializePathIntplLookahead(channel, options)",
        "Answer(s)": "C"
    },
    {
        "No": 440,
        "Instruction": "Stop the motion for a path interpolation with look ahead channel.",
        "A": "ClearPathIntplLookahead(channel)",
        "B": "StopPathInterpolationLookAhead(channel)",
        "C": "StopPathIntplLookahead(channel)",
        "D": "StartPathIntplPos(pPathIntplCommand)",
        "Answer(s)": "C"
    },
    {
        "No": 441,
        "Instruction": "Clear all data for a path interpolation with look ahead channel.",
        "A": "GetPathIntplBufferPoints(axis, pPoints)",
        "B": "ClearPathIntplLookahead(channel)",
        "C": "ClearPathIntplLookaheadWithPrediction(channel)",
        "D": "CreatePathIntplLookaheadBuffer(channel, points)",
        "Answer(s)": "B"
    },
    {
        "No": 442,
        "Instruction": "Get the current status for a path interpolation with look ahead channel.",
        "A": "FreePathIntplWithRotationBuffer(channel)",
        "B": "GetPathIntplWithRotationStatus(channel)",
        "C": "GetNextPathPrediction(channel)",
        "D": "GetPathIntplLookaheadStatus(channel)",
        "Answer(s)": "D"
    },
    {
        "No": 443,
        "Instruction": "Start an interpolation between two axes, where one axis executes a normal position command and the second axis travels a specified distance in the same amount of time.",
        "A": "StartCoordinatedPos(pPosCommand)",
        "B": "StartPos(pPosCommand)",
        "C": "StartCoordinatedPosition(pCoordinates)",
        "D": "ApiLogToString(pLogData, logDataSize)",
        "Answer(s)": "A"
    },
    {
        "No": 444,
        "Instruction": "Start multiple interpolations, each between pairs of two axes, where one axis executes a normal position command and the second axis travels a specified distance in the same amount of time.",
        "A": "StartCoordinatedPos(numCommands, pPosCommand)",
        "B": "StartMov_Trigger(numCommands, pPosCommand)",
        "C": "FreePathIntplLookaheadBuffer(channel)",
        "D": "InitializePosition(numCommands, positions)",
        "Answer(s)": "A"
    },
    {
        "No": 445,
        "Instruction": "Start an interpolation between two or more axes, where one axis executes a normal position command and the remaining axes travel the specified distances in the same amount of time.",
        "A": "StartCoordinatedPos_JerkRatio(pPosCommand)",
        "B": "StartCoordinatedPos_JerkRatio(pPosCommand, pVelocityProfile)",
        "C": "IsDeviceValid()",
        "D": "StartCoordinatedPos(numCommands, pPosCommand)",
        "Answer(s)": "A"
    },
    {
        "No": 446,
        "Instruction": "Start a two link motion in which the profile is generated by simulating a rotary axis connected to a linear axis with two links. A motion profile is generated for the rotary axis, and the linear axis follows the simulated motion of the rotary axis. The target position is specified in absolute coordinates.",
        "A": "StartPathIntplWithRotation_Point_TriggerEvents(channel, point, TriggerEvents pTriggerEvents)",
        "B": "StartTwoLinkLinearPos(pTwoLinkCommand)",
        "C": "StartTwoLinkLinearPos(new_pTwoLinkCommand)",
        "D": "StartTwoLinkUntetheredLinearMov(pTwoLinkCommand)",
        "Answer(s)": "B"
    },
    {
        "No": 447,
        "Instruction": "Start a two link motion in which the profile is generated by simulating a rotary axis connected to a linear axis with two links. A motion profile is generated for the rotary axis, and the linear axis follows the simulated motion of the rotary axis. The target position is specified in relative coordinates.",
        "A": "StartTwoLinkLinearPos(pTwoLinkCommand)",
        "B": "StartTwoLinkRotaryMov(pTwoLinkCommand)",
        "C": "StartTwoLinkLinearMovement(pTwoLinkCommand)",
        "D": "StartTwoLinkLinearMov(pTwoLinkCommand)",
        "Answer(s)": "D"
    },
    {
        "No": 448,
        "Instruction": "Start a two link motion in which the profile is generated by simulating a linear axis connected to a rotary axis with two links. A motion profile is generated for the linear axis, and the rotary axis follows the simulated motion of the linear axis. The target position is specified in absolute coordinates.",
        "A": "StartTwoLinkRotaryPos(pTwoLinkCommand)",
        "B": "StartTwoLinkUntetheredRotaryMov(pTwoLinkCommand)",
        "C": "StartPathIntpl3DPos_TriggerEvents(pPathIntplCommand, pTriggerEvents)",
        "D": "UpdateTwoLinkRotaryPos(pUpdatedTwoLinkCommand)",
        "Answer(s)": "A"
    },
    {
        "No": 449,
        "Instruction": "Start a two link motion in which the profile is generated by simulating a linear axis connected to a rotary axis with two links. A motion profile is generated for the linear axis, and the rotary axis follows the simulated motion of the linear axis. The target position is specified in relative coordinates.",
        "A": "SimulatePosAtTime_3D(self, pPathIntplCommand, timeMilliseconds)",
        "B": "StartTwoLinkRotaryMov(pTwoLinkCommand)",
        "C": "StartTwoLinkLinearPos(pTwoLinkCommand)",
        "D": "StopTwoLinkRotaryMov(pTwoLinkCommand)",
        "Answer(s)": "B"
    },
    {
        "No": 450,
        "Instruction": "Start a two link motion in which the profile is generated by simulating a rotary axis connected to a linear axis with two links. A motion profile is generated for the rotary axis, and the linear axis follows the simulated motion of the rotary axis. The target position is specified in absolute coordinates.",
        "A": "StartUntetheredTwoLinkLinearPos(pLinearPosCommand)",
        "B": "StartTwoLinkUntetheredLinearPos(pTwoLinkCommand)",
        "C": "StartTwoLinkLinearMov(pTwoLinkCommand)",
        "D": "StartCBSplineMov_TotalTime (channel, pSplineCommand, numPoints, pPoint)",
        "Answer(s)": "B"
    },
    {
        "No": 451,
        "Instruction": "Start a two link motion in which the profile is generated by simulating a rotary axis connected to a linear axis with two links. A motion profile is generated for the rotary axis, and the linear axis follows the simulated motion of the rotary axis. The target position is specified in relative coordinates.",
        "A": "StartTwoLinkUntetheredLinearMovement(pTwoLinkCmd)",
        "B": "StartTwoLinkUntetheredLinearPos(pTwoLinkCommand)",
        "C": "StartTwoLinkUntetheredLinearMov(pTwoLinkCommand)",
        "D": "ErrorToString(errCode)",
        "Answer(s)": "C"
    },
    {
        "No": 452,
        "Instruction": "Start a two link motion in which the profile is generated by simulating a linear axis connected to a rotary axis with two links. A motion profile is generated for the linear axis, and the rotary axis follows the simulated motion of the linear axis. The target position is specified in absolute coordinates.",
        "A": "StartTwoLinkRotaryPos(pTwoLinkCommand)",
        "B": "StartTwoLinkUntetheredRotaryPos(pTwoLinkCommand)",
        "C": "ClearPathIntplLookahead(channel)",
        "D": "StartTwoLinkUntetheredRotaryPosWithSpeed(pTwoLinkCommand, speed)\nNew function_str: StartTwoLinkUntetheredRotaryPosWithSpeed(pTwoLinkCommand, speed)",
        "Answer(s)": "B"
    },
    {
        "No": 453,
        "Instruction": "Start a two link motion in which the profile is generated by simulating a linear axis connected to a rotary axis with two links. A motion profile is generated for the linear axis, and the rotary axis follows the simulated motion of the linear axis. The target position is specified in relative coordinates.",
        "A": "ClearPathIntplWithRotation(channel)",
        "B": "StartTwoLinkUntetheredRotaryMov(pTwoLinkCommand)",
        "C": "StartTwoLinkUntetheredRotaryMovement(pTwoLinkCommand)",
        "D": "StartTwoLinkLinearMov(pTwoLinkCommand)",
        "Answer(s)": "B"
    },
    {
        "No": 454,
        "Instruction": "Simulate a path interpolation command without moving any axes. The move distance, remain distance, and total distance after the path interpolation runs for a specified amount of time are returned.",
        "A": "SimulateTimeAtDist(pPathIntplCommand, specificDistance)",
        "B": "SimulatePosAtTime(self, pPathIntplCommand, timeMilliseconds)",
        "C": "SimulatePositionAtTime(self, trajectoryInterpolator, timeElapsed)",
        "D": "StartCoordinatedPos(numCommands, pPosCommand)",
        "Answer(s)": "B"
    },
    {
        "No": 455,
        "Instruction": "Simulate a path interpolation command without moving any axes. The elapsed time and remaining time after the axis reaches the specified position are returned.",
        "A": "SimulateTimeAtPos(pSimulatePosCommand, specificPos)",
        "B": "SimulateTimeAtPos(pPathIntplCommand, specificPos1, specificPos2, minimumSearchIndex)",
        "C": "StartCSplineMov_TotalTime (channel, pSplineCommand, numPoints, pPoint)",
        "D": "InterpolateTimeAtPositionPath(pPathIntplCommand, startPos, endPos, minIndex)",
        "Answer(s)": "B"
    },
    {
        "No": 456,
        "Instruction": "Simulate a path interpolation command without moving any axes. The move time, remain time, and total time after the path interpolation runs for the specified distance are returned.",
        "A": "StartPathIntplMov_TriggerEvents(pPathIntplCommand, pTriggerEvents)",
        "B": "SimulatePosAtTime_3D(self, pPathIntplCommand, timeMilliseconds)",
        "C": "SimulateTimeAtDist(pPathIntplCommand, specificDistance)",
        "D": "DisplayTimeAtDistance(pathInterpolator, targetDistance)",
        "Answer(s)": "C"
    },
    {
        "No": 457,
        "Instruction": "Simulate a 3D path interpolation command without moving any axes. The move distance, remain distance, and total distance after the 3D path interpolation runs for a specified amount of time are returned.",
        "A": "SimulatePosAtTime_3D(self, pPathIntplCommand, timeMilliseconds)",
        "B": "StartPathIntplWithRotation_Trigger(channel, pTrigger)",
        "C": "SimulatePositionAtGivenTime_3D(self, positionInterpolationCommand, elapsedTimeMs)",
        "D": "SimulateTimeAtDist_3D(pPathIntplCommand, specificDistance)",
        "Answer(s)": "A"
    },
    {
        "No": 458,
        "Instruction": "Simulate a 3D path interpolation command without moving any axes. The elapsed time and remaining time after the axis reaches the specified position are returned",
        "A": "SimulateTimeAtPos_3D_Extended(pPathCommand, startPos, endPos, referencePos, searchIndexMin)",
        "B": "SimulateTimeAtDist_3D(pPathIntplCommand, specificDistance)",
        "C": "SimulateTimeAtPos_3D(pPathIntplCommand, specificPos1, specificPos2, specificPos3, minimumSearchIndex)",
        "D": "IsDeviceValid()",
        "Answer(s)": "C"
    },
    {
        "No": 459,
        "Instruction": "Simulate a 3D path interpolation command without moving any axes. The move time, remain time, and total time after the 3D path interpolation runs for the specified distance are returned.",
        "A": "SimulateTimeAtDist_LinearIntpl(pSimulateLinearIntplCommand, specificDistance)",
        "B": "EstimateTimeAtDist_3D(pPathInterpolateCmd, targetDistance)",
        "C": "SimulateTimeAtDist_3D(pPathIntplCommand, specificDistance)",
        "D": "CreatePathIntplBuffer(axis, unsigned points)",
        "Answer(s)": "C"
    },
    {
        "No": 460,
        "Instruction": "Return TRUE if this class object has access to a device, and FALSE otherwise. A device is required to execute most functions in this class. If this function returns FALSE, a device can be created by calling the CreateDevice function from the WMX3Api object that was passed to the constructor of this class.",
        "A": "IsDeviceValid()",
        "B": "StartCSplineMov_TotalTime (channel, pSplineCommand, numPoints, pPoint)",
        "C": "GetBacklashCompensation(axis)",
        "D": "IsValidDevice()",
        "Answer(s)": "A"
    },
    {
        "No": 461,
        "Instruction": "Start constant linear velocity control for an axis.",
        "A": "SetConstantLinearVel(masterAxis, slaveAxis, centerPos, minR,positiveMaxR, negativeMaxR, constLinVel, initVelVariance)",
        "B": "SetConstantLinearVelocity(masterAxis, slaveAxis, centerPos, minRadius, posMaxRadius, negMaxRadius, constLinVel, initVelVariance)",
        "C": "StartAxisPP(slaveId, axisIndex, targetPos, profileVel, profileAcc, profileDec)",
        "D": "CreatePathIntplLookaheadBuffer(channel, points)",
        "Answer(s)": "A"
    },
    {
        "No": 462,
        "Instruction": "Resolve constant linear velocity control for an axis.",
        "A": "StartCSplineMov_VelAccLimited (channel, pSplineCommand, numPoints, pPoint)",
        "B": "ResolveSync(slaveAxis)",
        "C": "ResolveConstantLinearVel(axis)",
        "D": "CalculateConstantLinearVelFromAxis(axis)",
        "Answer(s)": "C"
    },
    {
        "No": 463,
        "Instruction": "Return TRUE if this class object has access to a device, and FALSE otherwise. A device is required to execute most functions in this class. If this function returns FALSE, a device can be created by calling the CreateDevice function from the WMX3Api object that was passed to the constructor of this class.",
        "A": "IsDeviceValid(deviceId: str)",
        "B": "SetAbsoluteEncoderHomeOffset(axis, offset)",
        "C": "StopPathIntplLookahead(channel)",
        "D": "IsDeviceValid()",
        "Answer(s)": "D"
    },
    {
        "No": 464,
        "Instruction": "Start E-CAM control.",
        "A": "SetWatch(channel, pWatch)",
        "B": "StartECAM(channel, pECAMData)",
        "C": "GetPathIntplLookaheadBytesPerPoint()",
        "D": "ModifyECAM(channel, pData)",
        "Answer(s)": "B"
    },
    {
        "No": 465,
        "Instruction": "Get E-CAM control parameters.",
        "A": "GetECAM(channel)",
        "B": "GetECAMInfo(channel)",
        "C": "StartCBSplineMov_VelAccLimited(channel, pSplineCommand, numPoints, pPoint)",
        "D": "GetWatch(channel)",
        "Answer(s)": "A"
    },
    {
        "No": 466,
        "Instruction": "Stop E-CAM control.",
        "A": "ResolveConstantLinearVel(axis)",
        "B": "StopLog(channel)",
        "C": "StopECAM(channel)",
        "D": "StopEcamSignal(channel)",
        "Answer(s)": "C"
    },
    {
        "No": 467,
        "Instruction": "Start dancer control.",
        "A": "LetsDance(axis, DancerControlSettings options)",
        "B": "StopDancerControl(axis)",
        "C": "StartDancerControl(axis, AdvSync_DancerControlOptions pDancerControlOptions)",
        "D": "StartCBSplineMov_Profile (channel, pSplineCommand, numPoints, pPoint)",
        "Answer(s)": "C"
    },
    {
        "No": 468,
        "Instruction": "Stop dancer control.",
        "A": "StartPathIntpl3DPos_TriggerEvents(pPathIntplCommand, pTriggerEvents)",
        "B": "endDancerControl(axis):",
        "C": "StopSuperimpose(axis)",
        "D": "StopDancerControl(axis)",
        "Answer(s)": "D"
    },
    {
        "No": 469,
        "Instruction": "Get a string representation of the specified error code.",
        "A": "GetVersion()",
        "B": "ErrorToString(errCode)",
        "C": "ClearPathIntplWithRotation(channel)",
        "D": "ErrorToMessage(errorCode)",
        "Answer(s)": "B"
    },
    {
        "No": 470,
        "Instruction": "Get a string representation of the specified error code.",
        "A": "ApiLogToString(pLogData, logDataSize)",
        "B": "ErrorToString(errCode)",
        "C": "ErrorToString_v2(errorCode)",
        "D": "GetOutAnalogDataUCharEx(addr)",
        "Answer(s)": "B"
    },
    {
        "No": 471,
        "Instruction": "Get a string representation of the raw data of an API log.",
        "A": "OpenCyclicBuffer_AxisSel(pAxisSelection, buffSize)",
        "B": "ApiLogToString(pLogData, logDataSize)",
        "C": "GetSoftwareTouchProbeCounterValue(channel, pLatched, pCounterValue)",
        "D": "ApiLogDataToFormattedString(logData, dataSize)",
        "Answer(s)": "B"
    },
    {
        "No": 472,
        "Instruction": "Get the version of the module library.",
        "A": "Execute_AxisSel(pAxisSelection)",
        "B": "FetchLibraryVersion()",
        "C": "GetLibVersion()",
        "D": "ClearTxPdoWrite(slaveId, index, subindex)",
        "Answer(s)": "C"
    },
    {
        "No": 473,
        "Instruction": "Return TRUE if this class object has access to a device, and FALSE otherwise. A device is required to execute most functions in this class. If this function returns FALSE, a device can be created by calling the CreateDevice function from the WMX3Api object that was passed to the constructor of this class.",
        "A": "SetVelocityFeedforwardGain(axis, gain)",
        "B": "IsDeviceValidForUser(userId: int, deviceId: String)",
        "C": "IsDeviceValid()",
        "D": "AddCommand(axis, pCmd, count)",
        "Answer(s)": "C"
    },
    {
        "No": 474,
        "Instruction": "Get the version of the module rtdll.",
        "A": "ApiLogToString(pLogData, logDataSize)",
        "B": "GetVersion()",
        "C": "GetEmergencyStopParam()",
        "D": "FetchCurrentVersion()",
        "Answer(s)": "B"
    },
    {
        "No": 475,
        "Instruction": "Create a new cyclic buffer memory space for an axis.",
        "A": "IsDeviceValid()",
        "B": "OpenCyclicBuffer(axis, buffSize)",
        "C": "OpenCyclicBuffer_AxisSel(pAxisSelection, buffSize)",
        "D": "OpenCircularBuffer(axis, size)",
        "Answer(s)": "B"
    },
    {
        "No": 476,
        "Instruction": "Create a new cyclic buffer memory space for multiple axes.",
        "A": "OpenCyclicBuffer_AxisSel(pAxisSelection, buffSize, sizeUnit)",
        "B": "OpenCyclicBuffer_SelectAxis(pSelectedAxis, bufferSize)",
        "C": "GetStatus_AxisSel(pAxisSelection)",
        "D": "OpenCyclicBuffer_AxisSel(pAxisSelection, buffSize)",
        "Answer(s)": "D"
    },
    {
        "No": 477,
        "Instruction": "Create a new cyclic buffer memory space for an axis. The size of the memory space can be specified in one of several units.",
        "A": "OpenCyclicBuffer_AxisSel(pAxisSelection, buffSize, sizeUnit)",
        "B": "Abort_AxisSel(pAxisSelection)",
        "C": "OpenCyclicBuffer(axis, buffSize, sizeUnit)",
        "D": "revised_function_str = InitializeCyclicBuffer(axis, maxSize, unitSize)",
        "Answer(s)": "C"
    },
    {
        "No": 478,
        "Instruction": "Create a new cyclic buffer memory space for multiple axes. The size of the memory space can be specified in one of several units.",
        "A": "Execute(axis)",
        "B": "OpenCyclicBuffer_AxisSelection(axis, maxSize, unit)",
        "C": "OpenCyclicBuffer_AxisSel(pAxisSelection, buffSize)",
        "D": "OpenCyclicBuffer_AxisSel(pAxisSelection, buffSize, sizeUnit)",
        "Answer(s)": "D"
    },
    {
        "No": 479,
        "Instruction": "Close the cyclic buffer memory space of an axis.",
        "A": "CloseCyclicBuffer(axis)",
        "B": "UpdateAxisBufferCyclic(axis)",
        "C": "AddCommand(axis, pCmd, count)",
        "D": "CloseCyclicBuffer_AxisSel(pAxisSelection)",
        "Answer(s)": "A"
    },
    {
        "No": 480,
        "Instruction": "Close the cyclic buffer memory space of multiple axes.",
        "A": "CloseCyclicBuffer_AxisSelection(axisSelectionParameter)",
        "B": "IsDeviceValid()",
        "C": "OpenCyclicBuffer_AxisSel(pAxisSelection, buffSize, sizeUnit)",
        "D": "CloseCyclicBuffer_AxisSel(pAxisSelection)",
        "Answer(s)": "D"
    },
    {
        "No": 481,
        "Instruction": "Add one position command data to the cyclic position command buffer of one axis.",
        "A": "OpenCyclicBuffer(axis, buffSize)",
        "B": "AddCommand(axis, pCmd, count)",
        "C": "registerCommand(newAxis, command).",
        "D": "AddCommand(axis, pCmd)",
        "Answer(s)": "D"
    },
    {
        "No": 482,
        "Instruction": "Add any number of position command data to the cyclic position command buffer of one axis.",
        "A": "CreateCommand(axis, command, quantity)",
        "B": "Execute(axis)",
        "C": "AddCommand_AxisSel(pAxisSelection, pCmds)",
        "D": "AddCommand(axis, pCmd, count)",
        "Answer(s)": "D"
    },
    {
        "No": 483,
        "Instruction": "Add one position command data each to the cyclic position command buffer of multiple axes.",
        "A": "GetVersion()",
        "B": "AddCommand_AxisSel(pAxisSelection, pCmds)",
        "C": "UpdateFunction_AxisSelection(pSelection, pCommands)",
        "D": "Continue_AxisSel(pAxisSelection)",
        "Answer(s)": "B"
    },
    {
        "No": 484,
        "Instruction": "Add any number of position command data to the cyclic position command buffer of multiple axes.",
        "A": "UpdateAxisSelection(pAxisSelection, pCommands, count)",
        "B": "AddCommand_AxisSel(pAxisSelection, pCmds, count)",
        "C": "OpenCyclicBuffer(axis, buffSize)",
        "D": "AddCommand_AxisSel(pAxisSelection, pCmds)",
        "Answer(s)": "B"
    },
    {
        "No": 485,
        "Instruction": "Start the execution of the cyclic position command buffer for a single axis.",
        "A": "CloseCyclicBuffer_AxisSel(pAxisSelection)",
        "B": "Pause(axis)",
        "C": "Execute(axis)",
        "D": "ExecuteAxis(axis_command)",
        "Answer(s)": "C"
    },
    {
        "No": 486,
        "Instruction": "Start the execution of the cyclic position command buffer for multiple axes.",
        "A": "Execute_AxisSel(pAxisSelection)",
        "B": "IsDeviceValid()",
        "C": "Resume_AxisSel(pAxisSelection)",
        "D": "Execute_AxisSelection(pSelectedAxis)",
        "Answer(s)": "A"
    },
    {
        "No": 487,
        "Instruction": "Stop execution of the cyclic position command buffer of an axis and clear the buffer.",
        "A": "Wait(axis)",
        "B": "Terminate(axis)",
        "C": "No alternative function available",
        "D": "Abort(axis)",
        "Answer(s)": "D"
    },
    {
        "No": 488,
        "Instruction": "Stop execution of the cyclic position command buffer of multiple axes and clear the buffer.",
        "A": "Abort_AxisSel(pAxisSelection)",
        "B": "Wait_AxisSel(pAxisSelection)",
        "C": "OpenCyclicBuffer(axis, buffSize)",
        "D": "Terminate_AxisSelection(pSelectedAxis)",
        "Answer(s)": "A"
    },
    {
        "No": 489,
        "Instruction": "Get the cyclic position command buffer status of the specified axis.",
        "A": "get_axis_status(axis):",
        "B": "GetStatus(axis)",
        "C": "GetStatus()",
        "D": "CloseCyclicBuffer_AxisSel(pAxisSelection)",
        "Answer(s)": "B"
    },
    {
        "No": 490,
        "Instruction": "Get the cyclic position command buffer status of the specified axes.",
        "A": "GetAxisSelectionStatus(pSelectedAxis)",
        "B": "Execute_AxisSel(pAxisSelection)",
        "C": "GetStatus_AxisSel(pAxisSelection)",
        "D": "Stop_AxisSel(pAxisSelection)",
        "Answer(s)": "C"
    },
    {
        "No": 491,
        "Instruction": "Get a string representation of the specified error code.",
        "A": "ErrorCodeToString(err)",
        "B": "GetOutputData(buff, buffSize, dataSize)",
        "C": "ErrorToString(errCode)",
        "D": "StartPathIntplMov_TriggerEvents(pPathIntplCommand, pTriggerEvents)",
        "Answer(s)": "C"
    },
    {
        "No": 492,
        "Instruction": "Get a string representation of the raw data of an API log.",
        "A": "ApiLogToString(pLogData, logDataSize)",
        "B": "ApiLogToString(logData, dataSize)",
        "C": "SetEvent(pEventData)",
        "D": "SetOptions(channel, pOptions)",
        "Answer(s)": "A"
    },
    {
        "No": 493,
        "Instruction": "Get the version of the module library.",
        "A": "SetEvent(pEventData)",
        "B": "GetLibraryVersion()",
        "C": "GetLibVersion()",
        "D": "StartCSplinePos_VelAccLimited (channel, pSplineCommand, numPoints, pPoint)",
        "Answer(s)": "C"
    },
    {
        "No": 494,
        "Instruction": "Return TRUE if this class object has access to a device, and FALSE otherwise. A device is required to execute most functions in this class. If this function returns FALSE, a device can be created by calling the CreateDevice function from the WMX3Api object that was passed to the constructor of this class.",
        "A": "GetOutputModuleId()",
        "B": "StartMemoryLog(channel)",
        "C": "IsDeviceValid()",
        "D": "IsDeviceDataValid()",
        "Answer(s)": "C"
    },
    {
        "No": 495,
        "Instruction": "Get the version of the module rtdll.",
        "A": "RetrieveVersion()",
        "B": "SetSoftwareTouchProbe(channel, enable, axis, byteAddrs, bitOffset, logic, mode)",
        "C": "GetVersion()",
        "D": "StartPathIntplWithRotation_Pos_TriggerEvents(channel, double pos, TriggerEvents pTriggerEvents)",
        "Answer(s)": "C"
    },
    {
        "No": 496,
        "Instruction": "Set an event.",
        "A": "RemoveEvent(id)",
        "B": "SetEvent_Option(pEventInput, pEventOutput, pOption)",
        "C": "SetEventDetails(eventInputData, eventOutputData)",
        "D": "SetEvent(pEventInput, pEventOutput)",
        "Answer(s)": "D"
    },
    {
        "No": 497,
        "Instruction": "Set an event.",
        "A": "SetEvent_Option(pEventInput, pEventOutput, pOption)",
        "B": "SetEventOutput(id, pEventOutput)",
        "C": "StopPSO(channel)",
        "D": "SetEventOption(pInputEvent, pOutputEvent, option)",
        "Answer(s)": "A"
    },
    {
        "No": 498,
        "Instruction": "Set an event.",
        "A": "ModifyEventID(pInputEvent, pOutputEvent, newID)",
        "B": "SetEventOutput(id, pEventOutput)",
        "C": "SetEvent_ID(pEventInput, pEventOutput, id)",
        "D": "GetSoftwareTouchProbeCounterValue(channel, pLatched, pCounterValue)",
        "Answer(s)": "C"
    },
    {
        "No": 499,
        "Instruction": "Set an event.",
        "A": "SetEvent_ID_Option(pEventInput, pEventOutput, id, pOption)",
        "B": "SetEvent_Option_ID(pEventInput, pEventOutput, id, pOption)",
        "C": "GetSoftwareTouchProbe(channel)",
        "D": "SetEventInput(id, pEventInput)",
        "Answer(s)": "A"
    },
    {
        "No": 500,
        "Instruction": "Get the input function module ID and output function module ID of an existing event.",
        "A": "GetInputModuleId()",
        "B": "SetPlannedVelOverrideSingleData(channel, sData)",
        "C": "GetEventModuleId(id)",
        "D": "GetModuleEventId(moduleId)",
        "Answer(s)": "C"
    },
    {
        "No": 501,
        "Instruction": "Get an event.",
        "A": "RetrieveEventDetailsInOut(eventId)",
        "B": "GetPSOConfig(channel)",
        "C": "GetEvent_InOut(id)",
        "D": "GetEventOption(id)",
        "Answer(s)": "C"
    },
    {
        "No": 502,
        "Instruction": "Get the option settings of an existing event.",
        "A": "GetEventInput(id)",
        "B": "GetEvent(id)",
        "C": "GetEventDetails(event_id)",
        "D": "GetEventOption(id)",
        "Answer(s)": "D"
    },
    {
        "No": 503,
        "Instruction": "This function sets the input function of an event.",
        "A": "SetEvent(id, eventDetails)",
        "B": "EnableEvent(id, enable)",
        "C": "SetEvent(pEventInput, pEventOutput)",
        "D": "SetEventInput(id, pEventInput)",
        "Answer(s)": "D"
    },
    {
        "No": 504,
        "Instruction": "This function sets the output function of an event.",
        "A": "ClearAllEvent()",
        "B": "SetEvent_ID(pEventInput, pEventOutput, id)",
        "C": "SetEventOutputByEventId(eventId, eventOutput)",
        "D": "SetEventOutput(id, pEventOutput)",
        "Answer(s)": "D"
    },
    {
        "No": 505,
        "Instruction": "This function gets the input function of an event.",
        "A": "GetEventOutput(id)",
        "B": "GetEventData(id)",
        "C": "GetEventInput(id)",
        "D": "SetEvent(pEventData)",
        "Answer(s)": "C"
    },
    {
        "No": 506,
        "Instruction": "This function gets the output function of an event.",
        "A": "GetEvent_InOut(id)",
        "B": "GetEventInfo(event_id)",
        "C": "SetPlannedVelOverrideMultipleData(channel, count, pMData)",
        "D": "GetEventOutput(id)",
        "Answer(s)": "D"
    },
    {
        "No": 507,
        "Instruction": "Get the IDs of all existing events.",
        "A": "GetAllDevices()",
        "B": "GetAllEventIDsByCategory(category: str)",
        "C": "GetSoftwareTouchProbeCounterValue(channel, pLatched, pCounterValue)",
        "D": "GetAllEventID()",
        "Answer(s)": "D"
    },
    {
        "No": 508,
        "Instruction": "Get the IDs of all existing events.",
        "A": "GetInputModuleId()",
        "B": "GetAllEventID_In(filterInputModuleId)",
        "C": "GetAllEventIDByInputModuleId(filterInputModuleId)",
        "D": "GetOutputModuleId()",
        "Answer(s)": "B"
    },
    {
        "No": 509,
        "Instruction": "Get the IDs of all existing events.",
        "A": "GetAllEventID_In(filterInputModuleId)",
        "B": "GetAllEventID_InOut(filterInputModuleId, filterOutputModuleId)",
        "C": "StartPSO(channel)",
        "D": "GetAllEventIDs(filterInputModuleID, filterOutputModuleID)",
        "Answer(s)": "B"
    },
    {
        "No": 510,
        "Instruction": "Enable or disable an existing event.",
        "A": "SetOutputData(moduleId, data, dataSize)",
        "B": "EnableNotification(id, enabled)",
        "C": "EnableSyncGroup(groupId, enable)",
        "D": "EnableEvent(id, enable)",
        "Answer(s)": "D"
    },
    {
        "No": 511,
        "Instruction": "Remove an existing event.",
        "A": "GetEventInput(id)",
        "B": "GetPlannedVelOverrideConfig(channel)",
        "C": "UpdateEvent(id)",
        "D": "RemoveEvent(id)",
        "Answer(s)": "D"
    },
    {
        "No": 512,
        "Instruction": "Clear all existing events.",
        "A": "ClearAllEvent()",
        "B": "GetAllEventID()",
        "C": "ClearAllEvents()",
        "D": "GetPlannedVelOverrideDataCount(channel)",
        "Answer(s)": "A"
    },
    {
        "No": 513,
        "Instruction": "Set an event.",
        "A": "ModifyEvent(pEventData)",
        "B": "SetEventInput(id, pEventInput)",
        "C": "SetEvent(pEventData)",
        "D": "GetPSOConfig(channel)",
        "Answer(s)": "C"
    },
    {
        "No": 514,
        "Instruction": "Get the parameters of an event.",
        "A": "GetEvent(id)",
        "B": "GetAllEventID()",
        "C": "RetrieveEventByID(eventID)",
        "D": "GetEventModuleId(id)",
        "Answer(s)": "A"
    },
    {
        "No": 515,
        "Instruction": "Set parameters for a software touch probe channel. A software touch probe channel is able to latch onto the encoder data of an axis when a particular input signal is detected.",
        "A": "IsSoftwareTouchProbeLatched(channel)",
        "B": "SetPSOSingleData(channel, sData)",
        "C": "SetSoftwareTouchProbe(channel, enable, axis, byteAddrs, bitOffset, logic, mode)",
        "D": "SetSoftwareTouchProbeConfiguration(channel, enable, axis, byteAddrs, bitOffset, logic, mode)",
        "Answer(s)": "C"
    },
    {
        "No": 516,
        "Instruction": "Enable a software touch probe channel. A software touch probe channel will only latch encoder data when enabled.",
        "A": "SetPlannedVelOverrideMultipleData(channel, count, pMData)",
        "B": "EnableHardwareTouchProbe(axis, enable)",
        "C": "EnableSoftwareTouchProbe(channel, enable)",
        "D": "python\nEnableTouchProbeSoftware(channel, enable)\n",
        "Answer(s)": "C"
    },
    {
        "No": 517,
        "Instruction": "Get parameters of a software touch probe channel.",
        "A": "GetSoftwareTouchProbe(channel)",
        "B": "GetHardwareTouchProbe(channel)",
        "C": "SetEvent(pEventInput, pEventOutput)",
        "D": "GetStatus(channel)",
        "Answer(s)": "A"
    },
    {
        "No": 518,
        "Instruction": "Check whether a software touch probe channel has latched data.",
        "A": "IsTouchProbeLatched(channelNumber)",
        "B": "IsSoftwareTouchProbeLatched(channel)",
        "C": "StartPlannedVelOverride(channel)",
        "D": "GetSoftwareTouchProbeCounterValue(channel, pLatched, pCounterValue)",
        "Answer(s)": "B"
    },
    {
        "No": 519,
        "Instruction": "Get latched data of software touch probe.",
        "A": "EnableSoftwareTouchProbe(channel, enable)",
        "B": "CaptureTouchProbeCounterValue(channel, latched, counterValue)",
        "C": "GetSoftwareTouchProbeCounterValue(channel, pLatched, pCounterValue)",
        "D": "ErrorToString(errCode)",
        "Answer(s)": "C"
    },
    {
        "No": 520,
        "Instruction": "Set parameters for the hardware touch probe of an axis. A hardware touch probe latches the encoder data of the axis when the touch probe input signal is detected.",
        "A": "EnableHardwareTouchProbe(axis, enable)",
        "B": "SetHardwareTouchProbe(axis, enable, mode, triggerSource, channel)",
        "C": "GetEvent_InOut(id)",
        "D": "SetHardwareTouchProbeConfig(axis, enabled, operationMode, triggerInput, channelNumber)",
        "Answer(s)": "B"
    },
    {
        "No": 521,
        "Instruction": "Get parameters and current state of the hardware touch probe of an axis.",
        "A": "GetHardwareTouchProbeStatus(axis)",
        "B": "CheckHardwareTouchProbeStatus(input_axis)",
        "C": "SetEvent(pEventData)",
        "D": "EnableHardwareTouchProbe(axis, enable)",
        "Answer(s)": "A"
    },
    {
        "No": 522,
        "Instruction": "Enable or disable the hardware touch probe of an axis.",
        "A": "SetHardwareTouchProbe(axis, enable, mode, triggerSource, channel)",
        "B": "StartPSO(channel)",
        "C": "ToggleHardwareTouchProbe(axis, enabled)",
        "D": "EnableHardwareTouchProbe(axis, enable)",
        "Answer(s)": "D"
    },
    {
        "No": 523,
        "Instruction": "Set parameters for a position synchronous output channel. A position synchronous output channel is able to output an output signal when certain conditions, such as an axis reaching a certain position, are met.",
        "A": "SetOptions(channel, pOptions)",
        "B": "SetPSOConfig(channel, pType, pMinDurationMilliseconds)",
        "C": "GetEventOutput(id)",
        "D": "SetPSOConfiguration(channelName, parameterType, minDurationMilliseconds)",
        "Answer(s)": "B"
    },
    {
        "No": 524,
        "Instruction": "Set parameters for a position synchronous output channel. A position synchronous output channel is able to output an output signal when certain conditions, such as an axis reaching a certain position, are met.",
        "A": "SetOptions(channel, pOptions)",
        "B": "GetPSOIntervalData(channel)",
        "C": "SetPSOConfig_Option(channel, pType, pMinDurationMilliseconds, pOption)",
        "D": "SetPSOConfigOption(channelId, optionType, minDurationMs, specificOption)",
        "Answer(s)": "C"
    },
    {
        "No": 525,
        "Instruction": "Get parameters for a position synchronous output channel.",
        "A": "GetPSOConfigDetails(clientId, channelType)",
        "B": "StopPSO(channel)",
        "C": "GetLogOption(channel)",
        "D": "GetPSOConfig(channel)",
        "Answer(s)": "D"
    },
    {
        "No": 526,
        "Instruction": "Get parameters for a position synchronous output channel.",
        "A": "GetPSOConfig(channel)",
        "B": "SetHardwareTouchProbe(axis, enable, mode, triggerSource, channel)",
        "C": "GetPSOConfig_Option(channel)",
        "D": "GetPSOConfig_Options(channel_id)",
        "Answer(s)": "C"
    },
    {
        "No": 527,
        "Instruction": "Set a single data point for a position synchronous output channel.",
        "A": "SetLogFilePath(channel, pPath)",
        "B": "SetPSOSingleData(channel, sData)",
        "C": "GetHardwareTouchProbeStatus(axis)",
        "D": "SetSinglePSOData(sData, channel)",
        "Answer(s)": "B"
    },
    {
        "No": 528,
        "Instruction": "Set multiple data points for a position synchronous output channel.",
        "A": "GetEventOption(id)",
        "B": "SetPSOMultipleData(channel_id, num_readings, data_array)",
        "C": "SetPSOMultipleData(channel, count, pMData)",
        "D": "SetPlannedVelOverrideSingleData(channel, sData)",
        "Answer(s)": "C"
    },
    {
        "No": 529,
        "Instruction": "Set data points over a range for a position synchronous output channel.",
        "A": "SetPSODataInterval(channelId, startTimestamp, endTimestamp, samplingInterval)",
        "B": "GetSoftwareTouchProbeCounterValue(channel, pLatched, pCounterValue)",
        "C": "SetPSOIntervalData(channel, rangeStart, rangeEnd, interval)",
        "D": "GetAllEventID_InOut(filterInputModuleId, filterOutputModuleId)",
        "Answer(s)": "C"
    },
    {
        "No": 530,
        "Instruction": "Get all data points that are currently set for a position synchronous output channel.",
        "A": "SetHardwareTouchProbe(axis, enable, mode, triggerSource, channel)",
        "B": "GetPSOData(channel, maxCount)",
        "C": "RetrievePSOData(channelName, numberOfRecords)",
        "D": "SetPSOSingleData(channel, sData)",
        "Answer(s)": "B"
    },
    {
        "No": 531,
        "Instruction": "Get the number of data points that are currently set for a position synchronous output channel.",
        "A": "FetchPSODataCount(channel)",
        "B": "GetEventModuleId(id)",
        "C": "GetPSOIntervalData(channel)",
        "D": "GetPSODataCount(channel)",
        "Answer(s)": "D"
    },
    {
        "No": 532,
        "Instruction": "Get the range and interval of a position synchronous output channel.",
        "A": "GetPSOChannelData(channel_id)",
        "B": "GetPlannedVelOverrideStatus(channel)",
        "C": "GetPSODataCount(channel)",
        "D": "GetPSOIntervalData(channel)",
        "Answer(s)": "D"
    },
    {
        "No": 533,
        "Instruction": "Start a position synchronous output channel. A position synchronous output channel must be started before it controls the output.",
        "A": "StartPSO(channel)",
        "B": "GetPSOConfig(channel)",
        "C": "StartLog(channel)",
        "D": "InitiatePSO(channel)",
        "Answer(s)": "A"
    },
    {
        "No": 534,
        "Instruction": "Stop a position synchronous output channel. A stopped position synchronous output channel will stop controlling any outputs.",
        "A": "SetEventInput(id, pEventInput)",
        "B": "StopPSO(channel)",
        "C": "GetOptions(channel)",
        "D": "StopProcessing(channel)",
        "Answer(s)": "B"
    },
    {
        "No": 535,
        "Instruction": "Get the state of a position synchronous output channel.",
        "A": "GetPSOStatus(channel)",
        "B": "GetPowerStatus(channel_id)",
        "C": "GetPSODataCount(channel)",
        "D": "StartPSO(channel)",
        "Answer(s)": "A"
    },
    {
        "No": 536,
        "Instruction": "Set parameters for a planned velocity override channel. A planned velocity override channel is able to override the velocity of an axis when certain conditions, such as an axis reaching a certain position, are met.",
        "A": "SetPlannedVelOverrideMultipleData(channel, count, pMData)",
        "B": "SetPlannedVelOverrideConfigWithAxis(channel, type, source, axisNumber)",
        "C": "StartPlannedVelOverride(channel)",
        "D": "SetPlannedVelOverrideConfig(channel, type, pSource, axis)",
        "Answer(s)": "D"
    },
    {
        "No": 537,
        "Instruction": "Get parameters for a planned velocity override channel.",
        "A": "GetPlannedVelOverrideConfig(channel)",
        "B": "GetPlannedVelOverrideConfigData(channel_id)",
        "C": "GetPlannedVelOverrideDataCount(channel)",
        "D": "GetPSODataCount(channel)",
        "Answer(s)": "A"
    },
    {
        "No": 538,
        "Instruction": "Set a single data point for a planned velocity override channel.",
        "A": "GetPlannedVelOverrideData(channel, maxCount)",
        "B": "GetEvent(id)",
        "C": "SetPlannedVelocityOverrideData(channel, data)",
        "D": "SetPlannedVelOverrideSingleData(channel, sData)",
        "Answer(s)": "D"
    },
    {
        "No": 539,
        "Instruction": "Set multiple data points for a planned velocity override channel.",
        "A": "SetPlannedVelOverrideSingleData(channel, sData)",
        "B": "SetPlannedVelOverrideMultipleData(channel, count, pMData)",
        "C": "SetEvent(pEventInput, pEventOutput)",
        "D": "SetPlannedVelOverridesBulkData(channel, num_overrides, overrides_data)",
        "Answer(s)": "B"
    },
    {
        "No": 540,
        "Instruction": "Get all data points that are currently set for a planned velocity override channel.",
        "A": "GetPlannedVelOverrideData(channel, maxCount)",
        "B": "SetPlannedVelOverrideMultipleData(channel, count, pMData)",
        "C": "GetPlannedVelOverrideDataCount(channel)",
        "D": "GetPlannedVelOverrideDataWithLimit(channelName, maxItems)",
        "Answer(s)": "A"
    },
    {
        "No": 541,
        "Instruction": "Get the number of data points that are currently set for a planned velocity override channel.",
        "A": "RemoveEvent(id)",
        "B": "GetPlannedVelocityOverrideDataCount(channel_id)",
        "C": "StopPlannedVelOverride(channel)",
        "D": "GetPlannedVelOverrideDataCount(channel)",
        "Answer(s)": "D"
    },
    {
        "No": 542,
        "Instruction": "Start a planned velocity override channel. A planned velocity override channel must be started before it controls the output.",
        "A": "GetPSOIntervalData(channel)",
        "B": "StartPlannedVelOverride(channel)",
        "C": "GetPlannedVelOverrideConfig(channel)",
        "D": "BeginPlannedVelocityOverride(channel)",
        "Answer(s)": "B"
    },
    {
        "No": 543,
        "Instruction": "Stop a planned velocity override channel. A stopped planned velocity override channel will stop controlling any outputs.",
        "A": "SetPSOConfig(channel, pType, pMinDurationMilliseconds)",
        "B": "StopPlannedVelOverride(channel)",
        "C": "GetPlannedVelOverrideConfig(channel)",
        "D": "StopPlannedVelocityOverride(channel)",
        "Answer(s)": "B"
    },
    {
        "No": 544,
        "Instruction": "Get the state of a planned velocity override channel.",
        "A": "GetPlannedVelOverrideStatus(channel)",
        "B": "GetPlannedVelOverrideStatusUpdated(vehicleChannel)",
        "C": "GetEventOption(id)",
        "D": "StartPlannedVelOverride(channel)",
        "Answer(s)": "A"
    },
    {
        "No": 545,
        "Instruction": "Get a string representation of the specified error code.",
        "A": "ErrorToString(errCode)",
        "B": "SetOutAnalogDataUInt(addr, analogData)",
        "C": "GetInitialOutBytesInterruptId(addr, size)",
        "D": "ErrorToString(code)",
        "Answer(s)": "A"
    },
    {
        "No": 546,
        "Instruction": "Get a string representation of the raw data of an API log.",
        "A": "ApiLogToString(pLogData, logDataSize)",
        "B": "GetPSOConfig_Option(channel)",
        "C": "ApiLogDataToString(logData, dataSize)",
        "D": "GetOutByteEx(addr)",
        "Answer(s)": "A"
    },
    {
        "No": 547,
        "Instruction": "Get the version of the module library.",
        "A": "Export_SysPrm_AxisPrm_Axis(pPath, pParam, pAxisParam, axis)",
        "B": "GetLibVersion()",
        "C": "GetLibraryVersion()",
        "D": "SetOutAnalogDataUShort(addr, analogData)",
        "Answer(s)": "B"
    },
    {
        "No": 548,
        "Instruction": "Return TRUE if this class object has access to a device, and FALSE otherwise. A device is required to execute most functions in this class. If this function returns FALSE, a device can be created by calling the CreateDevice function from the WMX3Api object that was passed to the constructor of this class.",
        "A": "GetOutBitEx(addr, bit)",
        "B": "IsDeviceAuthenticationValid()",
        "C": "IsDeviceValid()",
        "D": "GetVersion()",
        "Answer(s)": "C"
    },
    {
        "No": 549,
        "Instruction": "Get the version of the module rtdll.",
        "A": "GetBacklashCompensation(axis)",
        "B": "GetInAnalogDataUInt(addr)",
        "C": "GetSoftwareVersion()",
        "D": "GetVersion()",
        "Answer(s)": "D"
    },
    {
        "No": 550,
        "Instruction": "Set the value of an output bit.",
        "A": "SetOutputBit(address, bitPosition, value)",
        "B": "SetMBit(addr, bit, data)",
        "C": "GetOutAnalogDataInt(addr)",
        "D": "SetOutBit(addr, bit, data)",
        "Answer(s)": "D"
    },
    {
        "No": 551,
        "Instruction": "Set the value of an output byte.",
        "A": "SetOutBytesEx(addr, size, pData)",
        "B": "SetOutByte(addr, data)",
        "C": "SetOutputByte(address, value)",
        "D": "SetMByte(addr, data)",
        "Answer(s)": "B"
    },
    {
        "No": 552,
        "Instruction": "Set the value of multiple output bytes.",
        "A": "SetOutBytesEx(addr, size, pData)",
        "B": "SetInputData(moduleId, data, dataSize)",
        "C": "SetOutBytes(addr, size, pData)",
        "D": "SetOutputBytes(address, length, data)",
        "Answer(s)": "C"
    },
    {
        "No": 553,
        "Instruction": "Set the value of multiple output bits.",
        "A": "SetOutBits(pByte, pBit, pData, count)",
        "B": "SetOutAnalogDataUIntEx(addr, analogData)",
        "C": "SetOutputBits(bytePointer, bitIndex, dataValue, count)",
        "D": "SetOutBit(addr, bit, data)",
        "Answer(s)": "A"
    },
    {
        "No": 554,
        "Instruction": "Set the value of output analog data spanning one byte.",
        "A": "GetOutputModuleId()",
        "B": "SetOutAnalogDataChar(addr, analogData)",
        "C": "SetOutAnalogDataCharEx(addr, analogData)",
        "D": "SetOutputVoltage(addr, voltage)",
        "Answer(s)": "B"
    },
    {
        "No": 555,
        "Instruction": "Set the value of output analog data spanning one byte.",
        "A": "SetOutAnalogDataUInt16(addr, analogData)",
        "B": "SetOutAnalogDataUChar(addr, analogData)",
        "C": "GetInBytesEx(addr, size)",
        "D": "SetMAnalogDataUChar(addr, analogData)",
        "Answer(s)": "B"
    },
    {
        "No": 556,
        "Instruction": "Set the value of output analog data spanning two bytes.",
        "A": "SetOutAnalogDataShort(addr, analogData)",
        "B": "GetOutAnalogDataUCharEx(addr)",
        "C": "SetOutAnalogDataChar(addr, analogData)",
        "D": "SetAnalogOutputShort(address, data)",
        "Answer(s)": "A"
    },
    {
        "No": 557,
        "Instruction": "Set the value of output analog data spanning two bytes.",
        "A": "SetOutBit(addr, bit, data)",
        "B": "SetAnalogOutputUShort(addr, data)",
        "C": "SetOutAnalogDataShortEx(addr, analogData)",
        "D": "SetOutAnalogDataUShort(addr, analogData)",
        "Answer(s)": "D"
    },
    {
        "No": 558,
        "Instruction": "Set the value of output analog data spanning four bytes.",
        "A": "SetOutByte(addr, data)",
        "B": "SetOutAnalogDataInt(addr, analogData)",
        "C": "SetOutputAnalogDataInt(addrIndex, analogValue)",
        "D": "SetMAnalogDataUInt(addr, analogData)",
        "Answer(s)": "B"
    },
    {
        "No": 559,
        "Instruction": "Set the value of output analog data spanning four bytes.",
        "A": "SetOutAnalogDataIntEx(addr, analogData)",
        "B": "GetInAnalogDataCharEx(addr)",
        "C": "SetOutAnalogDataUInt(addr, analogData)",
        "D": "SetAnalogOutputDataInt(addr, analogValue)",
        "Answer(s)": "C"
    },
    {
        "No": 560,
        "Instruction": "Get the value of an input bit.",
        "A": "GetMBitEx(addr, bit)",
        "B": "GetInBit(addr, bit)",
        "C": "SetBit(addr, bit_num)",
        "D": "SetOutBytes(addr, size, pData)",
        "Answer(s)": "B"
    },
    {
        "No": 561,
        "Instruction": "Get the value of an input byte.",
        "A": "GetInAnalogDataUIntEx(addr)",
        "B": "GetByteAtAddress(memory_address)",
        "C": "GetOutByte(addr)",
        "D": "GetInByte(addr)",
        "Answer(s)": "D"
    },
    {
        "No": 562,
        "Instruction": "Get the value of multiple input bytes.",
        "A": "GetMBytesEx(addr, size)",
        "B": "GetInitialOutByteInterruptId(addr)",
        "C": "GetBytes(address, length)",
        "D": "GetInBytes(addr, size)",
        "Answer(s)": "D"
    },
    {
        "No": 563,
        "Instruction": "Get the value of input analog data spanning one byte.",
        "A": "GetInAnalogDataChar(addr)",
        "B": "SetOutBytes(addr, size, pData)",
        "C": "GetAnalogDataChar(addr)",
        "D": "GetInAnalogDataUCharEx(addr)",
        "Answer(s)": "A"
    },
    {
        "No": 564,
        "Instruction": "Get the value of input analog data spanning one byte.",
        "A": "GetInAnalogDataUChar(addr)",
        "B": "GetMAnalogDataUChar(addr)",
        "C": "GetInByte(addr)",
        "D": "GetAnalogDataUChar(addr)",
        "Answer(s)": "A"
    },
    {
        "No": 565,
        "Instruction": "Get the value of input analog data spanning two bytes.",
        "A": "GetInputData(buff, buffSize, dataSize, initialState)",
        "B": "FetchAnalogShortData(addr)",
        "C": "GetMAnalogDataShort(addr)",
        "D": "GetInAnalogDataShort(addr)",
        "Answer(s)": "D"
    },
    {
        "No": 566,
        "Instruction": "Get the value of input analog data spanning two bytes.",
        "A": "SetOutBytesEx(addr, size, pData)",
        "B": "GetInAnalogDataUShort(addr)",
        "C": "GetInAnalogDataShortEx(addr)",
        "D": "GetAnalogDataUShort(addr)",
        "Answer(s)": "B"
    },
    {
        "No": 567,
        "Instruction": "Get the value of input analog data spanning four bytes.",
        "A": "GetInAnalogDataIntEx(addr)",
        "B": "GetAnalogDataIntFromAddress(addr)",
        "C": "GetInAnalogDataInt(addr)",
        "D": "GetInAnalogDataIntEx(addr)",
        "Answer(s)": "C"
    },
    {
        "No": 568,
        "Instruction": "Get the value of input analog data spanning four bytes.",
        "A": "GetAnalogDataUInt(addr, channel)",
        "B": "GetInAnalogDataUInt(addr)",
        "C": "GetOutAnalogDataShort(addr)",
        "D": "GetInAnalogDataUIntEx(addr)",
        "Answer(s)": "B"
    },
    {
        "No": 569,
        "Instruction": "Get the value of an output bit.",
        "A": "GetVersion()",
        "B": "ExtractBit(addr, bit)",
        "C": "GetOutBit(addr, bit)",
        "D": "GetInBit(addr, bit)",
        "Answer(s)": "C"
    },
    {
        "No": 570,
        "Instruction": "Get the value of an output byte.",
        "A": "RetrieveByteFromAddress(address)",
        "B": "GetInitialOutByteInterruptId(addr)",
        "C": "GetOutBytes(addr, size)",
        "D": "GetOutByte(addr)",
        "Answer(s)": "D"
    },
    {
        "No": 571,
        "Instruction": "Get the value of multiple output bytes.",
        "A": "GetOutBytesEx(addr, size)",
        "B": "GetOutAnalogDataUCharEx(addr)",
        "C": "GetOutBytes(addr, size)",
        "D": "GetOutputData(destination_addr, data_size)",
        "Answer(s)": "C"
    },
    {
        "No": 572,
        "Instruction": "Get the value of output analog data spanning one byte.",
        "A": "GetAnalogDataCharOut(address)",
        "B": "GetOutAnalogDataChar(addr)",
        "C": "GetInAnalogDataChar(addr)",
        "D": "GetInAnalogDataChar(addr)",
        "Answer(s)": "B"
    },
    {
        "No": 573,
        "Instruction": "Get the value of output analog data spanning one byte.",
        "A": "GetOutAnalogDataUChar(addr)",
        "B": "SetOutAnalogDataUCharEx(addr, analogData)",
        "C": "GetMAnalogDataUChar(addr)",
        "D": "GetAnalogDataUChar(addr)",
        "Answer(s)": "A"
    },
    {
        "No": 574,
        "Instruction": "Get the value of output analog data spanning two bytes.",
        "A": "GetInAnalogDataUShort(addr)",
        "B": "GetAnalogDataOutShort(addr)",
        "C": "GetOutAnalogDataShort(addr)",
        "D": "GetOutAnalogDataShortEx(addr)",
        "Answer(s)": "C"
    },
    {
        "No": 575,
        "Instruction": "Get the value of output analog data spanning two bytes.",
        "A": "GetOutByte(addr)",
        "B": "GetAnalogDataUShort(addr)",
        "C": "GetOutAnalogDataShortEx(addr)",
        "D": "GetOutAnalogDataUShort(addr)",
        "Answer(s)": "D"
    },
    {
        "No": 576,
        "Instruction": "Get the value of output analog data spanning four bytes.",
        "A": "GetOutAnalogDataIntEx(addr)",
        "B": "GetAnalogDataInt(addr)",
        "C": "SetOutputData(moduleId, data, dataSize)",
        "D": "GetOutAnalogDataInt(addr)",
        "Answer(s)": "D"
    },
    {
        "No": 577,
        "Instruction": "Get the value of output analog data spanning four bytes.",
        "A": "GetAnalogDataUInt(addr, channelId)",
        "B": "GetMAnalogDataUInt(addr)",
        "C": "GetInAnalogDataUShortEx(addr)",
        "D": "GetOutAnalogDataUInt(addr)",
        "Answer(s)": "D"
    },
    {
        "No": 578,
        "Instruction": "Set the value of an output bit.",
        "A": "SetOutBit(addr: int, bit_pos: int, value: bool)",
        "B": "SetOutBitEx(addr, bit, data)",
        "C": "GetInAnalogDataUIntEx(addr)",
        "D": "SetOutBit(addr, bit, data)",
        "Answer(s)": "B"
    },
    {
        "No": 579,
        "Instruction": "Set the value of an output byte.",
        "A": "SetOutputData(address, value)",
        "B": "GetInputData(buff, buffSize, dataSize)",
        "C": "SetOutBitEx(addr, bit, data)",
        "D": "SetOutByteEx(addr, data)",
        "Answer(s)": "D"
    },
    {
        "No": 580,
        "Instruction": "Set the value of multiple output bytes.",
        "A": "SetOutBytesEx(addr, size, pData)",
        "B": "GetInitialOutByte(addr)",
        "C": "SetOutputBytesExtended(address, byte_size, data_buffer)",
        "D": "GetOutBytesEx(addr, size)",
        "Answer(s)": "A"
    },
    {
        "No": 581,
        "Instruction": "Set the value of multiple output bits.",
        "A": "SetOutBits(pByteData, startingBitIndex, newData, numberOfBits)",
        "B": "SetMBitsEx(pByte, pBit, pData, count)",
        "C": "SetOutByte(addr, data)",
        "D": "SetOutBitsEx(pByte, pBit, pData, count)",
        "Answer(s)": "D"
    },
    {
        "No": 582,
        "Instruction": "Set the value of output analog data spanning one byte.",
        "A": "SetOutAnalogDataCharEx(addr, analogData)",
        "B": "SetOutAnalogDataUChar(addr, analogData)",
        "C": "SetAnalogDataCharEx(addr, newData)",
        "D": "GetInputModuleId()",
        "Answer(s)": "A"
    },
    {
        "No": 583,
        "Instruction": "Set the value of output analog data spanning one byte.",
        "A": "SetOutAnalogDataIntEx(addr, analogData)",
        "B": "SetOutAnalogDataFloatEx(addr, analogData)",
        "C": "SetOutAnalogDataCharEx(addr, analogData)",
        "D": "SetOutAnalogDataUCharEx(addr, analogData)",
        "Answer(s)": "D"
    },
    {
        "No": 584,
        "Instruction": "Set the value of output analog data spanning two bytes.",
        "A": "SetOutAnalogDataShort(addr, analogData)",
        "B": "SetAnalogDataShortEx(addr, newData)",
        "C": "GetOutAnalogDataCharEx(addr)",
        "D": "SetOutAnalogDataShortEx(addr, analogData)",
        "Answer(s)": "D"
    },
    {
        "No": 585,
        "Instruction": "Set the value of output analog data spanning two bytes.",
        "A": "SetOutAnalogDataUShortEx(addr, analogData)",
        "B": "SetOutAnalogDataUShort(addr, analogData)",
        "C": "GetOutAnalogDataUIntEx(addr)",
        "D": "SetOutAnalogDataShort(addr, analogData)",
        "Answer(s)": "A"
    },
    {
        "No": 586,
        "Instruction": "Set the value of output analog data spanning four bytes.",
        "A": "SetOutAnalogDataUChar(addr, analogData)",
        "B": "SetAnalogDataOutput(addr, analogData)",
        "C": "SetOutAnalogDataIntEx(addr, analogData)",
        "D": "SetMAnalogDataUIntEx(addr, analogData)",
        "Answer(s)": "C"
    },
    {
        "No": 587,
        "Instruction": "Set the value of output analog data spanning four bytes.",
        "A": "SetOutputAnalogDataUInt(addr, analogData)",
        "B": "SetOutAnalogDataUIntEx(addr, analogData)",
        "C": "SetOutAnalogDataUInt(addr, analogData)",
        "D": "GetOutAnalogDataChar(addr)",
        "Answer(s)": "B"
    },
    {
        "No": 588,
        "Instruction": "Get the value of an input bit.",
        "A": "GetMBitEx(addr, bit)",
        "B": "GetInAnalogDataShortEx(addr)",
        "C": "GetBitValueAtAddress(address, position)",
        "D": "GetInBitEx(addr, bit)",
        "Answer(s)": "D"
    },
    {
        "No": 589,
        "Instruction": "Get the value of an input byte.",
        "A": "GetMByteEx(addr)",
        "B": "SetOutAnalogDataUShortEx(addr, analogData)",
        "C": "FetchByteAt(addr)",
        "D": "GetInByteEx(addr)",
        "Answer(s)": "D"
    },
    {
        "No": 590,
        "Instruction": "Get the value of multiple input bytes.",
        "A": "GetMemoryChunkEx(addr, length)",
        "B": "GetInBytesEx(addr, size)",
        "C": "GetInBytes(addr, size)",
        "D": "GetInAnalogDataChar(addr)",
        "Answer(s)": "B"
    },
    {
        "No": 591,
        "Instruction": "Get the value of input analog data spanning one byte.",
        "A": "GetMAnalogDataUCharEx(addr)",
        "B": "RetrieveAnalogInputDataExtended(address)",
        "C": "GetInAnalogDataCharEx(addr)",
        "D": "SetOutByte(addr, data)",
        "Answer(s)": "C"
    },
    {
        "No": 592,
        "Instruction": "Get the value of input analog data spanning one byte.",
        "A": "SetInitialOutByte(addr, data, enable)",
        "B": "GetMAnalogDataCharEx(addr)",
        "C": "GetInAnalogDataUCharEx(addr)",
        "D": "GetAnalogDataUChar(addr)",
        "Answer(s)": "C"
    },
    {
        "No": 593,
        "Instruction": "Get the value of input analog data spanning two bytes",
        "A": "GetMAnalogDataUShortEx(addr)",
        "B": "GetShortAnalogDataEx(addr)",
        "C": "GetInAnalogDataShortEx(addr)",
        "D": "SetOutBytesEx(addr, size, pData)",
        "Answer(s)": "C"
    },
    {
        "No": 594,
        "Instruction": "Get the value of input analog data spanning two bytes.",
        "A": "GetInAnalogDataUShortEx(addr)",
        "B": "GetInAnalogDataUShortEx(address)",
        "C": "GetInAnalogDataShortEx(addr)",
        "D": "GetInAnalogDataUIntEx(addr)",
        "Answer(s)": "A"
    },
    {
        "No": 595,
        "Instruction": "Get the value of input analog data spanning four bytes.",
        "A": "GetInAnalogDataIntEx(addr)",
        "B": "GetInAnalogDataUIntEx(addr)",
        "C": "GetAnalogInputDataIntEx(address)",
        "D": "GetOutByte(addr)",
        "Answer(s)": "A"
    },
    {
        "No": 596,
        "Instruction": "Get the value of input analog data spanning four bytes.",
        "A": "GetInAnalogDataUIntEx(addr)",
        "B": "GetMAnalogDataIntEx(addr)",
        "C": "SetOutAnalogDataShort(addr, analogData)",
        "D": "GetPositionAnalogDataInt(addr)",
        "Answer(s)": "A"
    },
    {
        "No": 597,
        "Instruction": "Get the value of an output bit.",
        "A": "SetOutAnalogDataShortEx(addr, analogData)",
        "B": "SetOutBitEx(addr, bit, data)",
        "C": "GetOutBitEx(addr, bit)",
        "D": "GetBitExtraction(addr, bit_position)",
        "Answer(s)": "C"
    },
    {
        "No": 598,
        "Instruction": "Get the value of an output byte.",
        "A": "GetOutByteEx(addr)",
        "B": "SetOutBitEx(addr, bit, data)",
        "C": "GetOutputByte(addr):",
        "D": "GetOutBytesEx(addr, size)",
        "Answer(s)": "A"
    },
    {
        "No": 599,
        "Instruction": "Get the value of multiple output bytes.",
        "A": "GetOutBytesEx(addr, size)",
        "B": "GetOutputData(addr_ptr, num_elements)",
        "C": "GetInAnalogDataUIntEx(addr)",
        "D": "GetMBytes(addr, size)",
        "Answer(s)": "A"
    },
    {
        "No": 600,
        "Instruction": "Get the value of output analog data spanning one byte.",
        "A": "GetAnalogDataCharFromAddressEx(address)",
        "B": "GetOutByte(addr)",
        "C": "GetInAnalogDataCharEx(addr)",
        "D": "GetOutAnalogDataCharEx(addr)",
        "Answer(s)": "D"
    },
    {
        "No": 601,
        "Instruction": "Get the value of output analog data spanning one byte.",
        "A": "GetAnalogDataUChar(address)",
        "B": "SetOutAnalogDataUCharEx(addr, analogData)",
        "C": "GetMAnalogDataUCharEx(addr)",
        "D": "GetOutAnalogDataUCharEx(addr)",
        "Answer(s)": "D"
    },
    {
        "No": 602,
        "Instruction": "Get the value of output analog data spanning two bytes.",
        "A": "GetOutAnalogDataShortEx(addr)",
        "B": "IsDeviceValid()",
        "C": "GetOutAnalogDataUShortEx(addr)",
        "D": "GetAnalogDataShortEx(addr)",
        "Answer(s)": "A"
    },
    {
        "No": 603,
        "Instruction": "Get the value of output analog data spanning two bytes.",
        "A": "GetOutAnalogDataUShortEx(addr)",
        "B": "GetInAnalogDataUShortEx(addr)",
        "C": "GetOutBitEx(addr, bit)",
        "D": "GetOutAnalogDataUShortEx(address)",
        "Answer(s)": "A"
    },
    {
        "No": 604,
        "Instruction": "Get the value of output analog data spanning four bytes.",
        "A": "GetOutAnalogDataInt(addr)",
        "B": "GetAnalogDataIntEx(addr)",
        "C": "GetOutAnalogDataIntEx(addr)",
        "D": "GetOutAnalogDataShortEx(addr)",
        "Answer(s)": "C"
    },
    {
        "No": 605,
        "Instruction": "Get the value of output analog data spanning four bytes.",
        "A": "GetOutAnalogDataUIntEx(addr)",
        "B": "GetOutAnalogDataUInt(addr)",
        "C": "SetOutBitEx(addr, bit, data)",
        "D": "GetOutAnalogDataUInt(addr, options)",
        "Answer(s)": "A"
    },
    {
        "No": 606,
        "Instruction": "Set the initial value of an output byte that is applied when communication is started.",
        "A": "GetInAnalogDataChar(addr)",
        "B": "SetInitialOutByte(addr, data, enable)",
        "C": "GetInitialOutBytes(addr, size)",
        "D": "SetInitialOutputByte(address, value, isEnabled)",
        "Answer(s)": "B"
    },
    {
        "No": 607,
        "Instruction": "Set the initial values of multiple output bytes that are applied when communication is started.",
        "A": "SetInitialOutByte(addr, data, enable)",
        "B": "SetInitialOutboundData(addr, size, dataBuffer, enableFlag)",
        "C": "GetInAnalogDataUCharEx(addr)",
        "D": "SetInitialOutBytes(addr, size, pData, pEnable)",
        "Answer(s)": "D"
    },
    {
        "No": 608,
        "Instruction": "Set the initial values of multiple output bytes that are applied when communication is started.",
        "A": "FetchInitialOutputByte(address)",
        "B": "GetInitialOutBytes(addr, size)",
        "C": "GetInitialOutByte(addr)",
        "D": "GetOutByteEx(addr)",
        "Answer(s)": "C"
    },
    {
        "No": 609,
        "Instruction": "Get the initial values of multiple output bytes that are applied when communication is started.",
        "A": "GetOutBytesEx(addr, size)",
        "B": "GetOutBytesEx(addr, size)",
        "C": "GetInitialOutBytes(addr, size)",
        "D": "FetchInitialOutBytes(address, byte_count)",
        "Answer(s)": "C"
    },
    {
        "No": 610,
        "Instruction": "Get the ID of the interrupt (cyclic handler) that will set the initial value of the specified output byte.",
        "A": "GetOutAnalogDataUShort(addr)",
        "B": "GetInitialOutByte(addr)",
        "C": "GetInitialOutByteInterruptId(addr)",
        "D": "GetInitialOutputByteInterruptId(address)",
        "Answer(s)": "C"
    },
    {
        "No": 611,
        "Instruction": "Get the IDs of the interrupts (cyclic handlers) that will set the initial values of the specified output bytes.",
        "A": "GetInitialOutBytesInterruptId(addr, size)",
        "B": "SetOutBitsEx(pByte, pBit, pData, count)",
        "C": "GetInitialOutputBytesInterruptId(address, length)",
        "D": "GetInitialOutBytes(addr, size)",
        "Answer(s)": "A"
    },
    {
        "No": 612,
        "Instruction": "Get a string representation of the specified error code.",
        "A": "ErrorToString(errCode)",
        "B": "OpenApiLogFile(pPath)",
        "C": "ErrorToMessage(errNumber)",
        "D": "Import_SysPrm_Axis(pPath, axis, copyParamToAxes)",
        "Answer(s)": "A"
    },
    {
        "No": 613,
        "Instruction": "Get a string representation of the raw data of an API log.",
        "A": "SetInputData(moduleId, data, dataSize)",
        "B": "ApiLogDataToString(logDataPtr, dataSize)",
        "C": "SimulateTimeAtPos_3D(pPathIntplCommand, specificPos1, specificPos2, specificPos3, minimumSearchIndex)",
        "D": "ApiLogToString(pLogData, logDataSize)",
        "Answer(s)": "D"
    },
    {
        "No": 614,
        "Instruction": "Get the version of the module library.",
        "A": "ApiLogToString(pLogData, logDataSize)",
        "B": "GetLibVersion()",
        "C": "SetMAnalogDataChar(addr, analogData)",
        "D": "GetLibraryVersion()",
        "Answer(s)": "B"
    },
    {
        "No": 615,
        "Instruction": "Return TRUE if this class object has access to a device, and FALSE otherwise. A device is required to execute most functions in this class. If this function returns FALSE, a device can be created by calling the CreateDevice function from the WMX3Api object that was passed to the constructor of this class.",
        "A": "GetLibVersion()",
        "B": "IsDeviceValid()",
        "C": "GetEventModuleId(id)",
        "D": "IsDeviceValidated()",
        "Answer(s)": "B"
    },
    {
        "No": 616,
        "Instruction": "Get the version of the module rtdll.",
        "A": "GetAppVersion()",
        "B": "GetVersion()",
        "C": "GetInAnalogDataUShortEx(addr)",
        "D": "StartLog(channel)",
        "Answer(s)": "B"
    },
    {
        "No": 617,
        "Instruction": "Start logging data.",
        "A": "ResetLog(channel)",
        "B": "InitializeLogging(channel_id):",
        "C": "StartLog(channel)",
        "D": "OpenApiLogFile(pPath)",
        "Answer(s)": "C"
    },
    {
        "No": 618,
        "Instruction": "Stop logging data.",
        "A": "GetLogOption(channel)",
        "B": "UpdateLogChannel(channel_name)",
        "C": "StopLog(channel)",
        "D": "StopECAM(channel)",
        "Answer(s)": "C"
    },
    {
        "No": 619,
        "Instruction": "Reset the log settings, options, and statuses for the specified log channel.",
        "A": "UpdateLog(channel)",
        "B": "GetLibVersion()",
        "C": "GetLogOption(channel)",
        "D": "ResetLog(channel)",
        "Answer(s)": "D"
    },
    {
        "No": 620,
        "Instruction": "Set the log header string that is copied to the beginning of the log file.",
        "A": "SetChannelLogHeader(channelName, logHeader)",
        "B": "SetLogHeader(channel, pLogHeader)",
        "C": "SetLog(channel, input)",
        "D": "StartMemoryLog(channel)",
        "Answer(s)": "B"
    },
    {
        "No": 621,
        "Instruction": "Specify data to be collected by the logging operation.",
        "A": "StopMemoryLog(channel)",
        "B": "SetLog(channel, input)",
        "C": "StopLog(channel)",
        "D": "SetChannelLog(channel, input)",
        "Answer(s)": "B"
    },
    {
        "No": 622,
        "Instruction": "Set the log options for a log channel.",
        "A": "SetOptions(channel, pOptions)",
        "B": "OpenMemoryLogBuffer(channel)",
        "C": "SetLoggingOption(loggingChannel, optionParams)",
        "D": "SetLogOption(channel, pOption)",
        "Answer(s)": "D"
    },
    {
        "No": 623,
        "Instruction": "Get the log options for a log channel.",
        "A": "GetLoggingOption(channel_name)",
        "B": "GetOptions(channel)",
        "C": "GetLogOption(channel)",
        "D": "SetLogFilePath(channel, pPath)",
        "Answer(s)": "C"
    },
    {
        "No": 624,
        "Instruction": "Set the file path for a log channel.",
        "A": "GetLogFilePath(channel)",
        "B": "SetMemoryMLog(channel, pMAddress, size)",
        "C": "SetLogFilePath(channel_id, file_path)",
        "D": "SetLogFilePath(channel, pPath)",
        "Answer(s)": "D"
    },
    {
        "No": 625,
        "Instruction": "Get the file path for a log channel.",
        "A": "GetWatch(channel)",
        "B": "SetMemoryLog(channel, pAxisSelection, pOption)",
        "C": "GetLogFilePath(channel)",
        "D": "GetLogFilePathForChannel(channel_id)",
        "Answer(s)": "C"
    },
    {
        "No": 626,
        "Instruction": "Get the current status of the data logging operation.",
        "A": "ResetLog(channel)",
        "B": "GetChannelLogStatus(channel_id)",
        "C": "GetPSOStatus(channel)",
        "D": "GetLogStatus(channel)",
        "Answer(s)": "D"
    },
    {
        "No": 627,
        "Instruction": "Get the current status of the data logging operation. Compared to GetLogStatus, more detailed statuses can be obtained.",
        "A": "GetPathIntplLookaheadStatus(channel)",
        "B": "GetDetailLogStatus(channel)",
        "C": "SetLogHeader(channel, pLogHeader)",
        "D": "GetChannelDetailLogStatus(channel_id)",
        "Answer(s)": "B"
    },
    {
        "No": 628,
        "Instruction": "Specify data to be collected by the logging operation.",
        "A": "GetInputData(buff, buffSize, dataSize)",
        "B": "SetLogChannel(channel, filePath, duration, sampleRate, axisSelection, options, mode)",
        "C": "SetLog(channel, pPath, milliseconds, samplePeriodInCycles, pAxisSelection, pOptions, mode)",
        "D": "StartCSplineMov_TotalTime (channel, pSplineCommand, numPoints, pPoint)",
        "Answer(s)": "C"
    },
    {
        "No": 629,
        "Instruction": "Open the memory log buffer.",
        "A": "CreateMemoryLogBuffer(channel_id)",
        "B": "CloseMemoryLogBuffer(channel)",
        "C": "OpenMemoryLogBuffer(channel)",
        "D": "SetMemoryMLog(channel, pMAddress, size)",
        "Answer(s)": "C"
    },
    {
        "No": 630,
        "Instruction": "Close the memory log buffer.",
        "A": "CloseBufferedLog(channel)",
        "B": "SetMemoryIOLog(channel, pInputIOAddress, inputSize, pOutputIOAddress, outputSize)",
        "C": "CloseMemoryLogBuffer(channel)",
        "D": "StartMemoryLog(channel)",
        "Answer(s)": "C"
    },
    {
        "No": 631,
        "Instruction": "Start the memory log operation.",
        "A": "StartMemoryLogging(channel, parameters)",
        "B": "GetMemoryLogData(channel)",
        "C": "StartMemoryLog(channel)",
        "D": "GetLogOption(channel)",
        "Answer(s)": "C"
    },
    {
        "No": 632,
        "Instruction": "Stop the memory log operation.",
        "A": "SetLogOption(channel, pOption)",
        "B": "StopMemoryLogging (channel_id)",
        "C": "StopMemoryLog(channel)",
        "D": "OpenMemoryLogBuffer(channel)",
        "Answer(s)": "C"
    },
    {
        "No": 633,
        "Instruction": "Get the current status of the memory log operation.",
        "A": "GetMemoryLogStatus(channel)",
        "B": "GetMemoryLogStatusForChannel(channel_id)",
        "C": "SetIOLog(channel, pInputIOAddress, inputSize, pOutputIOAddress, outputSize)",
        "D": "GetPSOStatus(channel)",
        "Answer(s)": "A"
    },
    {
        "No": 634,
        "Instruction": "Set the parameters for the API log.",
        "A": "SetLogPath(log_path)",
        "B": "SetIOLogFormat(channel, pInputIOLogFormat, inputIOFormatCount, pOutputIOLogFormat, outputIOFormatCount)",
        "C": "StopApiLog()",
        "D": "SetApiLog(pPath)",
        "Answer(s)": "D"
    },
    {
        "No": 635,
        "Instruction": "Start logging data to the API log.",
        "A": "UpdateApiLogStart()",
        "B": "StartApiLog()",
        "C": "SetApiLog(pPath)",
        "D": "GetMemoryLogData(channel)",
        "Answer(s)": "B"
    },
    {
        "No": 636,
        "Instruction": "Stop logging data to the API log.",
        "A": "Stop(axis)",
        "B": "OpenMemoryLogBuffer(channel)",
        "C": "EndApiLog()",
        "D": "StopApiLog()",
        "Answer(s)": "D"
    },
    {
        "No": 637,
        "Instruction": "Get the current status of the API log.",
        "A": "FetchApiLogStatus()",
        "B": "GetApiLogStatus()",
        "C": "GetLogStatus(channel)",
        "D": "SetIOLogFormat(channel, pInputIOLogFormat, inputIOFormatCount, pOutputIOLogFormat, outputIOFormatCount)",
        "Answer(s)": "B"
    },
    {
        "No": 638,
        "Instruction": "Open an API log file to extract information from the contents.",
        "A": "OpenLogFile(pFilePath)",
        "B": "OpenApiLogFile(pPath)",
        "C": "IsDeviceValid()",
        "D": "CloseApiLogFile(pFile)",
        "Answer(s)": "B"
    },
    {
        "No": 639,
        "Instruction": "Extract the information of one API function call from the API log file.",
        "A": "GetOutputData(buff, buffSize, dataSize)",
        "B": "GetApiLogData_ApiLogInfo(pFileName, bufferSize)",
        "C": "GetApiLogData_ApiLogInfo(pFile, buffSize)",
        "D": "CloseApiLogFile(pFile)",
        "Answer(s)": "C"
    },
    {
        "No": 640,
        "Instruction": "Close an API log file.",
        "A": "CloseApiLogFile(pFile)",
        "B": "CloseLogFile(pLogFileHandle)",
        "C": "SetLog(channel, input)",
        "D": "ClearAllEvent()",
        "Answer(s)": "A"
    },
    {
        "No": 641,
        "Instruction": "Get a string representation of the specified error code.",
        "A": "StartRampRateTrq(pTrqCommand, rampRate)",
        "B": "ConvertErrorCodeToString(code)",
        "C": "ErrorToString(errCode)",
        "D": "SetMAnalogDataUInt(addr, analogData)",
        "Answer(s)": "C"
    },
    {
        "No": 642,
        "Instruction": "Get a string representation of the raw data of an API log.",
        "A": "GetMBit(addr, bit)",
        "B": "GetParam_Axis(axis)",
        "C": "ApiLogToString(pLogData, logDataSize)",
        "D": "ApiLogDataToString(logData, dataSize)",
        "Answer(s)": "C"
    },
    {
        "No": 643,
        "Instruction": "Get the version of the module library.",
        "A": "GetLibVersion()",
        "B": "SetMAnalogDataUShort(addr, analogData)",
        "C": "SdoUpload(slaveId, index, subindex, sdoBuffSize)",
        "D": "FetchLibraryVersion()",
        "Answer(s)": "A"
    },
    {
        "No": 644,
        "Instruction": "Return TRUE if this class object has access to a device, and FALSE otherwise. A device is required to execute most functions in this class. If this function returns FALSE, a device can be created by calling the CreateDevice function from the WMX3Api object that was passed to the constructor of this class.",
        "A": "ErrorToString(errCode)",
        "B": "IsDeviceValid()",
        "C": "GetMAnalogDataCharEx(addr)",
        "D": "IsDeviceValid(deviceId: string)",
        "Answer(s)": "B"
    },
    {
        "No": 645,
        "Instruction": "Get the version of the module rtdll.",
        "A": "ClearPathIntplWithRotation(channel)",
        "B": "SetMAnalogDataInt(addr, analogData)",
        "C": "FetchVersionInfo()",
        "D": "GetVersion()",
        "Answer(s)": "D"
    },
    {
        "No": 646,
        "Instruction": "Set the value of a user memory bit.",
        "A": "SetMAnalogDataInt(addr, analogData)",
        "B": "SetMBit(addr, bit, data)",
        "C": "SetBit(data_address, bit_position, new_bit_value)",
        "D": "SetOutBit(addr, bit, data)",
        "Answer(s)": "B"
    },
    {
        "No": 647,
        "Instruction": "Set the value of a user memory byte.",
        "A": "SetMBitEx(addr, bit, data)",
        "B": "SetMemoryByte(address, value)",
        "C": "SetMAnalogDataUChar(addr, analogData)",
        "D": "SetMByte(addr, data)",
        "Answer(s)": "D"
    },
    {
        "No": 648,
        "Instruction": "Set the value of multiple user memory bytes.",
        "A": "SetMemoryBytes(address, numBytes, data)",
        "B": "SetMAnalogDataUInt(addr, analogData)",
        "C": "SetMBytes(addr, size, pData)",
        "D": "SetOutBytesEx(addr, size, pData)",
        "Answer(s)": "C"
    },
    {
        "No": 649,
        "Instruction": "Set the value of multiple user memory bits.",
        "A": "SetMBits(pByte, pBit, pData, count)",
        "B": "SetMBit(addr, bit, data)",
        "C": "SetMultipleBits(pBuffer, startIndex, bitValues, numBits)",
        "D": "GetMAnalogDataUIntEx(addr)",
        "Answer(s)": "A"
    },
    {
        "No": 650,
        "Instruction": "Set the value of user memory analog data spanning one byte.",
        "A": "SetMAnalogDataCharEx(addr, analogData)",
        "B": "SetAnalogDataChar(address, data)",
        "C": "SetMAnalogDataUInt(addr, analogData)",
        "D": "SetMAnalogDataChar(addr, analogData)",
        "Answer(s)": "D"
    },
    {
        "No": 651,
        "Instruction": "Set the value of user memory analog data spanning one byte.",
        "A": "SetMAnalogDataUChar(addr, newAnalogData)",
        "B": "SetMAnalogDataUChar(addr, analogData)",
        "C": "SetMAnalogDataCharEx(addr, analogData)",
        "D": "SetMAnalogDataChar(addr, analogData)",
        "Answer(s)": "B"
    },
    {
        "No": 652,
        "Instruction": "Set the value of user memory analog data spanning two bytes.",
        "A": "SetMBits(pByte, pBit, pData, count)",
        "B": "SetAnalogDataShort(address, data)",
        "C": "SetMAnalogDataShortEx(addr, analogData)",
        "D": "SetMAnalogDataShort(addr, analogData)",
        "Answer(s)": "D"
    },
    {
        "No": 653,
        "Instruction": "Set the value of user memory analog data spanning two bytes.",
        "A": "SetMAnalogDataShortEx(addr, analogData)",
        "B": "SetAnalogDataUShort(addr, data)",
        "C": "SetMAnalogDataUShort(addr, analogData)",
        "D": "SetMBytesEx(addr, size, pData)",
        "Answer(s)": "C"
    },
    {
        "No": 654,
        "Instruction": "Set the value of user memory analog data spanning four bytes.",
        "A": "SetAnalogDataInt(addr, data)",
        "B": "SetMBit(addr, bit, data)",
        "C": "SetOutAnalogDataUInt(addr, analogData)",
        "D": "SetMAnalogDataInt(addr, analogData)",
        "Answer(s)": "D"
    },
    {
        "No": 655,
        "Instruction": "Set the value of user memory analog data spanning four bytes.",
        "A": "GetMAnalogDataUInt(addr)",
        "B": "SetMAnalogDataIntEx(addr, analogData)",
        "C": "SetMAnalogDataUInt(addr, analogData)",
        "D": "SetMAnalogDataUIntUpdated(addr, newAnalogData)",
        "Answer(s)": "C"
    },
    {
        "No": 656,
        "Instruction": "Get the value of a user memory bit.",
        "A": "GetInBit(addr, bit)",
        "B": "FetchBitAtMemoryAddress(addr, bit)",
        "C": "GetMAnalogDataInt(addr)",
        "D": "GetMBit(addr, bit)",
        "Answer(s)": "D"
    },
    {
        "No": 657,
        "Instruction": "Get the value of a user memory byte.",
        "A": "GetInByte(addr)",
        "B": "GetMByte(addr)",
        "C": "GetMByteAtAddress(address)",
        "D": "SetMBits(pByte, pBit, pData, count)",
        "Answer(s)": "B"
    },
    {
        "No": 658,
        "Instruction": "Get the value of multiple user memory bytes.",
        "A": "GetMegaBytes(address, size)",
        "B": "GetMBytes(addr, size)",
        "C": "GetOutBytes(addr, size)",
        "D": "SetMAnalogDataUShort(addr, analogData)",
        "Answer(s)": "B"
    },
    {
        "No": 659,
        "Instruction": "Get the value of user memory analog data spanning one byte.",
        "A": "GetAnalogDataChar(address)",
        "B": "GetMAnalogDataUInt(addr)",
        "C": "GetMAnalogDataChar(addr)",
        "D": "GetMAnalogDataUChar(addr)",
        "Answer(s)": "C"
    },
    {
        "No": 660,
        "Instruction": "Get the value of user memory analog data spanning one byte.",
        "A": "GetAnalogDataUChar(addr)",
        "B": "GetMAnalogDataUChar(addr)",
        "C": "GetLibVersion()",
        "D": "GetMAnalogDataCharEx(addr)",
        "Answer(s)": "B"
    },
    {
        "No": 661,
        "Instruction": "Get the value of user memory analog data spanning two bytes.",
        "A": "GetMAnalogDataShort(addr)",
        "B": "GetInAnalogDataShort(addr)",
        "C": "FetchAnalogDataShort(addr)",
        "D": "SetMByte(addr, data)",
        "Answer(s)": "A"
    },
    {
        "No": 662,
        "Instruction": "Get the value of user memory analog data spanning two bytes.",
        "A": "GetMAnalogDataUShort(addr)",
        "B": "GetInAnalogDataUShort(addr)",
        "C": "SetMAnalogDataUChar(addr, analogData)",
        "D": "GetAnalogDataUShort(addr)",
        "Answer(s)": "A"
    },
    {
        "No": 663,
        "Instruction": "Get the value of user memory analog data spanning four bytes.",
        "A": "SetMBytes(addr, size, pData)",
        "B": "GetMAnalogDataInt(addr)",
        "C": "GetMAnalogDataIntEx(addr)",
        "D": "GetAnalogDataInt(address)",
        "Answer(s)": "B"
    },
    {
        "No": 664,
        "Instruction": "Get the value of user memory analog data spanning four bytes.",
        "A": "GetMAnalogDataInt(addr)",
        "B": "GetMByteEx(addr)",
        "C": "GetMAnalogDataUInt(addr)",
        "D": "GetAnalogDataUInt(addr)",
        "Answer(s)": "C"
    },
    {
        "No": 665,
        "Instruction": "Set the value of a user memory bit.",
        "A": "SetMAnalogDataUCharEx(addr, analogData)",
        "B": "SetMBitEx(addr, bit, data)",
        "C": "SetBitExtended(address, bitPosition, value)",
        "D": "SetMByte(addr, data)",
        "Answer(s)": "B"
    },
    {
        "No": 666,
        "Instruction": "Set the value of a user memory byte.",
        "A": "SetMByteEx(addr, data)",
        "B": "WriteMByteEx(addr, data)",
        "C": "GetMAnalogDataUShort(addr)",
        "D": "SetMBytesEx(addr, size, pData)",
        "Answer(s)": "A"
    },
    {
        "No": 667,
        "Instruction": "Set the value of multiple user memory bytes.",
        "A": "SetMBytesEx(addr, size, pData)",
        "B": "SetOutBytes(addr, size, pData)",
        "C": "GetMBitEx(addr, bit)",
        "D": "SetMBytes(addr, numBytes, dataBlock)",
        "Answer(s)": "A"
    },
    {
        "No": 668,
        "Instruction": "Set the value of multiple user memory bits.",
        "A": "UpdateBitsInByteEx(pByteData, bitPosition, newData, bitCount)",
        "B": "SetMBitsEx(pByte, pBit, pData, count)",
        "C": "SetOutBitsEx(pByte, pBit, pData, count)",
        "D": "GetMBytes(addr, size)",
        "Answer(s)": "B"
    },
    {
        "No": 669,
        "Instruction": "Set the value of user memory analog data spanning one byte.",
        "A": "SetOutAnalogDataCharEx(addr, analogData)",
        "B": "SetMAnalogDataCharEx(addr, analogData)",
        "C": "SetAnalogDataEx(addr, data)",
        "D": "SetMAnalogDataChar(addr, analogData)",
        "Answer(s)": "B"
    },
    {
        "No": 670,
        "Instruction": "Set the value of user memory analog data spanning one byte.",
        "A": "SetMAnalogDataUChar(addr, analogData)",
        "B": "SetMAnalogDataUCharEx(addr, analogData)",
        "C": "SetMAnalogDataCharEx(addr, analogData)",
        "D": "GetMAnalogDataShortEx(addr)",
        "Answer(s)": "B"
    },
    {
        "No": 671,
        "Instruction": "Set the value of user memory analog data spanning two bytes.",
        "A": "SetMAnalogDataCharEx(addr, analogData)",
        "B": "SetOutAnalogDataShortEx(addr, analogData)",
        "C": "SetMAnalogDataShort(addr, data)",
        "D": "SetMAnalogDataShortEx(addr, analogData)",
        "Answer(s)": "D"
    },
    {
        "No": 672,
        "Instruction": "Set the value of user memory analog data spanning two bytes.",
        "A": "SetMAnalogDataUShortEx(addr, newAnalogData)",
        "B": "SetMAnalogDataUShortEx(addr, analogData)",
        "C": "SetMAnalogDataShort(addr, analogData)",
        "D": "GetMBytesEx(addr, size)",
        "Answer(s)": "B"
    },
    {
        "No": 673,
        "Instruction": "Set the value of user memory analog data spanning four bytes.",
        "A": "SetMAnalogDataUShortEx(addr, analogData)",
        "B": "SetAnalogData(addr, analogValues)",
        "C": "SetMAnalogDataUIntEx(addr, analogData)",
        "D": "SetMAnalogDataIntEx(addr, analogData)",
        "Answer(s)": "D"
    },
    {
        "No": 674,
        "Instruction": "Set the value of user memory analog data spanning four bytes.",
        "A": "SetMAnalogDataUIntEx(addr, analogData)",
        "B": "SetMAnalogDataIntEx(addr, analogData)",
        "C": "GetMAnalogDataUShort(addr)",
        "D": "SetAnalogDataUIntEx(address, data)",
        "Answer(s)": "A"
    },
    {
        "No": 675,
        "Instruction": "Get the value of a user memory bit.",
        "A": "GetInBit(addr, bit)",
        "B": "GetMBitEx(addr, bit)",
        "C": "GetLibVersion()",
        "D": "GetMBitRange(addr, start_bit, end_bit)",
        "Answer(s)": "B"
    },
    {
        "No": 676,
        "Instruction": "Get the value of a user memory byte.",
        "A": "GetMBytesEx(addr, size)",
        "B": "GetMegabyteExtended(address)",
        "C": "GetMByteEx(addr)",
        "D": "GetInByteEx(addr)",
        "Answer(s)": "C"
    },
    {
        "No": 677,
        "Instruction": "Get the value of multiple user memory bytes.",
        "A": "GetMBytes(addr, size)",
        "B": "GetMBytesEx(addr, size)",
        "C": "ReadMemoryBlockEx(address, blockSize)",
        "D": "IsDeviceValid()",
        "Answer(s)": "B"
    },
    {
        "No": 678,
        "Instruction": "Get the value of user memory analog data spanning one byte.",
        "A": "GetMAnalogDataUCharEx(addr)",
        "B": "GetAnalogDataAtAddress(addr):",
        "C": "GetMAnalogDataCharEx(addr)",
        "D": "SetMAnalogDataUShortEx(addr, analogData)",
        "Answer(s)": "C"
    },
    {
        "No": 679,
        "Instruction": "Get the value of user memory analog data spanning one byte.",
        "A": "GetMAnalogDataUChar(addr)",
        "B": "SetMAnalogDataUIntEx(addr, analogData)",
        "C": "GetMAnalogDataUCharEx(addr)",
        "D": "GetAnalogDataUChar(addr)",
        "Answer(s)": "C"
    },
    {
        "No": 680,
        "Instruction": "Get the value of user memory analog data spanning two bytes.",
        "A": "GetAnalogShortData(addr)",
        "B": "SetMAnalogDataShort(addr, analogData)",
        "C": "GetMAnalogDataShortEx(addr)",
        "D": "GetMAnalogDataUShortEx(addr)",
        "Answer(s)": "C"
    },
    {
        "No": 681,
        "Instruction": "Get the value of user memory analog data spanning two bytes.",
        "A": "GetInAnalogDataUShortEx(addr)",
        "B": "GetMAnalogDataUShortEx(addr)",
        "C": "GetAnalogDataUShortExtended(address)",
        "D": "SetMAnalogDataUInt(addr, analogData)",
        "Answer(s)": "B"
    },
    {
        "No": 682,
        "Instruction": "Get the value of user memory analog data spanning four bytes.",
        "A": "GetInAnalogDataUIntEx(addr)",
        "B": "SetMAnalogDataShortEx(addr, analogData)",
        "C": "FetchAnalogDataIntByAddressEx(address)",
        "D": "GetMAnalogDataIntEx(addr)",
        "Answer(s)": "D"
    },
    {
        "No": 683,
        "Instruction": "Get the value of user memory analog data spanning four bytes.",
        "A": "GetMAnalogDataInt(addr)",
        "B": "SetMAnalogDataUChar(addr, analogData)",
        "C": "GetMAnalogDataUIntEx(addr)",
        "D": "GetAnalogMeasurementDataUintExtended(address)",
        "Answer(s)": "C"
    },
    {
        "No": 684,
        "Instruction": "Get a string representation of the specified error code.",
        "A": "ErrorToString(errCode)",
        "B": "IsDeviceValid()",
        "C": "GetAllDevices()",
        "D": "ErrorToStringFormatted(errorCode)",
        "Answer(s)": "A"
    },
    {
        "No": 685,
        "Instruction": "Get a string representation of the raw data of an API log.",
        "A": "ApiLogToString(pLogData, logDataSize)",
        "B": "GetOutAnalogDataUInt(addr)",
        "C": "ApiLogDataToString(logData, dataSize)",
        "D": "SetWatchdog(watchdog)",
        "Answer(s)": "A"
    },
    {
        "No": 686,
        "Instruction": "Get the version of the module library.",
        "A": "GetLibraryVersion()",
        "B": "SetDeviceWaitEvent(errCode)",
        "C": "Execute(channel)",
        "D": "GetLibVersion()",
        "Answer(s)": "D"
    },
    {
        "No": 687,
        "Instruction": "Get the version of the IMDll.",
        "A": "GetImDllVersion()",
        "B": "GetIMDllVersion()",
        "C": "SetWatchdog(watchdog)",
        "D": "GetVersion()",
        "Answer(s)": "B"
    },
    {
        "No": 688,
        "Instruction": "Append a string to a file.",
        "A": "OpenApiLogFile(pPath)",
        "B": "SaveToFile(file_path, file_format)",
        "C": "PrintToFile(filePath, format)",
        "D": "SetWatchdog(watchdog)",
        "Answer(s)": "C"
    },
    {
        "No": 689,
        "Instruction": "Append a string to a file.",
        "A": "GetWatchDog()",
        "B": "Export_AxisPrm(pPath, pAxisParam)",
        "C": "PrintToFileIfExist(filePath, format)",
        "D": "SaveFileIfExists(filePath, fileFormat)",
        "Answer(s)": "C"
    },
    {
        "No": 690,
        "Instruction": "Get the character string stored in the WMX3 engine message output buffer.",
        "A": "PrintToServerConsole(format)",
        "B": "GetStatistic()",
        "C": "GetStandardOutputString()",
        "D": "GetStdOutStr()",
        "Answer(s)": "D"
    },
    {
        "No": 691,
        "Instruction": "Get the size of the string stored in the WMX3 engine message output buffer.",
        "A": "GetStdOutDataSize()",
        "B": "GetModuleInfo(moduleId)",
        "C": "RetrieveStdOutDataSize():",
        "D": "GetHomeData()",
        "Answer(s)": "A"
    },
    {
        "No": 692,
        "Instruction": "Clear the string stored in the WMX3 engine message output buffer.",
        "A": "GetStdOutDataSize()",
        "B": "ClearStdOut()",
        "C": "SetWatchdog(watchdog)",
        "D": "ClearConsoleOutput()",
        "Answer(s)": "B"
    },
    {
        "No": 693,
        "Instruction": "Release resources related to the WMX3 engine message output buffer.",
        "A": "ReleaseStdOutBuffer():",
        "B": "ReleaseStdOut()",
        "C": "ReleaseEStop()",
        "D": "CompareWindowsUpdates()",
        "Answer(s)": "B"
    },
    {
        "No": 694,
        "Instruction": "Return TRUE if this class object has access to a device, and FALSE otherwise. A device is required to execute most functions in this class. If this function returns FALSE, a device can be created by calling the CreateDevice function from the WMX3Api object that was passed to the constructor of this class.",
        "A": "GetMAnalogDataInt(addr)",
        "B": "IsValidDevice()",
        "C": "IsDeviceValid()",
        "D": "GetModuleSuspend()",
        "Answer(s)": "C"
    },
    {
        "No": 695,
        "Instruction": "Start the WMX3 engine without creating a device.",
        "A": "RestartEngine(path)",
        "B": "InitializeEngine(filePath)",
        "C": "StartEngine(path)",
        "D": "GetLibVersion()",
        "Answer(s)": "C"
    },
    {
        "No": 696,
        "Instruction": "Stop the currently running WMX3 engine and then restart the WMX3 engine.",
        "A": "PrintToServerConsole(format)",
        "B": "GetEngineStatus()",
        "C": "RestartEngine(path)",
        "D": "RevertEngine(path)",
        "Answer(s)": "C"
    },
    {
        "No": 697,
        "Instruction": "Stop the currently running WMX3 engine.",
        "A": "StopEngine()",
        "B": "StopLog(channel)",
        "C": "GetDeviceID()",
        "D": "ShutdownEngine():",
        "Answer(s)": "A"
    },
    {
        "No": 698,
        "Instruction": "Create a device to interface with the WMX3 engine.",
        "A": "SetDeviceName(name)",
        "B": "UpdateDevice(path)",
        "C": "ResetDeviceWaitEvent()",
        "D": "CreateDevice(path)",
        "Answer(s)": "D"
    },
    {
        "No": 699,
        "Instruction": "Close a device.",
        "A": "ApiLogToString(pLogData, logDataSize)",
        "B": "IsDeviceValid()",
        "C": "CloseDevice()",
        "D": "CloseConnection()",
        "Answer(s)": "C"
    },
    {
        "No": 700,
        "Instruction": "Get the device ID number of the device.",
        "A": "GetDeviceSerialNumber()",
        "B": "GetDeviceName()",
        "C": "SetDeviceName(name)",
        "D": "GetDeviceID()",
        "Answer(s)": "D"
    },
    {
        "No": 701,
        "Instruction": "Configure the engine to automatically quit or not automatically quit when the last device is closed by a watchdog time out.",
        "A": "AutoQuitWithoutActiveDev(quit)",
        "B": "AutoQuitWithoutActiveDev(withConfirmation)",
        "C": "ResetDeviceWaitEvent()",
        "D": "StartPathIntplWithRotation_Point(channel, point)",
        "Answer(s)": "A"
    },
    {
        "No": 702,
        "Instruction": "Set the watchdog time out period for the device that called this function.",
        "A": "SetWatch(channel, pWatch)",
        "B": "SetAlarmSystem(watchdog_system)",
        "C": "SetWatchdog(watchdog)",
        "D": "SetDeviceWaitEvent(errCode)",
        "Answer(s)": "C"
    },
    {
        "No": 703,
        "Instruction": "Set the watchdog time out period for a specific device.",
        "A": "SetWatchdog(deviceId, watchdog)",
        "B": "GetDeviceName()",
        "C": "CreateDevice(path)",
        "D": "setWatchdogConfig(deviceId, configOptions)",
        "Answer(s)": "A"
    },
    {
        "No": 704,
        "Instruction": "Get the watchdog time out period and the current watchdog count.",
        "A": "GetWatch(channel)",
        "B": "GetWatchDogConfiguration()",
        "C": "GetWatchDog()",
        "D": "ReleaseStdOut()",
        "Answer(s)": "C"
    },
    {
        "No": 705,
        "Instruction": "Reset the watchdog count of a device.",
        "A": "ResetWatchdogTimer()",
        "B": "RefreshWatchdogTimer()",
        "C": "SetWatchdog(deviceId, watchdog)",
        "D": "RestartEngine(path)",
        "Answer(s)": "A"
    },
    {
        "No": 706,
        "Instruction": "Configure a device to collect API execution statistics data.",
        "A": "SetStatistic(enable)",
        "B": "ToggleStatistic(enable_toggle)",
        "C": "SetDeviceName(name)",
        "D": "SetSingleTurn(axis, enable. encoderCount)",
        "Answer(s)": "A"
    },
    {
        "No": 707,
        "Instruction": "Read the currently collected API execution statistics data.",
        "A": "GetStatus()",
        "B": "GetDeviceName()",
        "C": "GetStatistic()",
        "D": "GetStatisticsMetrics()",
        "Answer(s)": "C"
    },
    {
        "No": 708,
        "Instruction": "Set the interrupt (cyclic handler) associated with the calling device.",
        "A": "SetInterruptId(interrputId)",
        "B": "SetInterruptIdWithPriority(interruptId, priority)",
        "C": "SetUpdatePeriod(period)",
        "D": "SetWatchdog(watchdog)",
        "Answer(s)": "A"
    },
    {
        "No": 709,
        "Instruction": "Get the interrupt (cyclic handler) associated with the calling device.",
        "A": "GetInterruptId(interrputId)",
        "B": "SetEventOutput(id, pEventOutput)",
        "C": "PrintToFile(filePath, format)",
        "D": "GetInterruptById(interruptId)",
        "Answer(s)": "A"
    },
    {
        "No": 710,
        "Instruction": "Start communication with the servo network.",
        "A": "StartCommunication()",
        "B": "GetEngineStatus()",
        "C": "StopCommunication()",
        "D": "InitiateCommunication():",
        "Answer(s)": "A"
    },
    {
        "No": 711,
        "Instruction": "Stop communication with the servo network.",
        "A": "StopCommunication()",
        "B": "SleepAtEngine(microSecond)",
        "C": "EndCommunication()",
        "D": "StartCommunication()",
        "Answer(s)": "A"
    },
    {
        "No": 712,
        "Instruction": "Obtain information of the modules that are loaded by the engine.",
        "A": "AutoQuitWithoutActiveDev(quit)",
        "B": "GetModulesInfo()",
        "C": "GetModuleInfo(moduleId)",
        "D": "GetModulesDetails()",
        "Answer(s)": "B"
    },
    {
        "No": 713,
        "Instruction": "Obtain information of a single module that is loaded by the engine.",
        "A": "GetModuleInfo(moduleId)",
        "B": "GetModuleId()",
        "C": "ApiLogToString(pLogData, logDataSize)",
        "D": "GetModuleDetails(moduleId)",
        "Answer(s)": "A"
    },
    {
        "No": 714,
        "Instruction": "Obtain the status of the engine.",
        "A": "GetEngineStatusInformation()",
        "B": "SetInterruptId(interrputId)",
        "C": "GetStatus(axis)",
        "D": "GetEngineStatus()",
        "Answer(s)": "D"
    },
    {
        "No": 715,
        "Instruction": "Obtain information of all existing devices.",
        "A": "ClearAllEvent()",
        "B": "GetAllDevices()",
        "C": "GetAllConnectedDevices()",
        "D": "GetStdOutDataSize()",
        "Answer(s)": "B"
    },
    {
        "No": 716,
        "Instruction": "Set the name of this device.",
        "A": "SetDeviceName(name)",
        "B": "SetDeviceWaitEvent(errCode)",
        "C": "UpdateDeviceName(name)",
        "D": "CreateDevice(path)",
        "Answer(s)": "A"
    },
    {
        "No": 717,
        "Instruction": "Get the name of this device.",
        "A": "PrintToServerConsole(format)",
        "B": "GetProductName(deviceId: int)",
        "C": "GetDeviceID()",
        "D": "GetDeviceName()",
        "Answer(s)": "D"
    },
    {
        "No": 718,
        "Instruction": "Reserved.",
        "A": "AutoQuitWithoutActiveDev(quit)",
        "B": "SetDeviceWaitEvent(errCode)",
        "C": "ResetDeviceWaitEvent()",
        "D": "SetDeviceWaitEventWithTimeout(errCode, timeout)",
        "Answer(s)": "B"
    },
    {
        "No": 719,
        "Instruction": "Reserved.",
        "A": "SetWatchdog(watchdog)",
        "B": "ResetDeviceWaitEvent()",
        "C": "GetDeviceName()",
        "D": "function_str = ResetDeviceOptionalEvent()",
        "Answer(s)": "B"
    },
    {
        "No": 720,
        "Instruction": "Reserved.",
        "A": "RecordWindowsUpdates(waitTimeMilliseconds)",
        "B": "WaitForDeviceWaitEvent(waitTime, errCode)",
        "C": "WaitForDeviceWaitEventWithTimeout(timeToWait, errorCode)",
        "D": "SetDeviceName(name)",
        "Answer(s)": "B"
    },
    {
        "No": 721,
        "Instruction": "Set whether to suspend loading specific platform modules when starting communication.",
        "A": "SetModuleSuspend(suspend)",
        "B": "GetModuleId()",
        "C": "SetModulePause(pause)",
        "D": "SetInterruptId(interrputId)",
        "Answer(s)": "A"
    },
    {
        "No": 722,
        "Instruction": "Get the settings of whether to suspend loading specific platform modules when starting communication.",
        "A": "GetModuleSuspend()",
        "B": "GetModuleId()",
        "C": "PrintToFile(filePath, format)",
        "D": "GetSuspendModuleInfo()",
        "Answer(s)": "A"
    },
    {
        "No": 723,
        "Instruction": "Clear all settings of whether to suspend loading specific platform modules when starting communication.",
        "A": "AbortModuleSuspend()",
        "B": "GetModuleId()",
        "C": "Slightly modified function: CancelModuleSuspend()",
        "D": "GetModuleInfo(moduleId)",
        "Answer(s)": "A"
    },
    {
        "No": 724,
        "Instruction": "Pauses execution of the current thread until the specified timeout interval elapses.",
        "A": "SetUpdatePeriod(period)",
        "B": "SetStatistic(enable)",
        "C": "SleepAtEngine(milliseconds)",
        "D": "SleepAtEngine(microSecond)",
        "Answer(s)": "D"
    },
    {
        "No": 725,
        "Instruction": "Print a message to the Console Screen.",
        "A": "GetPitchErrorCompensation(axis)",
        "B": "PrintToServerLog(format)",
        "C": "PrintToServerConsole(format)",
        "D": "RecordWindowsUpdates(waitTimeMilliseconds)",
        "Answer(s)": "C"
    },
    {
        "No": 726,
        "Instruction": "Record a list of installed Windows Updates to file.",
        "A": "RecordWindowsUpdates()",
        "B": "CreateDevice(path)",
        "C": "UpdateWindowsRecord()",
        "D": "GetRecordingBufferChannel()",
        "Answer(s)": "A"
    },
    {
        "No": 727,
        "Instruction": "Record a list of installed Windows Updates to file.",
        "A": "Wait_TimeMilli(axis, waitTimeMilliseconds)",
        "B": "RecordWindowsUpdates(waitTimeMilliseconds)",
        "C": "RecordWindowsUpdates(updateIntervalSeconds)",
        "D": "StartCommunication()",
        "Answer(s)": "B"
    },
    {
        "No": 728,
        "Instruction": "Compare the list of currently installed Windows Updates to the list recorded to file.",
        "A": "UpdateWindowsComparison()",
        "B": "StartEngine(path)",
        "C": "RecordWindowsUpdates()",
        "D": "CompareWindowsUpdates()",
        "Answer(s)": "D"
    },
    {
        "No": 729,
        "Instruction": "Compare the list of currently installed Windows Updates to the list recorded to file.",
        "A": "CompareSoftwarePatchUpdates(waitTimeMilliseconds)",
        "B": "RecordWindowsUpdates()",
        "C": "Wait_TimeMilli(axis, waitTimeMilliseconds)",
        "D": "CompareWindowsUpdates(waitTimeMilliseconds)",
        "Answer(s)": "D"
    },
    {
        "No": 730,
        "Instruction": "Get a string representation of the specified error code.",
        "A": "SdoDownload_SdoType(slaveId, index, subindex, sdoType, sdoDataSize, sdoData)",
        "B": "ErrorToString(errCode)",
        "C": "StartPathIntpl3DMov_TriggerEvents(pPathIntplCommand, pTriggerEvents, numAddlCommands, pPathIntplAddlCommand)",
        "D": "ErrorDescription(code)",
        "Answer(s)": "B"
    },
    {
        "No": 731,
        "Instruction": "Get the version of the module library.",
        "A": "GetVersion()",
        "B": "GetPSOConfig_Option(channel)",
        "C": "GetLibVersion()",
        "D": "FetchLibVersion()",
        "Answer(s)": "C"
    },
    {
        "No": 732,
        "Instruction": "Return TRUE if this class object has access to a device, and FALSE otherwise. A device is required to execute most functions in this class. If this function returns FALSE, a device can be created by calling the CreateDevice function from the WMX3Api object that was passed to the constructor of this class.",
        "A": "SdoDownload(slaveId, dropNo, index, subindex, sdoDataSize, sdoData)",
        "B": "PdoRead(slaveId, index, subindex, pdoBuffSize)",
        "C": "IsDeviceValid()",
        "D": "IsValidDevice()",
        "Answer(s)": "C"
    },
    {
        "No": 733,
        "Instruction": "Get the version of the module rtdll.",
        "A": "ScanNetwork()",
        "B": "SimulatePosAtTime(pSimulatePosCommand, int returnType, double timeMilliseconds)",
        "C": "GetVersion()",
        "D": "FetchCurrentVersion()",
        "Answer(s)": "C"
    },
    {
        "No": 734,
        "Instruction": "Scan the network topology.",
        "A": "ScanNetwork()",
        "B": "SdoDownload_SdoType(slaveId, index, subindex, sdoType, sdoDataSize, sdoData)",
        "C": "DiscoverNetworkDevices()",
        "D": "StartHotconnect()",
        "Answer(s)": "A"
    },
    {
        "No": 735,
        "Instruction": "Change the specified slave state.",
        "A": "ChangeSlaveStatus(slaveId, status)",
        "B": "ChangeSlaveState(slaveId, state)",
        "C": "GetVersion()",
        "D": "HaltAxis(slaveId, axisIndex)",
        "Answer(s)": "B"
    },
    {
        "No": 736,
        "Instruction": "Start hot connect.",
        "A": "StartHotconnect()",
        "B": "SdoUpload(slaveId, index, subindex, sdoBuffSize)",
        "C": "InitiateHotConnection()",
        "D": "StartEngine(path)",
        "Answer(s)": "A"
    },
    {
        "No": 737,
        "Instruction": "Read the current master information from the engine.",
        "A": "GetVersion()",
        "B": "GetMasterDetails()",
        "C": "GetMasterInfo()",
        "D": "SdoDownload_SdoType(slaveId, index, subindex, sdoType, sdoDataSize, sdoData)",
        "Answer(s)": "C"
    },
    {
        "No": 738,
        "Instruction": "Download data to the specified slave SDO.",
        "A": "SdoDownload(slaveId, index, subindex, sdoDataSize, sdoData)",
        "B": "SdoDownload(slaveId, dropNo, index, subindex, sdoDataSize, sdoData)",
        "C": "SdoUpload(slaveId, index, subindex, sdoDataSize, sdoData)",
        "D": "SetUpdatePeriod(period)",
        "Answer(s)": "A"
    },
    {
        "No": 739,
        "Instruction": "Upload data from the specified slave SDO.",
        "A": "SdoUpload(slaveId, index, subindex, sdoBuffSize)",
        "B": "SdoUpload_SdoType(slaveId, index, subindex, sdoType, sdoBuffSize)",
        "C": "GetMasterInfo()",
        "D": "SdoUploadExtended(slaveId, index, subindex, sdoBuffSize)",
        "Answer(s)": "A"
    },
    {
        "No": 740,
        "Instruction": "Download data to the specified slave SDO.",
        "A": "SdoDownload_SdoType(slaveId, index, subindex, sdoType, sdoDataSize, sdoData)",
        "B": "SdoUpload_SdoType(slaveId, index, subindex, sdoType, sdoDataSize, sdoData)",
        "C": "HaltAxis(slaveId, axisIndex)",
        "D": "SdoDownload(slaveId, index, subindex, sdoDataSize, sdoData)",
        "Answer(s)": "A"
    },
    {
        "No": 741,
        "Instruction": "Upload data from the specified slave SDO.",
        "A": "SdoDownload_SdoType(slaveId, index, subindex, sdoType, sdoDataSize, sdoData)",
        "B": "SdoUpload(slaveId, index, subindex, sdoBuffSize)",
        "C": "SdoUpload_SdoType(slaveId, index, subindex, sdoType, sdoBuffSize)",
        "D": "SdoUpload_SdoRequest(slaveId, index, subindex, sdoDataType, sdoDataSize)",
        "Answer(s)": "C"
    },
    {
        "No": 742,
        "Instruction": "Write data to the specified slave's Tx PDO.",
        "A": "TxPdoWriteRequest(slaveId, index, subindex, dataSize, data)",
        "B": "TxPdoWrite(slaveId, index, subindex, pdoDataSize, pdoData)",
        "C": "HaltAxis(slaveId, axisIndex)",
        "D": "PdoRead(slaveId, index, subindex, pdoBuffSize)",
        "Answer(s)": "B"
    },
    {
        "No": 743,
        "Instruction": "Clear the data which is being written to Tx PDO.",
        "A": "PdoRead(slaveId, index, subindex, pdoBuffSize)",
        "B": "SdoUpload_SdoType(slaveId, index, subindex, sdoType, sdoBuffSize)",
        "C": "ClearTxPdoWriteRequest(slaveId, pdoIndex, pdoSubindex)",
        "D": "ClearTxPdoWrite(slaveId, index, subindex)",
        "Answer(s)": "D"
    },
    {
        "No": 744,
        "Instruction": "Read data from the specified slave's Rx or Tx PDO.",
        "A": "GetVersion()",
        "B": "PdoReadFromSlave(slaveNum, dataIndex, subIndex, buffSize)",
        "C": "SdoUpload(slaveId, dropNo, index, subindex, sdoBuffSize)",
        "D": "PdoRead(slaveId, index, subindex, pdoBuffSize)",
        "Answer(s)": "D"
    },
    {
        "No": 745,
        "Instruction": "Set the axis operation mode for a specified slave axis.",
        "A": "SetAxisMode(slaveId, axisIndex, mode)",
        "B": "SetAxisModeByIdAndIndex(slaveId, axisIndex, mode)",
        "C": "HaltAxisRelease(slaveId, axisIndex)",
        "D": "HaltAxis(slaveId, axisIndex)",
        "Answer(s)": "A"
    },
    {
        "No": 746,
        "Instruction": "Start the PP operation for a specified slave axis.",
        "A": "SetAxisPositionProfile(slaveId, axisIndex, targetPos, maxVelocity, acceleration, deceleration)",
        "B": "StartAxisPP(slaveId, axisIndex, targetPos, profileVel, profileAcc, profileDec)",
        "C": "SetAxisMode(slaveId, axisIndex, mode)",
        "D": "SetAxisMode(slaveId, axisIndex, mode)",
        "Answer(s)": "B"
    },
    {
        "No": 747,
        "Instruction": "Start the HM operation for a specified slave axis.",
        "A": "InitializeAxisHM(slaveId, axisIndex, opMode, maxSpeed, minSpeed, hmAcc)",
        "B": "SdoUpload_SdoType(slaveId, index, subindex, sdoType, sdoBuffSize)",
        "C": "StartAxisHM(slaveId, axisIndex, method, switchSpeed, zeroSpeed, hmAcc)",
        "D": "StartAxisPP(slaveId, axisIndex, targetPos, profileVel, profileAcc, profileDec)",
        "Answer(s)": "C"
    },
    {
        "No": 748,
        "Instruction": "Halt the specified slave axis.",
        "A": "HaltAxisRelease(slaveId, axisIndex)",
        "B": "GetLibVersion()",
        "C": "AdjustAxisHalt(slaveId, axisIndex)",
        "D": "HaltAxis(slaveId, axisIndex)",
        "Answer(s)": "D"
    },
    {
        "No": 749,
        "Instruction": "Release the halt state for a specified slave axis.",
        "A": "SdoUpload_SdoType(slaveId, index, subindex, sdoType, sdoBuffSize)",
        "B": "HaltAxisRelease(slaveId, axisIndex)",
        "C": "SetAxisMode(slaveId, axisIndex, mode)",
        "D": "StopAxisRelease(slaveId, axisIndex)",
        "Answer(s)": "B"
    },
    {
        "No": 750,
        "Instruction": "Set the master info update period.",
        "A": "SetUpdatePeriod(period)",
        "B": "GetOutputModuleId()",
        "C": "HaltAxisRelease(slaveId, axisIndex)",
        "D": "SetUpdateInterval(interval)",
        "Answer(s)": "A"
    },
    {
        "No": 751,
        "Instruction": "Get a string representation of the specified error code.",
        "A": "GetPathIntplBufferPoints(axis, pPoints)",
        "B": "ErrorToString(errCode)",
        "C": "StartAxisPP(slaveId, axisIndex, targetPos, profileVel, profileAcc, profileDec)",
        "D": "StringifyError(errorCode)",
        "Answer(s)": "B"
    },
    {
        "No": 752,
        "Instruction": "Get the version of the module library.",
        "A": "GetLibraryVersion()",
        "B": "ResetSyncStatisticsInfo()",
        "C": "ApiLogToString(pLogData, logDataSize)",
        "D": "GetLibVersion()",
        "Answer(s)": "D"
    },
    {
        "No": 753,
        "Instruction": "Return TRUE if this class object has access to a device, and FALSE otherwise. A device is required to execute most functions in this class. If this function returns FALSE, a device can be created by calling the CreateDevice function from the WMX3Api object that was passed to the constructor of this class.",
        "A": "IsDeviceValid()",
        "B": "GetMasterInfo()",
        "C": "CheckIfDeviceIsValid()",
        "D": "GetIMDllVersion()",
        "Answer(s)": "A"
    },
    {
        "No": 754,
        "Instruction": "Get the version of the module rtdll in CCLINK.",
        "A": "ResetSlaveError(slaveId)",
        "B": "GetVersion()",
        "C": "FetchVersion()",
        "D": "StopEngine()",
        "Answer(s)": "B"
    },
    {
        "No": 755,
        "Instruction": "Reset the salve's error in CCLINK.",
        "A": "ResetSlaveError(slaveId)",
        "B": "ResetSlave(slaveId)",
        "C": "SyncToJog(slaveAxis)",
        "D": "StartHotconnect()",
        "Answer(s)": "A"
    },
    {
        "No": 756,
        "Instruction": "Set the master info update period in CCLINK.",
        "A": "GetOutputModuleId()",
        "B": "SetPeriodicUpdate(interval)",
        "C": "SlmpSendBySlaveId(slaveId, port, dropNo, command, subCommand, dataSize, data, buffSize)",
        "D": "SetUpdatePeriod(period)",
        "Answer(s)": "D"
    },
    {
        "No": 757,
        "Instruction": "Read the current master information from the engine in CCLINK.",
        "A": "GetMasterInfo()",
        "B": "GetDetailedMasterInfo()",
        "C": "GetVersion()",
        "D": "GetVersion()",
        "Answer(s)": "A"
    },
    {
        "No": 758,
        "Instruction": "Scan the network topology in CCLINK.",
        "A": "EnumerateNetworkDevices()",
        "B": "ScanNetwork()",
        "C": "StartHotconnect()",
        "D": "SdoDownload_SdoType(slaveId, dropNo, index, subindex, sdoType, sdoDataSize, sdoData)",
        "Answer(s)": "B"
    },
    {
        "No": 759,
        "Instruction": "Start hot connect in CCLINK.",
        "A": "StartHotconnect()",
        "B": "StartPT(pPTCommand)",
        "C": "SdoUpload_SdoType(slaveId, dropNo, index, subindex, sdoType, sdoBuffSize)",
        "D": "StartHotspotConnection()",
        "Answer(s)": "A"
    },
    {
        "No": 760,
        "Instruction": "Reset the synchronization statistics information in CCLINK.",
        "A": "SetSyncMasterSlave(masterAxis, slaveAxis)",
        "B": "UpdateSyncStatisticsInfo()",
        "C": "HaltAxisRelease(slaveId, axisIndex)",
        "D": "ResetSyncStatisticsInfo()",
        "Answer(s)": "D"
    },
    {
        "No": 761,
        "Instruction": "Download data to the specified slave SDO in CCLINK.",
        "A": "TxPdoWrite(slaveId, index, subindex, pdoDataSize, pdoData)",
        "B": "SlmpSendByMacIpAddr(macAddr, ipAddr, port, dropNo, command, subCommand, dataSize, data, buffSize)",
        "C": "SdoDownload(slaveId, dropNo, index, subindex, sdoDataSize, sdoData)",
        "D": "SdoUpload(slaveId, dropNo, index, subindex, sdoDataSize, sdoData)",
        "Answer(s)": "C"
    },
    {
        "No": 762,
        "Instruction": "Upload data from the specified slave SDO in CCLINK.",
        "A": "PdoRead(slaveId, index, subindex, pdoBuffSize)",
        "B": "HaltAxis(slaveId, axisIndex)",
        "C": "SdoUploadData(slaveId, dropNo, indexNo, subindexNo, sdoBuffSize)",
        "D": "SdoUpload(slaveId, dropNo, index, subindex, sdoBuffSize)",
        "Answer(s)": "D"
    },
    {
        "No": 763,
        "Instruction": "Download data to the specified slave SDO in CCLINK.",
        "A": "SdoDownload_SdoType(slaveId, dropNo, index, subindex, sdoType, sdoDataSize, sdoData)",
        "B": "SdoUpload_SdoType(slaveId, dropNo, index, subindex, sdoType, sdoBuffSize)",
        "C": "SdoDownload_SdoType(slaveId, dropNo, index, subindex, objectType, dataSize, data)",
        "D": "StartHotconnect()",
        "Answer(s)": "A"
    },
    {
        "No": 764,
        "Instruction": "Upload data from the specified slave SDO in CCLINK.",
        "A": "StartAxisPP(slaveId, axisIndex, targetPos, profileVel, profileAcc, profileDec)",
        "B": "SdoUpload(sdoType, slaveId, dropNo, index, subindex, sdoBuffSize)",
        "C": "SdoUpload_SdoType(slaveId, dropNo, index, subindex, sdoType, sdoBuffSize)",
        "D": "SdoUpload(slaveId, dropNo, index, subindex, sdoBuffSize)",
        "Answer(s)": "C"
    },
    {
        "No": 765,
        "Instruction": "Set the axis operation mode for a specified slave axis in CCLINK.",
        "A": "HaltAxisRelease(slaveId, axisIndex)",
        "B": "StartAxisHM(slaveId, axisIndex, method, switchSpeed, zeroSpeed, hmAcc)",
        "C": "SetAxisConfiguration(slaveId, axisIndex, configuration)",
        "D": "SetAxisMode(slaveId, axisIndex, mode)",
        "Answer(s)": "D"
    },
    {
        "No": 766,
        "Instruction": "Start the PP operation for a specified slave axis in CCLINK.",
        "A": "StartAxisPP(slaveId, axisIndex, targetPos, profileVel, profileAcc, profileDec)",
        "B": "StartAxisHM(slaveId, axisIndex, method, switchSpeed, zeroSpeed, hmAcc)",
        "C": "StartHotconnect()",
        "D": "StopAxisPP(slaveId, axisIndex, targetPos, profileVel, profileAcc, profileDec)",
        "Answer(s)": "A"
    },
    {
        "No": 767,
        "Instruction": "Start the HM operation for a specified slave axis in CCLINK.",
        "A": "SetAxisMode(slaveId, axisIndex, mode)",
        "B": "SdoDownload(slaveId, dropNo, index, subindex, sdoDataSize, sdoData)",
        "C": "InitiateAxisMovement(slaveId, axisIndex, moveType, maxVelocity, minVelocity, acceleration)",
        "D": "StartAxisHM(slaveId, axisIndex, method, switchSpeed, zeroSpeed, hmAcc)",
        "Answer(s)": "D"
    },
    {
        "No": 768,
        "Instruction": "Halt the specified slave axis in CCLINK.",
        "A": "StopAxis(slaveId, axisIndex)",
        "B": "HaltAxis(slaveId, axisIndex)",
        "C": "HaltAxisRelease(slaveId, axisIndex)",
        "D": "ResetSyncStatisticsInfo()",
        "Answer(s)": "B"
    },
    {
        "No": 769,
        "Instruction": "Release the halt state for a specified slave axis in CCLINK.",
        "A": "HaltAxisReleaseCommand(slaveId, axisIndex)",
        "B": "HaltAxisRelease(slaveId, axisIndex)",
        "C": "StartAxisHM(slaveId, axisIndex, method, switchSpeed, zeroSpeed, hmAcc)",
        "D": "SetAxisMode(slaveId, axisIndex, mode)",
        "Answer(s)": "B"
    }
]