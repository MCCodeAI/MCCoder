# Write python code to Initialize WMX3, do {user_logic}, and close WMX3.
# This python code is to initialized WMX3(includes CreateDevice, SetDeviceName, StartCommunication, ImportAndSetAll, ClearAmpAlarm, SetServoOn, StartHome), and do {user_logic}, and close WMX3(includes SetServoOn, StopCommunication and CloseDevice). 
#WMX3 python library
# Axes = []

from WMX3ApiPython import *
from time import *

INFINITE = int(0xFFFFFFFF)

def main():
    Wmx3Lib = WMX3Api()
    CmStatus = CoreMotionStatus()
    Wmx3Lib_cm = CoreMotion(Wmx3Lib)
    print('Program begin.')
    sleep(0.1)

    # Create devices. 
    ret = Wmx3Lib.CreateDevice('C:\\Program Files\\SoftServo\\WMX3', DeviceType.DeviceTypeNormal, INFINITE)
    if ret!=0:
        print('CreateDevice error code is ' + str(ret) + ': ' + Wmx3Lib.ErrorToString(ret))
        return
    
    # Set Device Name.
    Wmx3Lib.SetDeviceName('WMX3initTest')

    # Start Communication.
    ret = Wmx3Lib.StartCommunication(INFINITE)
    if ret!=0:
        print('StartCommunication error code is ' + str(ret) + ': ' + Wmx3Lib.ErrorToString(ret))
        return

    # Import and set all the preset motion parameters.
    ret=Wmx3Lib_cm.config.ImportAndSetAll("C:\\Program Files\\SoftServo\\WMX3\\wmx_parameters.xml")
    if ret != 0:
        print('ImportAndSetAll Parameters error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
    sleep(0.5)
 
    # Clear alarms, set servos on, and perform homing for Axes
    for axis in []:
        # Clear the amplifier alarm
        timeoutCounter = 0
        while True:
            # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
            ret, CmStatus = Wmx3Lib_cm.GetStatus()
            if not CmStatus.GetAxesStatus(axis).ampAlarm:
                break
            ret = Wmx3Lib_cm.axisControl.ClearAmpAlarm(axis)
            sleep(0.5)
            timeoutCounter += 1
            if timeoutCounter > 5:
                break
        if timeoutCounter > 5:
            print(f'Clear axis {axis} alarm fails!')
            return

        # Set servo on for Axis
        ret = Wmx3Lib_cm.axisControl.SetServoOn(axis, 1)
        timeoutCounter = 0
        while True:
            # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
            ret, CmStatus = Wmx3Lib_cm.GetStatus()
            if (CmStatus.GetAxesStatus(axis).servoOn):
                break
            sleep(0.4)
            timeoutCounter += 1
            if (timeoutCounter > 5):
                break
        if (timeoutCounter > 5):
            print('Set servo on for axis {axis} fails!')
            return

        # Sleep is a must between SetServoOn and Homing
        sleep(0.1)

        # Homing
        homeParam = Config_HomeParam()
        ret, homeParam = Wmx3Lib_cm.config.GetHomeParam(axis)
        homeParam.homeType = Config_HomeType.CurrentPos

        # SetHomeParam -> First return value: Error code, Second return value: param error
        ret, homeParamError = Wmx3Lib_cm.config.SetHomeParam(axis, homeParam)

        ret = Wmx3Lib_cm.home.StartHome(axis)
        if ret != 0:
            print(f'StartHome error code for axis {axis} is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
            return
        Wmx3Lib_cm.motion.Wait(axis)


    # {user_logic}


    # Set servo off for Axes
    for axis in []:
        ret = Wmx3Lib_cm.axisControl.SetServoOn(axis, 0)
        if ret != 0:
            print(f'SetServoOn to off error code for axis {axis} is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
            return

    # Stop Communication.
    ret = Wmx3Lib.StopCommunication(INFINITE)
    if ret!=0:
        print('StopCommunication error code is ' + str(ret) + ': ' + Wmx3Lib.ErrorToString(ret))
        return

    # Close Device.
    ret = Wmx3Lib.CloseDevice()
    if ret!=0:
        print('CloseDevice error code is ' + str(ret) + ': ' + Wmx3Lib.ErrorToString(ret))
        return

    print('Program End.')

if __name__ == '__main__':
    main()



#``



# Write python code to start an absolute position command of Axis 0 to position 180 with 1000 velocity.
# Move Axis 0 to 180 with velocity 1000.
    # Axes = [0]
    # Start an absolute position command of Axis 0 to position 180 with 1000 velocity.
    posCommand = Motion_PosCommand()
    posCommand.profile.type = ProfileType.Trapezoidal
    posCommand.axis = 0
    posCommand.target = 180
    posCommand.profile.velocity = 1000
    posCommand.profile.acc = 10000
    posCommand.profile.dec = 10000

    # Execute command to move from current position to specified absolute position.
    ret = Wmx3Lib_cm.motion.StartPos(posCommand)
    if ret!=0:
        print('StartPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until the axis moves to the target position and stops.
    Wmx3Lib_cm.motion.Wait(0)



#``



# Write python code to Start a relative position command of Axis 1 with 200 distance and 2000 velocity.
# Move Axis 1 with 200 distance with velocity 2000.
    # Axes = [1]

    # Start a relative position command of Axis 1 with 200 distance and 2000 velocity.
    # Create a command value of target as 200.
    posCommand = Motion_PosCommand()
    posCommand.profile.type = ProfileType.Trapezoidal
    posCommand.axis = 1
    posCommand.target = 200
    posCommand.profile.velocity = 2000
    posCommand.profile.acc = 10000
    posCommand.profile.dec = 10000

    # Execute command to move from current position to a specified distance relatively. e.g. 'Move 100..'
    ret = Wmx3Lib_cm.motion.StartMov(posCommand)
    if ret!=0:
        print('StartMov error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until the axis moves to the target position and stops.
    Wmx3Lib_cm.motion.Wait(1)


#``



# Write python code to Jog Axis 2 for 1.5s with 160 velocity, then start an absolute position command to position 10 with 1000 velocity.
# Jog Axis 2 for 1.5s with 160 velocity, then move to 10 with velocity 1000.
    # Axes = [2]

    jogCommand = Motion_JogCommand()
    jogCommand.profile.type = ProfileType.Trapezoidal
    jogCommand.axis = 2
    jogCommand.profile.velocity = 160
    jogCommand.profile.acc = 10000
    jogCommand.profile.dec = 10000

    # Rotate the motor at the specified speed.
    ret =Wmx3Lib_cm.motion.StartJog(jogCommand)
    if ret!=0:
        print('StartJog error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    #Jogging for 1.5 seconds
    sleep(1.5)
    
    Wmx3Lib_cm.motion.Stop(2)

    Wmx3Lib_cm.motion.Wait(2)
    
    # Create a command value of target as 10.
    posCommand = Motion_PosCommand()
    posCommand.profile.type = ProfileType.Trapezoidal
    posCommand.axis = 2
    posCommand.target = 10
    posCommand.profile.velocity = 1000
    posCommand.profile.acc = 10000
    posCommand.profile.dec = 10000

    # Execute command to move from current position to specified absolute position.
    ret = Wmx3Lib_cm.motion.StartPos(posCommand)
    if ret!=0:
        print('StartPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until the axis moves to the target position and stops.
    Wmx3Lib_cm.motion.Wait(2)



#``



# Write python code to Start an absolute position command of Axis 0 to position 180 with 1000 velocity, and then start a relative position command of Axis 0 with 200 distance and 2000 velocity.
# Move Axis 0 to position 180 with 1000 velocity, and then move Axis 0 with with 200 distance and 2000 velocity.
    # Axes = [0]
    # Create a command value of target as 180.
    posCommand = Motion_PosCommand()
    posCommand.profile.type = ProfileType.Trapezoidal
    posCommand.axis = 0
    posCommand.target = 180
    posCommand.profile.velocity = 1000
    posCommand.profile.acc = 10000
    posCommand.profile.dec = 10000

    # Execute command to move from current position to specified absolute position.
    ret = Wmx3Lib_cm.motion.StartPos(posCommand)
    if ret!=0:
        print('StartPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until the axis moves to the target position and stops.
    Wmx3Lib_cm.motion.Wait(0)

    # Create a command value of target as 200.
    posCommand = Motion_PosCommand()
    posCommand.profile.type = ProfileType.Trapezoidal
    posCommand.axis = 0
    posCommand.target = 200
    posCommand.profile.velocity = 2000
    posCommand.profile.acc = 10000
    posCommand.profile.dec = 10000

    # Execute command to move from current position to a specified distance relatively. e.g. 'Move 100..'
    ret = Wmx3Lib_cm.motion.StartMov(posCommand)
    if ret!=0:
        print('StartMov error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until the axis moves to the target position and stops.
    Wmx3Lib_cm.motion.Wait(0)


#``



# Write python code to Start an absolute position path interpolation motion command of Axis 0 and 1 with velocity 1000. The 1st segment is a linear interpolation to position (-200, -200), the 2nd segment is a counterclockwise circular interpolation to position (-150, -200) with center point (0, 0), the 3rd segment is a linear interpolation to position (-180, -10), and the 4th segment is a clockwise circular interpolation to position (-10, -150) with center point (0, 0).
    # Axes = [0, 1]

    adv = AdvancedMotion(Wmx3Lib)
    path = AdvMotion_PathIntplCommand()

    path.SetAxis(0, 0)
    path.SetAxis(1, 1)

    path.enableConstProfile = 1

    path.profile = Profile()
    path.profile.type = ProfileType.Trapezoidal
    path.profile.velocity = 1000
    path.profile.acc = 10000
    path.profile.dec = 10000

    path.numPoints = 4

    path.SetType(0, AdvMotion_PathIntplSegmentType.Linear)

    path.SetTarget(0, 0, -200)
    path.SetTarget(1, 0, -200)

    path.SetType(1, AdvMotion_PathIntplSegmentType.Circular)
    path.SetTarget(0, 1, -150)
    path.SetTarget(1, 1, -200)
    path.SetCenterPos(0, 1, 0)
    path.SetCenterPos(1, 1, 0)
    path.SetDirection(1, 1)

    path.SetType(2, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 2, -180)
    path.SetTarget(1, 2, -10)

    path.SetType(3, AdvMotion_PathIntplSegmentType.Circular)
    path.SetTarget(0, 3, -10)
    path.SetTarget(1, 3, -150)
    path.SetCenterPos(0, 3, 0)
    path.SetCenterPos(1, 3, 0)
    path.SetDirection(3, 1)

    ret = adv.advMotion.StartPathIntplPos(path)
    if ret!=0:
            print('StartPathIntplPos error code is ' + str(ret) + ': ' + adv.ErrorToString(ret))
            return

    # Wait for the motion to complete. Start a blocking wait command, returning only when Axis 0 and Axis 1 become idle.
    axisSel = AxisSelection()
    axisSel.axisCount = 2
    axisSel.SetAxis(0, 0)
    axisSel.SetAxis(1, 1)
    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axisSel)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return


#``



# Write python code to Set output bit 0.2 to be 1, sleep for 0.15 seconds, and then set it to be 0.
    # Axes = []

    # Set output bit 0.2 to be 1, 
    Wmx3Lib_Io = Io(Wmx3Lib)
    ret = Wmx3Lib_Io.SetOutBit(0x0, 0x02, 0x01)
    if ret!=0:
        print('SetOutBit error code is ' + str(ret) + ': ' + Wmx3Lib_Io.ErrorToString(ret))
        return
    
    sleep(0.15)

    # Set output bit 0.2 to be 0.
    ret = Wmx3Lib_Io.SetOutBit(0x0, 0x02, 0x00)
    if ret!=0:
        print('SetOutBit error code is ' + str(ret) + ': ' + Wmx3Lib_Io.ErrorToString(ret))
        return


#``



# Write python code to Start an absolute position linear interpolation motion command of Axis 0 and 1 to position (300, 100) with 1000 velocity.
    # Axes = [0, 1]

    # Create a command value of target as (300, 100).
    lin = Motion_LinearIntplCommand()
    lin.axisCount = 2 
    lin.SetAxis(0,0)
    lin.SetAxis(1,1) 

    lin.profile.type = ProfileType.Trapezoidal
    lin.profile.velocity = 1000
    lin.profile.acc = 10000
    lin.profile.dec = 10000

    lin.SetTarget(0,300)  #Set target of Axis 0 to be 300
    lin.SetTarget(1,100)  #Set target of Axis 1 to be 100

    # Start an absolute position linear interpolation motion command.
    ret =Wmx3Lib_cm.motion.StartLinearIntplPos(lin)
    if ret!=0:
            print('StartLinearIntplPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
            return
    
    # Wait for the motion to complete. Start a blocking wait command, returning only when Axis 0 and Axis 1 become idle.
    axisSel = AxisSelection()
    axisSel.axisCount = 2
    axisSel.SetAxis(0, 0)
    axisSel.SetAxis(1, 1)
    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axisSel)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    


#``



# Write python code to Start a relative position linear interpolation motion command of Axis 0 and 1 with  (200, -150) distance with 1000 velocity.
    # Axes = [0, 1]
    
    # Create a command value of relative distance of (200, -150).
    lin = Motion_LinearIntplCommand()
    lin.axisCount = 2 
    lin.SetAxis(0,0)
    lin.SetAxis(1,1) 

    lin.profile.type = ProfileType.Trapezoidal
    lin.profile.velocity = 1000
    lin.profile.acc = 10000
    lin.profile.dec = 10000

    lin.SetTarget(0,200)  #Set target of Axis 0 to be 300
    lin.SetTarget(1,-150)  #Set target of Axis 1 to be 100

    # Start an relative position linear interpolation motion command.
    ret =Wmx3Lib_cm.motion.StartLinearIntplMov(lin)
    if ret!=0:
            print('StartLinearIntplMov error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
            return
    
    # Wait for the motion to complete. Start a blocking wait command, returning only when Axis 0 and Axis 1 become idle.
    axisSel = AxisSelection()
    axisSel.axisCount = 2
    axisSel.SetAxis(0, 0)
    axisSel.SetAxis(1, 1)
    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axisSel)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    


#``



# Write python code to Start an absolute position linear interpolation motion command of Axis 0 and 1 to position (300, 100) with 1000 velocity, and then start a relative position linear interpolation motion command of Axis 0 and 1 with  (200, -150) distance with 1000 velocity.
    # Axes = [0, 1]

    # Create a command value of relative distance
    lin = Motion_LinearIntplCommand()
    lin.axisCount = 2 
    lin.SetAxis(0,0)
    lin.SetAxis(1,1) 

    lin.profile.type = ProfileType.Trapezoidal
    lin.profile.velocity = 1000
    lin.profile.acc = 10000
    lin.profile.dec = 10000

    lin.SetTarget(0,300)  #Set target of Axis 0 to be 300
    lin.SetTarget(1,100)  #Set target of Axis 1 to be 100

    # Start an absolute position linear interpolation motion command.
    ret =Wmx3Lib_cm.motion.StartLinearIntplPos(lin)
    if ret!=0:
            print('StartLinearIntplPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
            return
    Wmx3Lib_cm.motion.Wait(0) #need to wait the Axis 0 to be idle

    lin.SetTarget(0,200)  #Set target of Axis 0  
    lin.SetTarget(1,-150)  #Set target of Axis 1  

    # Start an relative position linear interpolation motion command.
    ret =Wmx3Lib_cm.motion.StartLinearIntplMov(lin)
    if ret!=0:
            print('StartLinearIntplMov error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
            return
    
    # Wait for the motion to complete. Start a blocking wait command, returning only when Axis 0 and Axis 1 become idle.
    axisSel = AxisSelection()
    axisSel.axisCount = 2
    axisSel.SetAxis(0, 0)
    axisSel.SetAxis(1, 1)
    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axisSel)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    


#``



# Write python code to Establish synchronous control between master axis 0 and a slave axis 1, then move Axis 0 to position 188 with velocity 1200.
    # Axes = [0, 1]

    # Establish the synchronization between Axis 0 and Axis 1, with Axis 0 designated as the master axis and Axis 1 as the slave axis.
    ret = Wmx3Lib_cm.sync.SetSyncMasterSlave(0, 1)
    if ret != 0:
        print('SetSyncMasterSlave error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Create a command with target position 1,000,000 and velocity 100,000.
    posCommand = Motion_PosCommand()
    posCommand.profile.type = ProfileType.Trapezoidal
    posCommand.axis = 0
    posCommand.target = 188
    posCommand.profile.velocity = 1200
    posCommand.profile.acc = 10000
    posCommand.profile.dec = 10000

    # Execute the command to move the master axis from its current position to a specified absolute position, with the slave axis moving in synchronization.
    ret = Wmx3Lib_cm.motion.StartPos(posCommand)
    if ret != 0:
        print('StartMov error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait for the positioning motion to complete. Start a blocking wait command, returning only when Axis 0 becomes idle.
    ret = Wmx3Lib_cm.motion.Wait(0)
    if ret != 0:
        print('Wait error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Release the synchronization between Axis 0 and Axis 1.
    ret = Wmx3Lib_cm.sync.ResolveSync(1)
    if ret != 0:
        print('ResolveSync error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return



#``



# Write python code to Start a cubic spline motion command of Axis 2 and 3 with the total time of 1000ms to complete, the 1st point to 9th point are (0,0),(10,0),(50,50),(100,100),(100,150),(0,150),(0,100),(50,50),(7,8).
    # Axes = [2, 3]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    # Allocate buffer memory for a spline execution channel with 100 points for Channel 0.
    ret = Wmx3Lib_adv.advMotion.CreateSplineBuffer(0, 100)
    if ret != 0:
        print('CreateSplineBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Set the spline command options, specifying Axis 0 and Axis 1, with a total time of 1,000 milliseconds to complete the spline motion.
    splineCommand = AdvMotion_TotalTimeSplineCommand()
    splineCommand.dimensionCount = 2
    splineCommand.SetAxis(0, 2)
    splineCommand.SetAxis(1, 3)
    splineCommand.totalTimeMilliseconds = 1000

    # Set the spline point data with 9 points.
    splinePoint = []

    ret, CmStatus = Wmx3Lib_cm.GetStatus()

    splinePoint.append(AdvMotion_SplinePoint())
    splinePoint[0].SetPos(0, 0)
    splinePoint[0].SetPos(1, 0)

    splinePoint.append(AdvMotion_SplinePoint())
    splinePoint[1].SetPos(0, 10)
    splinePoint[1].SetPos(1, 0)

    splinePoint.append(AdvMotion_SplinePoint())
    splinePoint[2].SetPos(0, 50)
    splinePoint[2].SetPos(1, 50)

    splinePoint.append(AdvMotion_SplinePoint())
    splinePoint[3].SetPos(0, 100)
    splinePoint[3].SetPos(1, 100)

    splinePoint.append(AdvMotion_SplinePoint())
    splinePoint[4].SetPos(0, 100)
    splinePoint[4].SetPos(1, 150)

    splinePoint.append(AdvMotion_SplinePoint())
    splinePoint[5].SetPos(0, 0)
    splinePoint[5].SetPos(1, 150)

    splinePoint.append(AdvMotion_SplinePoint())
    splinePoint[6].SetPos(0, 0)
    splinePoint[6].SetPos(1, 100)

    splinePoint.append(AdvMotion_SplinePoint())
    splinePoint[7].SetPos(0, 50)
    splinePoint[7].SetPos(1, 50)

    splinePoint.append(AdvMotion_SplinePoint())
    splinePoint[8].SetPos(0, 7)
    splinePoint[8].SetPos(1, 8)

    # Execute the spline command.
    ret = Wmx3Lib_adv.advMotion.StartCSplinePos_TotalTime(0, splineCommand, 9, splinePoint)
    if ret != 0:
        print('StartCSplinePos_TotalTime error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the spline motion to complete. Start a blocking wait command, returning only when Axis 0 and Axis 1 become idle.
    axisSel = AxisSelection()
    axisSel.axisCount = 2
    axisSel.SetAxis(0, 2)
    axisSel.SetAxis(1, 3)
    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axisSel)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Free buffer memory for the spline execution channel. (Normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreeSplineBuffer(0)
    if ret != 0:
        print('FreeSplineBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return



#``



# Write python code to Create and execute a cyclic buffer memory space for Axis 4, to pisition 100 within 200 cycles, then move a relative 0 distance within 600 cycles, then to pisition -100 within 200 cycles, then sleep 1.5s, and close the cyclic buffer.
    # Axes = [4]

    Wmx3Lib_cyc = CyclicBuffer(Wmx3Lib)

    # Create a new cyclic buffer memory space for Axis 4, with a size of 1,024 cycles.
    ret = Wmx3Lib_cyc.OpenCyclicBuffer(4, 1024)
    if ret != 0:
        print('OpenCyclicBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_cyc.ErrorToString(ret))
        return

    # Start the execution of the cyclic position command buffer for Axis 4.
    ret = Wmx3Lib_cyc.Execute(4)
    if ret != 0:
        print('Execute error code is ' + str(ret) + ': ' + Wmx3Lib_cyc.ErrorToString(ret))
        return

    # Dynamically add points to move from the current position to the absolute position of 100 within 200 cycles.
    cyclicBufferSingleAxisCommand = CyclicBufferSingleAxisCommand()
    cyclicBufferSingleAxisCommand.type = CyclicBufferCommandType.AbsolutePos
    cyclicBufferSingleAxisCommand.intervalCycles = 200
    cyclicBufferSingleAxisCommand.command = 100
    ret = Wmx3Lib_cyc.AddCommand(4, cyclicBufferSingleAxisCommand)
    if ret != 0:
        print('AddCommand error code is ' + str(ret) + ': ' + Wmx3Lib_cyc.ErrorToString(ret))
        return

    # The relative position is 0, which means there was no movement for 600 cycles from the previous position.
    cyclicBufferSingleAxisCommand.type = CyclicBufferCommandType.RelativePos
    cyclicBufferSingleAxisCommand.intervalCycles = 600
    cyclicBufferSingleAxisCommand.command = 0
    ret = Wmx3Lib_cyc.AddCommand(4, cyclicBufferSingleAxisCommand)
    if ret != 0:
        print('AddCommand error code is ' + str(ret) + ': ' + Wmx3Lib_cyc.ErrorToString(ret))
        return

    # Move from the current position to the absolute position of -100 within 200 cycles.
    cyclicBufferSingleAxisCommand.type = CyclicBufferCommandType.AbsolutePos
    cyclicBufferSingleAxisCommand.intervalCycles = 200
    cyclicBufferSingleAxisCommand.command = -100
    ret = Wmx3Lib_cyc.AddCommand(4, cyclicBufferSingleAxisCommand)
    if ret != 0:
        print('AddCommand error code is ' + str(ret) + ': ' + Wmx3Lib_cyc.ErrorToString(ret))
        return

    # Wait for 1.5 seconds until the motion ends.
    sleep(1.5)

    # Close the cyclic buffer memory space.
    ret = Wmx3Lib_cyc.CloseCyclicBuffer(4)
    if ret != 0:
        print('CloseCyclicBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_cyc.ErrorToString(ret))
        return



#``



# Write python code to Start the motion for a path interpolation with look ahead channel 0 for Axis 0 and 1, with velocity 500, the 1st to 4th points are (100, 0) with smoothRadius as 12.5, (100, 100) with smoothRadius as 25,(0, 100) with smoothRadius as 50, and(0, 0).
    # Axes = [0, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)

    sleep(0.1)

    # Allocate buffer memory for a path interpolation with look ahead channel with 1,000 points for Channel 0.
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplLookaheadBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Set the configuration for the path interpolation with lookahead channel, specifying Axis 0 and Axis 1, with composite velocity of 1,000, composite acceleration of 20,000, and sample distance of 100.
    conf = AdvMotion_PathIntplLookaheadConfiguration()
    conf.axisCount = 2
    conf.SetAxis(0, 0)
    conf.SetAxis(1, 1)
    conf.compositeVel = 500
    conf.compositeAcc = 10000
    conf.sampleDistance = 100
    conf.stopOnEmptyBuffer = True

    ret = Wmx3Lib_adv.advMotion.SetPathIntplLookaheadConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplLookaheadConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Add interpolation commands to the path interpolation with look ahead channel, with the main body being a square trajectory formed by four points, with a side length of 100. There are smooth radius of 12.5, 25, and 50 at the end of the first, second, and third segments, respectively.
    path = AdvMotion_PathIntplLookaheadCommand()
    path.numPoints = 4

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 100)
    point.linear.SetTarget(1, 0)
    point.linear.smoothRadius = 12.5
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 100)
    point.linear.SetTarget(1, 100)
    point.linear.smoothRadius = 25
    path.SetPoint(1, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 0)
    point.linear.SetTarget(1, 100)
    point.linear.smoothRadius = 50
    path.SetPoint(2, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 0)
    point.linear.SetTarget(1, 0)
    path.SetPoint(3, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplLookaheadCommand(0, path)
    if ret != 0:
        print('AddPathIntplLookaheadCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Start the motion for the path interpolation with look ahead channel.
    ret = Wmx3Lib_adv.advMotion.StartPathIntplLookahead(0)
    if ret != 0:
        print('StartPathIntplLookahead error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the motion to complete. Start a blocking wait command, returning only when Axis 0 and Axis 1 become idle.
    axisSel = AxisSelection()
    axisSel.axisCount = 2
    axisSel.SetAxis(0, 0)
    axisSel.SetAxis(1, 1)
    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axisSel)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Free buffer memory for a path interpolation with lookahead channel. 
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    if ret != 0:
        print('FreePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return




#``



# Write python code to Start a clockwise circular interpolation motion command of Axis 0 and 1 with center position (100, 200), arc length 360, and velocity 1000.
    # Axes = [0, 1]

    circularIntplCommand = Motion_CenterAndLengthCircularIntplCommand()

    # Execute Circular Interpolation of Axis 0 and 1 with center position (100, 200), arc length 360, velocity 1000.
    circularIntplCommand.SetAxis(0, 0)
    circularIntplCommand.SetAxis(1, 1)
    circularIntplCommand.SetCenterPos(0, 100)
    circularIntplCommand.SetCenterPos(1, 200)
    circularIntplCommand.clockwise = 1
    circularIntplCommand.arcLengthDegree = 360
    circularIntplCommand.profile.type = ProfileType.Trapezoidal
    circularIntplCommand.profile.velocity = 1000
    circularIntplCommand.profile.acc = 10000
    circularIntplCommand.profile.dec = 10000
    ret = Wmx3Lib_cm.motion.StartCircularIntplPos_CenterAndLength(circularIntplCommand)
    if ret != 0:
        print('StartCircularIntplPos_RadiusAndEnd error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait for the motion to complete. Start a blocking wait command, returning only when Axis 0 and Axis 1 become idle.
    axisSel = AxisSelection()
    axisSel.axisCount = 2
    axisSel.SetAxis(0, 0)
    axisSel.SetAxis(1, 1)
    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axisSel)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return



#``



# Write python code to Start a helical interpolation motion command of clockwise circular interpolation of Axis 4 and 5 with center position  (100, 120), rotation degree 720, and velocity 1060, while concurrently moving axis 8 as the linear axis to position 140.
    # Axes = [4, 5, 8]

    helicalCommand = Motion_HelicalIntplCommand()

    # Execute Helical Motion
    helicalCommand.SetAxis(0, 4)
    helicalCommand.SetAxis(1, 5)
    helicalCommand.zAxis = 8
    helicalCommand.SetCenterPos(0, 100)
    helicalCommand.SetCenterPos(1, 120)
    helicalCommand.zEndPos = 140
    helicalCommand.clockwise = 1
    helicalCommand.arcLengthDegree = 720
    helicalCommand.profile.type = ProfileType.Trapezoidal
    helicalCommand.profile.velocity = 1060
    helicalCommand.profile.acc = 10000
    helicalCommand.profile.dec = 10000
    ret = Wmx3Lib_cm.motion.StartHelicalIntplPos(helicalCommand)
    if ret != 0:
        print('StartHelicalIntplPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait for the motion to complete. Start a blocking wait command, returning only when Axis 4, 5 and 8 become idle.
    axisSel = AxisSelection()
    axisSel.axisCount = 3
    axisSel.SetAxis(0, 4)
    axisSel.SetAxis(1, 5)
    axisSel.SetAxis(2, 8)
    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axisSel)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
        

#``



# Write python code to Start a relative triggered position command of Axis 1 with 180 distance and velocity of 1000, and the triggered condition is the remaining distance for Axis 0 to the target position is 30 while it moves a relative 100 distance.
    # Axes = [0, 1]

    posCommand = Motion_PosCommand()
    tgrPosCommand = Motion_TriggerPosCommand()
    trigger = Trigger()

    # Move the motor to the specified position.
    posCommand.profile.type = ProfileType.Trapezoidal
    posCommand.axis = 0
    posCommand.target = 100
    posCommand.profile.velocity = 1000
    posCommand.profile.acc = 10000
    posCommand.profile.dec = 10000
    ret = Wmx3Lib_cm.motion.StartMov(posCommand)
    if ret != 0:
        print('StartMov error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Set trigger PosCommand.
    tgrPosCommand.profile.type = ProfileType.Trapezoidal
    tgrPosCommand.axis = 1
    tgrPosCommand.target = 180
    tgrPosCommand.profile.velocity = 1000
    tgrPosCommand.profile.acc = 10000
    tgrPosCommand.profile.dec = 10000

    # Create Trigger
    # Start when the remaining distance of 0 axis reaches 30 pulse.
    trigger.triggerAxis = 0
    trigger.triggerType = TriggerType.RemainingDistance
    trigger.triggerValue = 30
    tgrPosCommand.trigger = trigger
    ret = Wmx3Lib_cm.motion.StartMov_Trigger(tgrPosCommand)
    if ret != 0:
        print('StartMov_Trigger error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    Wmx3Lib_cm.motion.Wait(1)

    # Wait for the motion to complete. Start a blocking wait command, returning only when Axis 0 and Axis 1 become idle.
    axisSel = AxisSelection()
    axisSel.axisCount = 2
    axisSel.SetAxis(0, 0)
    axisSel.SetAxis(1, 1)
    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axisSel)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
        


#``



# Write python code to sleep 1.6s.
# Pause for 1.6 seconds
# Axes = []

    # Sleep 1.6s
    sleep(1.6)




#``



# Write python code to Record and execute an API buffer with two segments: Move Axis 0 to position 200 and Axis 1 to postion 100.
    # Axes = [0, 1]

    Wmx3Lib_buf = ApiBuffer(Wmx3Lib)
    #  Clear the buffer of the specified channel.
    Wmx3Lib_buf.Clear(0)
    # Create a buffer for the specified channel.
    Wmx3Lib_buf.CreateApiBuffer(0, 1024 * 1024 * 3)
    # Start recording for the specified channel.
    Wmx3Lib_buf.StartRecordBufferChannel(0)

    # Create a command value.
    posCommand = Motion_PosCommand()
    posCommand.profile.type = ProfileType.Trapezoidal
    posCommand.axis = 0
    posCommand.target = 200
    posCommand.profile.velocity = 1000
    posCommand.profile.acc = 10000
    posCommand.profile.dec = 10000

    # Execute command to move to a specified absolute position. 
    Wmx3Lib_cm.motion.StartPos(posCommand)

    Wmx3Lib_buf.Wait(0)

    posCommand.axis = 1
    posCommand.target = 100
    posCommand.profile.velocity = 1000
    posCommand.profile.acc = 10000
    posCommand.profile.dec = 10000

    # Execute command to move to a specified absolute position.
    Wmx3Lib_cm.motion.StartPos(posCommand)
    Wmx3Lib_buf.Wait(1)

    # End Recording.
    Wmx3Lib_buf.EndRecordBufferChannel()
    # Drive the motion accumulated in the buffer so far.
    Wmx3Lib_buf.Execute(0)

    # Wait for the motion to complete. Start a blocking wait command, returning only when Axis 0 and Axis 1 become idle.
    axisSel = AxisSelection()
    axisSel.axisCount = 2
    axisSel.SetAxis(0, 0)
    axisSel.SetAxis(1, 1)
    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axisSel)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Destroy API buffer resources.
    Wmx3Lib_buf.Halt(0)
    Wmx3Lib_buf.FreeApiBuffer(0)



#``



# Write python code to Set an event to trigger a relative position command of Axis 0 with 100 distance and 1000 velocity, when Output 1.0 = 1. Event id is 10.
    # Axes = [0]

    Wmx3Lib_EventCtl = EventControl(Wmx3Lib)
    eventIN_IO = IoEventInput()
    eventOut_Motion = CoreMotionEventOutput()
    # Event ID
    posEventID = 10
    # RemoveEvent
    Wmx3Lib_EventCtl.RemoveEvent(posEventID)

    eventIN_IO.type = IoEventInputType.IOBit
    eventIN_IO.ioBit.ioSourceType = IOSourceType.Output
    eventIN_IO.ioBit.bitAddress = 0
    eventIN_IO.ioBit.byteAddress = 1

    eventOut_Motion.type = CoreMotionEventOutputType.StartSingleMov
    eventOut_Motion.startSingleMov.axis = 0
    eventOut_Motion.startSingleMov.type = ProfileType.Trapezoidal
    eventOut_Motion.startSingleMov.target = 100
    eventOut_Motion.startSingleMov.velocity = 1000
    eventOut_Motion.startSingleMov.acc = 10000
    eventOut_Motion.startSingleMov.dec = 10000

    # Set input events, output events, and event addresses.
    ret,Event_ID = Wmx3Lib_EventCtl.SetEvent_ID(eventIN_IO, eventOut_Motion, posEventID)
    if ret != 0:
        print('SetEvent_ID error code is ' + str(ret))
        return
    # EnableEvent
    Wmx3Lib_EventCtl.EnableEvent(posEventID, 1)

    sleep(0.01)
    # Set Output 1.0 = 1 to trigger the motion
    Wmx3Lib_Io = Io(Wmx3Lib)
    ret = Wmx3Lib_Io.SetOutBit(0x01, 0x00, 0x01)
    if ret!=0:
        print('SetOutBit error code is ' + str(ret) + ': ' + Wmx3Lib_Io.ErrorToString(ret))
        return

    # Wait until the axis moves to the target position and stops.
    Wmx3Lib_cm.motion.Wait(0)




#``



# Write python code to Execute an absolute triggered position command.Start an absolute postion command of Axis 0 to position 124 with velocity 1000, when the remaining time is 0, triggers Axis 0 to move to the absolute position of 70 with velocity 2000.
    # Axes = [0]

    pos = Motion_PosCommand()
    trigPos = Motion_TriggerPosCommand()

    # Execute normal motion command
    pos.axis = 0
    pos.profile.type = ProfileType.Trapezoidal
    pos.profile.velocity = 1000
    pos.profile.acc = 10000
    pos.profile.dec = 10000
    pos.profile.endVelocity = 1000
    pos.target = 124

    ret = Wmx3Lib_cm.motion.StartPos(pos)
    if ret != 0:
        print('StartPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Execute trigger motion command
    trigPos.axis = 0
    trigPos.profile.type = ProfileType.Trapezoidal
    trigPos.profile.velocity = 2000
    trigPos.profile.acc = 10000
    trigPos.profile.dec = 10000
    trigPos.target = 70
    trigPos.trigger.triggerType = TriggerType.RemainingTime
    trigPos.trigger.triggerAxis = 0
    trigPos.trigger.triggerValue = 0

    ret = Wmx3Lib_cm.motion.StartPos_Trigger(trigPos)
    if ret != 0:
        print('StarttrigPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until the axis moves to the target position and stops.
    Wmx3Lib_cm.motion.Wait(0)



#``



# Write python code to Execute an absolute position linear interpolation motion command. Control Axis 0 and 1 to linearly interpolate to position (300, 100) at a velocity of 1000, with acceleration and deceleration of 10000. Set the maximum velocity of Axis 0 to 600.
    # Axes = [0, 1]

    lin = Motion_LinearIntplCommand()

    # Execute absolute position linear interpolation motion command
    lin.axisCount = 2
    lin.SetAxis(0, 0)
    lin.SetAxis(1, 1)

    lin.profile.type = ProfileType.Trapezoidal
    lin.profile.velocity = 1000
    lin.profile.acc = 10000
    lin.profile.dec = 10000

    lin.SetTarget(0, 300)
    lin.SetTarget(1, 100)

    lin.SetMaxVelocity(0, 600)

    ret = Wmx3Lib_cm.motion.StartLinearIntplPos(lin)
    if ret != 0:
        print('StartLinearIntplPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait for the motion to complete. Start a blocking wait command, returning only when Axis 0 and Axis 1 become idle.
    axisSel = AxisSelection()
    axisSel.axisCount = 2
    axisSel.SetAxis(0, 0)
    axisSel.SetAxis(1, 1)
    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axisSel)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return


#``



# Write python code to Execute an absolute position linear interpolation motion command. Control Axis 0 and Axis 1 to linearly interpolate to position (300, 100). Set the maximum velocity of Axis 0 to 600 and Axis 1 to 500, with a maximum acceleration and deceleration of Axis 0 to 4000 and Axis 1 to 3000.
    # Axes = [0, 1]

    lin = Motion_LinearIntplCommand()

    # Execute absolute position linear interpolation motion command
    lin.axisCount = 2
    lin.SetAxis(0, 0)
    lin.SetAxis(1, 1)

    lin.profile.type = ProfileType.Trapezoidal
    lin.profile.velocity = 1000
    lin.profile.acc = 10000
    lin.profile.dec = 10000

    lin.SetTarget(0, 300)
    lin.SetTarget(1, 100)

    lin.SetMaxVelocity(0, 600)
    lin.SetMaxVelocity(1, 500)

    lin.SetMaxAcc(0, 4000)
    lin.SetMaxAcc(1, 3000)

    lin.SetMaxDec(0, 4000)
    lin.SetMaxDec(1, 3000)

    ret = Wmx3Lib_cm.motion.StartLinearIntplPos(lin)
    if ret != 0:
        print('StartLinearIntplPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait for the motion to complete. Start a blocking wait command, returning only when Axis 0 and Axis 1 become idle.
    axisSel = AxisSelection()
    axisSel.axisCount = 2
    axisSel.SetAxis(0, 0)
    axisSel.SetAxis(1, 1)
    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axisSel)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return


#``



# Write python code to Execute an absolute position triggered linear interpolation motion command.Control Axis 0 and Axis 1 to linearly interpolate to (150, 30) at a velocity of 1000 with acceleration and deceleration of 10000. Wait for 1 millisecond, then execute the trigger linear interpolation motion command. When the completed distance reaches 100, move Axis 0 and Axis 1 to (-100, -10).
    # Axes = [0, 1]

    lin = Motion_LinearIntplCommand()
    trig = Trigger()

    # Execute normal motion command
    lin.axisCount = 2
    lin.SetAxis(0, 0)
    lin.SetAxis(1, 1)

    lin.profile.type = ProfileType.Trapezoidal
    lin.profile.velocity = 1000
    lin.profile.acc = 10000
    lin.profile.dec = 10000

    lin.SetTarget(0, 150)
    lin.SetTarget(1, 30)

    ret = Wmx3Lib_cm.motion.StartLinearIntplPos(lin)
    if ret != 0:
        print('StartLinearIntplPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    sleep(0.001)

    lin.SetTarget(0, -100)
    lin.SetTarget(1, -10)

    trig.triggerType = TriggerType.CompletedDistance
    trig.triggerValue = 100

    ret = Wmx3Lib_cm.motion.StartLinearIntplPos_Trigger(lin, trig)
    if ret != 0:
        print('StartLinearIntplPos_Trigger error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait for the motion to complete. Start a blocking wait command, returning only when Axis 0 and Axis 1 become idle.
    axisSel = AxisSelection()
    axisSel.axisCount = 2
    axisSel.SetAxis(0, 0)
    axisSel.SetAxis(1, 1)
    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axisSel)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    


#``



# Write python code to Execute an absolute position triggered linear interpolation motion command.Control Axis 0 and Axis 1 to linearly interpolate to (130, 60) at a velocity of 1000 with acceleration and deceleration of 10000. Wait for 1 millisecond, then execute the trigger linear interpolation motion command. When the remaining distance is 80, trigger Axis 0 and Axis 1 to (-70, -40).
    # Axes = [0, 1]

    lin = Motion_LinearIntplCommand()
    trig = Trigger()

    # Execute normal motion command
    lin.axisCount = 2
    lin.SetAxis(0, 0)
    lin.SetAxis(1, 1)

    lin.profile.type = ProfileType.Trapezoidal
    lin.profile.velocity = 1000
    lin.profile.acc = 10000
    lin.profile.dec = 10000

    lin.SetTarget(0, 130)
    lin.SetTarget(1, 60)

    ret = Wmx3Lib_cm.motion.StartLinearIntplPos(lin)
    if ret != 0:
        print('StartLinearIntplPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    sleep(0.001)

    lin.SetTarget(0, -70)
    lin.SetTarget(1, -40)

    trig.triggerAxis = 0
    trig.triggerType = TriggerType.RemainingDistance
    trig.triggerValue = 80

    ret = Wmx3Lib_cm.motion.StartLinearIntplPos_Trigger(lin, trig)
    if ret != 0:
        print('StartLinearIntplPos_Trigger error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return   

    # Wait for the motion to complete. Start a blocking wait command, returning only when Axis 0 and Axis 1 become idle.
    axisSel = AxisSelection()
    axisSel.axisCount = 2
    axisSel.SetAxis(0, 0)
    axisSel.SetAxis(1, 1)
    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axisSel)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    



#``



# Write python code to Execute an absolute position triggered circular interpolation motion command.Control Axis 0 and Axis 1 to perform a clockwise circular interpolation with a 50 radius to pisition (100, 0) at a velocity of 1000. Wait for 1 millisecond, then execute the trigger circular interpolation motion command. When the remaining distance of Axis 0 is 80, trigger Axis 0 and Axis 1 to perform a clockwise circular interpolation (200, 0).
    # Axes = [0, 1]

    cir = Motion_RadiusAndEndCircularIntplCommand()
    trig = Trigger()

    # Execute normal motion command
    cir.SetAxis(0, 0)
    cir.SetAxis(1, 1)

    cir.profile.type = ProfileType.Trapezoidal
    cir.profile.velocity = 1000
    cir.profile.acc = 10000
    cir.profile.dec = 10000

    cir.SetEndPos(0, 100)
    cir.SetEndPos(1, 0)

    cir.radius = 50
    cir.clockwise = 1

    ret = Wmx3Lib_cm.motion.StartCircularIntplPos_RadiusAndEnd(cir)
    if ret != 0:
        print('StartCircularIntplPos_RadiusAndEnd error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    sleep(0.001)

    cir.SetEndPos(0, 200)
    cir.SetEndPos(1, 0)

    trig.triggerAxis = 0
    trig.triggerType = TriggerType.RemainingDistance
    trig.triggerValue = 80

    ret = Wmx3Lib_cm.motion.StartCircularIntplPos_RadiusAndEnd_Trigger(cir, trig)
    if ret != 0:
        print('StartCircularIntplPos_RadiusAndEnd_Trigger error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait for the motion to complete. Start a blocking wait command, returning only when Axis 0 and Axis 1 become idle.
    axisSel = AxisSelection()
    axisSel.axisCount = 2
    axisSel.SetAxis(0, 0)
    axisSel.SetAxis(1, 1)
    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axisSel)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    


#``



# Write python code to Execute an absolute position triggered linear interpolation motion command.Control Axis 0 and Axis 1 to linearly interpolate to (100, 100) at a velocity of 1000 with acceleration and deceleration of 10000. Wait for 1 millisecond, then execute the trigger linear interpolation motion command. When the remaining distance is 30, trigger Axis 0 and Axis 1 to (200, 0). After previous interpolation completes, when the remaining distance is 30, trigger Axis 0 and Axis 1 to (200, 0).And using same trigger and condition to trigger Axis 0 and Axis 1 to (300, 100),(400, 0) and (500, 100).
    # Axes = [0, 1]

    lin = Motion_LinearIntplCommand()
    trig = Trigger()

    # Execute normal motion command
    lin.axisCount = 2
    lin.SetAxis(0, 0)
    lin.SetAxis(1, 1)

    lin.profile.type = ProfileType.Trapezoidal
    lin.profile.velocity = 1000
    lin.profile.acc = 10000
    lin.profile.dec = 10000

    lin.SetTarget(0, 100)
    lin.SetTarget(1, 100)

    ret = Wmx3Lib_cm.motion.StartLinearIntplPos(lin)
    if ret != 0:
        print('StartLinearIntplPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    sleep(0.001)

    lin.SetTarget(0, 200)
    lin.SetTarget(1, 0)

    trig.triggerAxis = 0
    trig.triggerType = TriggerType.RemainingDistance
    trig.triggerValue = 30

    ret = Wmx3Lib_cm.motion.StartLinearIntplPos_Trigger(lin, trig)
    if ret != 0:
        print('StartLinearIntplPos_Trigger error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until the first interpolation completes before setting trigger for third interpolation
    while True:
        # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
        ret, CmStatus = Wmx3Lib_cm.GetStatus()
        if (CmStatus.GetAxesStatus(0).commandReady == 1):
            break
        sleep(0.1)

    lin.SetTarget(0, 300)
    lin.SetTarget(1, 100)

    ret = Wmx3Lib_cm.motion.StartLinearIntplPos_Trigger(lin, trig)
    if ret != 0:
        print('StartLinearIntplPos_Trigger error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until the second interpolation completes before setting trigger for fourth interpolation
    while True:
        # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
        ret, CmStatus = Wmx3Lib_cm.GetStatus()
        if (CmStatus.GetAxesStatus(0).commandReady == 1):
            break
        sleep(0.1)

    lin.SetTarget(0, 400)
    lin.SetTarget(1, 0)

    ret = Wmx3Lib_cm.motion.StartLinearIntplPos_Trigger(lin, trig)
    if ret != 0:
        print('StartLinearIntplPos_Trigger error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until the third interpolation completes before setting trigger for fifth interpolation
    while True:
        # GetStatus -> First return value : Error code, Second return value: CoreMotionStatus
        ret, CmStatus = Wmx3Lib_cm.GetStatus()
        if (CmStatus.GetAxesStatus(0).commandReady == 1):
            break
        sleep(0.1)

    lin.SetTarget(0, 500)
    lin.SetTarget(1, 100)

    ret = Wmx3Lib_cm.motion.StartLinearIntplPos_Trigger(lin, trig)
    if ret != 0:
        print('StartLinearIntplPos_Trigger error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait for the motion to complete. Start a blocking wait command, returning only when Axis 0 and Axis 1 become idle.
    axisSel = AxisSelection()
    axisSel.axisCount = 2
    axisSel.SetAxis(0, 0)
    axisSel.SetAxis(1, 1)
    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axisSel)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    


#``



# Write python code to Execute a sequence of moving position command with blocking wait command.The moving distance of Axis 0 is 100, -100 and 100 with blocking wait.
    # Axes = [0]

    pos = Motion_PosCommand()

    # Set position command parameters
    pos.axis = 0
    pos.profile.type = ProfileType.Trapezoidal
    pos.profile.velocity = 1000
    pos.profile.acc = 10000
    pos.profile.dec = 10000

    # Execute motion to move axis forward 100
    pos.target = 100

    ret = Wmx3Lib_cm.motion.StartMov(pos)
    if ret != 0:
        print('StartMov error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until motion is finishedmoving 
    ret = Wmx3Lib_cm.motion.Wait(0)
    if ret != 0:
        print('Wait error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Execute motion to move axis backward 100
    pos.target = -100
    ret = Wmx3Lib_cm.motion.StartMov(pos)
    if ret != 0:
        print('StartMov error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until motion is finished
    ret = Wmx3Lib_cm.motion.Wait(0)
    if ret != 0:
        print('Wait error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Execute motion to move axis forward 100
    pos.target = 100
    ret = Wmx3Lib_cm.motion.StartMov(pos)
    if ret != 0:
        print('StartMov error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until motion is finished
    ret = Wmx3Lib_cm.motion.Wait(0)
    if ret != 0:
        print('Wait error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    
    

#``



# Write python code to Execute a sequence of motion commands using trigger motion functions and Wait functions.Move Axis 0 as 100 distance with 1000 velocity, and trigger it to move as -100 distance when the remaining time is 0, and then move as 200 distance, and -200 distance after waiting it to be overridable.
    # Axes = [0]

    pos = Motion_PosCommand()
    tpos = Motion_TriggerPosCommand()
    wait = Motion_WaitCondition()

    # Set position command parameters
    pos.axis = 0
    pos.profile.type = ProfileType.Trapezoidal;
    pos.profile.velocity = 1000
    pos.profile.acc = 10000
    pos.profile.dec = 10000

    # Set triggered position command parameters
    tpos.axis = 0
    tpos.profile.type = ProfileType.Trapezoidal
    tpos.profile.velocity = 1000
    tpos.profile.acc = 10000
    tpos.profile.dec = 10000
    tpos.trigger.triggerAxis = 0
    tpos.trigger.triggerType = TriggerType.RemainingTime
    tpos.trigger.triggerValue = 0

    # Set wait condition parameters, waiting Axis 0 to be overridable.
    wait.waitConditionType = Motion_WaitConditionType.MotionStartedOverrideReady
    wait.axisCount = 1
    wait.SetAxis(0, 0)

    # Execute motion to move axis forward 100
    pos.target = 100

    ret = Wmx3Lib_cm.motion.StartMov(pos)
    if ret != 0:
        print('StartMov error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Execute trigger motion to move axis backward 100 at the end of the previous motion
    tpos.target = -100

    ret = Wmx3Lib_cm.motion.StartMov_Trigger(tpos)
    if ret != 0:
        print('StartMov_Trigger error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until trigger motion executes
    ret = Wmx3Lib_cm.motion.Wait_WaitCondition(wait)
    if ret != 0:
        print('Wait_WaitCondition error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Execute trigger motion to move axis forward 200 at the end of the previous motion
    tpos.target = 200

    ret = Wmx3Lib_cm.motion.StartMov_Trigger(tpos)
    if ret != 0:
        print('StartMov_Trigger error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until trigger motion executes
    ret = Wmx3Lib_cm.motion.Wait_WaitCondition(wait)
    if ret != 0:
        print('Wait_WaitCondition error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Execute trigger motion to move axis backward 20000 at the end of the previous motion
    tpos.target = -200
    ret = Wmx3Lib_cm.motion.StartMov_Trigger(tpos)
    if ret != 0:
        print('StartMov_Trigger error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until motion is finished
    ret = Wmx3Lib_cm.motion.Wait(0)
    if ret != 0:
        print('Wait error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    


#``



# Write python code to Execute a sequence of motion commands using trigger motion functions and Wait functions. Move Axis 0 to position 180 with 20 velocity, and trigger the velocity override to 40, 60, 40, and 20 respectively when the completed time is 1s.
    # Axes = [0]

    pos = Motion_PosCommand()
    tpos = Motion_TriggerPosCommand()
    wait = Motion_WaitCondition()

    # Set position command parameters
    pos.axis = 0
    pos.profile.type = ProfileType.Trapezoidal
    pos.profile.acc = 1000
    pos.profile.dec = 1000
    pos.target = 180

    # Set triggered position command parameters
    tpos.axis = 0
    tpos.profile.type = ProfileType.Trapezoidal
    tpos.profile.acc = 1000
    tpos.profile.dec = 1000
    tpos.trigger.triggerAxis = 0
    tpos.trigger.triggerType = TriggerType.CompletedTime
    tpos.trigger.triggerValue = 1000
    tpos.target = 180

    # Set wait condition parameters
    wait.waitConditionType = Motion_WaitConditionType.MotionStartedOverrideReady
    wait.axisCount = 1
    wait.SetAxis(0, 0)

    # Execute motion to move axis forward 20
    pos.profile.velocity = 20

    ret = Wmx3Lib_cm.motion.StartPos(pos)
    if ret != 0:
        print('StartPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Execute trigger motion to change axis velocity
    tpos.profile.velocity = 40

    ret = Wmx3Lib_cm.motion.StartPos_Trigger(tpos)
    if ret != 0:
        print('StartPos_Trigger error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until trigger motion executes
    ret = Wmx3Lib_cm.motion.Wait_WaitCondition(wait)
    if ret != 0:
        print('Wait_WaitCondition error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Execute trigger motion to change axis velocity
    tpos.profile.velocity = 60

    ret = Wmx3Lib_cm.motion.StartPos_Trigger(tpos)
    if ret != 0:
        print('StartPos_Trigger error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until trigger motion executes
    ret = Wmx3Lib_cm.motion.Wait_WaitCondition(wait)
    if ret != 0:
        print('Wait_WaitCondition error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Execute trigger motion to change axis velocity
    tpos.profile.velocity = 40

    ret = Wmx3Lib_cm.motion.StartPos_Trigger(tpos)
    if ret != 0:
        print('StartPos_Trigger error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until trigger motion executes
    ret = Wmx3Lib_cm.motion.Wait_WaitCondition(wait)
    if ret != 0:
        print('Wait_WaitCondition error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Execute trigger motion to change axis velocity
    tpos.profile.velocity = 20
    ret = Wmx3Lib_cm.motion.StartPos_Trigger(tpos)
    if ret != 0:
        print('StartPos_Trigger error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until motion is finished
    ret = Wmx3Lib_cm.motion.Wait(0)
    if ret != 0:
        print('Wait error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    


#``



# Write python code to Execute a sequence of linear interpolation commands using trigger motion functions and Wait functions. Control Axis 0 and Axis 1 to linearly interpolate to (100, 0) at a velocity of 500，and then trigger Axis 0 and Axis 1 to linearly interpolate to (100, 100), (0, 100) and (0, 0) respectively when the remaining distance is 20.
    # Axes = [0, 1]

    lin = Motion_LinearIntplCommand()
    trig = Trigger()
    wait = Motion_WaitCondition()

    # Set interpolation command parameters
    lin.axisCount = 2
    lin.SetAxis(0, 0)
    lin.SetAxis(1, 1)

    lin.profile.type = ProfileType.Trapezoidal
    lin.profile.velocity = 500
    lin.profile.acc = 10000
    lin.profile.dec = 10000

    # Set trigger parameters (trigger at 2000 remaining distance)
    trig.triggerAxis = 0
    trig.triggerType = TriggerType.RemainingDistance
    trig.triggerValue = 20

    # Set wait condition parameters
    wait.waitConditionType = Motion_WaitConditionType.MotionStartedOverrideReady
    wait.axisCount = 1
    wait.SetAxis(0, 0)

    # Execute linear interpolation to position (100, 0)
    lin.SetTarget(0, 100)
    lin.SetTarget(1, 0)

    ret = Wmx3Lib_cm.motion.StartLinearIntplPos(lin)
    if ret != 0:
        print('StartLinearIntplPos error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Execute trigger linear interpolation to position (100, 100)
    sleep(0.001)
    lin.SetTarget(0, 100)
    lin.SetTarget(1, 100)

    ret = Wmx3Lib_cm.motion.StartLinearIntplPos_Trigger(lin, trig)
    if ret != 0:
        print('StartLinearIntplPos_Trigger error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until trigger motion executes
    ret = Wmx3Lib_cm.motion.Wait_WaitCondition(wait)
    if ret != 0:
        print('Wait_WaitCondition error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Execute trigger linear interpolation to position (0, 100)
    lin.SetTarget(0, 0)
    lin.SetTarget(1, 100)

    ret = Wmx3Lib_cm.motion.StartLinearIntplPos_Trigger(lin, trig)
    if ret != 0:
        print('StartLinearIntplPos_Trigger error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until trigger motion executes
    ret = Wmx3Lib_cm.motion.Wait_WaitCondition(wait)
    if ret != 0:
        print('Wait_WaitCondition error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Execute trigger linear interpolation to position (0, 0)
    lin.SetTarget(0, 0)
    lin.SetTarget(1, 0)

    ret = Wmx3Lib_cm.motion.StartLinearIntplPos_Trigger(lin, trig)
    if ret != 0:
        print('StartLinearIntplPos_Trigger error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait for the motion to complete. Start a blocking wait command, returning only when Axis 0 and Axis 1 become idle.
    axisSel = AxisSelection()
    axisSel.axisCount = 2
    axisSel.SetAxis(0, 0)
    axisSel.SetAxis(1, 1)
    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axisSel)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    


#``



# Write python code to Execute a simple PVT command of Axis 0 consisting of five points as a format of (Position, Velocity, Time): (0,0,0),(55,1000,100),(205,2000,200),(450,3000,300),(600,0,400)
    # Axes = [0]

    pvt = Motion_PVTCommand()
    pvtparameter = Motion_PVTPoint()

    pvt.axis = 0
    pvt.pointCount = 5

    # Define point data
    pvtparameter.pos = 0
    pvtparameter.velocity = 0
    pvtparameter.timeMilliseconds = 0
    pvt.SetPoints(0, pvtparameter)

    pvtparameter.pos = 55
    pvtparameter.velocity = 1000
    pvtparameter.timeMilliseconds = 100
    pvt.SetPoints(1, pvtparameter)

    pvtparameter.pos = 205
    pvtparameter.velocity = 2000
    pvtparameter.timeMilliseconds = 200
    pvt.SetPoints(2, pvtparameter)

    pvtparameter.pos = 450
    pvtparameter.velocity = 3000
    pvtparameter.timeMilliseconds = 300
    pvt.SetPoints(3, pvtparameter)

    pvtparameter.pos = 600
    pvtparameter.velocity = 0
    pvtparameter.timeMilliseconds = 400
    pvt.SetPoints(4, pvtparameter)

    # Start PVT motion
    ret = Wmx3Lib_cm.motion.StartPVT(pvt)
    if ret != 0:
        print('StartPVT error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until motion is finished
    ret = Wmx3Lib_cm.motion.Wait(0)
    if ret != 0:
        print('Wait error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    


#``



# Write python code to Execute a PVT interpolation command of Axis 0 and Axis 1 of 4 points as a format of (Position0, Velocity0, Time0, Position1, Velocity1, Time1): (0,0,0,0,0,0),(50,1000,100,100,2000,100),(100,2000,200,250,1000,200),(200,0,300,300,0,300)
    # Axes = [0, 1]

    pvti = Motion_PVTIntplCommand()

    pvtparameter0 = Motion_PVTPoint()
    pvtparameter1 = Motion_PVTPoint()

    pvti.axisCount = 2
    pvti.SetAxis(0, 0)
    pvti.SetAxis(1, 1)
    pvti.SetPointCount(0, 4)
    pvti.SetPointCount(1, 4)

    # Define point data
    pvtparameter0.pos = 0
    pvtparameter0.velocity = 0
    pvtparameter0.timeMilliseconds = 0
    pvtparameter1.pos = 0
    pvtparameter1.velocity = 0
    pvtparameter1.timeMilliseconds = 0
    pvti.SetPoints(0, 0, pvtparameter0)
    pvti.SetPoints(1, 0, pvtparameter1)

    pvtparameter0.pos = 50
    pvtparameter0.velocity = 1000
    pvtparameter0.timeMilliseconds = 100
    pvtparameter1.pos = 100
    pvtparameter1.velocity = 2000
    pvtparameter1.timeMilliseconds = 100
    pvti.SetPoints(0, 1, pvtparameter0)
    pvti.SetPoints(1, 1, pvtparameter1)

    pvtparameter0.pos = 100
    pvtparameter0.velocity = 2000
    pvtparameter0.timeMilliseconds = 200
    pvtparameter1.pos = 250
    pvtparameter1.velocity = 1000
    pvtparameter1.timeMilliseconds = 200
    pvti.SetPoints(0, 2, pvtparameter0)
    pvti.SetPoints(1, 2, pvtparameter1)

    pvtparameter0.pos = 200
    pvtparameter0.velocity = 0
    pvtparameter0.timeMilliseconds = 300
    pvtparameter1.pos = 300
    pvtparameter1.velocity = 0
    pvtparameter1.timeMilliseconds = 300
    pvti.SetPoints(0, 3, pvtparameter0)
    pvti.SetPoints(1, 3, pvtparameter1)


    ret = Wmx3Lib_cm.motion.StartPVT_Intpl(pvti)
    if ret != 0:
        print('StartPVT_Intpl error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    
    # Wait for the motion to complete. Start a blocking wait command, returning only when Axis 0 and Axis 1 become idle.
    axisSel = AxisSelection()
    axisSel.axisCount = 2
    axisSel.SetAxis(0, 0)
    axisSel.SetAxis(1, 1)
    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axisSel)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    

#``



# Write python code to Execute a PT (Position-Time) command of Axis 0 of 6 points: (0,0),(100,500),(160,1000),(200,1500),(260,2000),(300,2500)
    # Axes = [0]

    pt = Motion_PTCommand()
    ptparameter = Motion_PTPoint()

    pt.axis = 0
    pt.pointCount = 6

    # Define point data
    ptparameter.pos = 0
    ptparameter.timeMilliseconds = 0
    pt.SetPoints(0, ptparameter)

    ptparameter.pos = 100
    ptparameter.timeMilliseconds = 500
    pt.SetPoints(1, ptparameter)

    ptparameter.pos = 160
    ptparameter.timeMilliseconds = 1000
    pt.SetPoints(2, ptparameter)

    ptparameter.pos = 200
    ptparameter.timeMilliseconds = 1500
    pt.SetPoints(3, ptparameter)

    ptparameter.pos = 260
    ptparameter.timeMilliseconds = 2000
    pt.SetPoints(4, ptparameter)

    ptparameter.pos = 300
    ptparameter.timeMilliseconds = 2500
    pt.SetPoints(5, ptparameter)

    ret = Wmx3Lib_cm.motion.StartPT(pt)
    if ret != 0:
        print('StartPT error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until motion is finished
    ret = Wmx3Lib_cm.motion.Wait(0)
    if ret != 0:
        print('Wait error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    



#``



# Write python code to Execute a VT (Velocity-Time) command of Axis 0 of 6 points: (0,0),(100,500),(200,1000),(300,1500),(400,2000),(500,2500)
    # Axes = [0]

    vt = Motion_VTCommand()
    vtparameter = Motion_VTPoint()

    vt.axis = 0
    vt.pointCount = 6

    # Define point data
    vtparameter.velocity = 0
    vtparameter.timeMilliseconds = 0
    vt.SetPoints(0, vtparameter)

    vtparameter.velocity = 100
    vtparameter.timeMilliseconds = 500
    vt.SetPoints(1, vtparameter)

    vtparameter.velocity = 200
    vtparameter.timeMilliseconds = 1000
    vt.SetPoints(2, vtparameter)

    vtparameter.velocity = 300
    vtparameter.timeMilliseconds = 1500
    vt.SetPoints(3, vtparameter)

    vtparameter.velocity = 400
    vtparameter.timeMilliseconds = 2000
    vt.SetPoints(4, vtparameter)

    vtparameter.velocity = 500
    vtparameter.timeMilliseconds = 2500
    vt.SetPoints(5, vtparameter)

    ret = Wmx3Lib_cm.motion.StartVT(vt)
    if ret != 0:
        print('StartVT error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until motion is finished
    ret = Wmx3Lib_cm.motion.Wait(0)
    if ret != 0:
        print('Wait error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    


#``



# Write python code to Execute anw AT (Acceleration-Time) command of Axis 0 of 7 points: (0,0),(100,500),(100,1000),(-100,1500),(100,2000),(-100,2500),(-100,3000)
    # Axes = [0]

    at = Motion_ATCommand()
    atparameter = Motion_ATPoint()

    at.axis = 0
    at.pointCount = 7

    # Define point data
    atparameter.acc = 0
    atparameter.timeMilliseconds = 0
    at.SetPoints(0, atparameter)

    atparameter.acc = 100
    atparameter.timeMilliseconds = 500
    at.SetPoints(1, atparameter)

    atparameter.acc = 100
    atparameter.timeMilliseconds = 1000
    at.SetPoints(2, atparameter)

    atparameter.acc = -100
    atparameter.timeMilliseconds = 1500
    at.SetPoints(3, atparameter)

    atparameter.acc = 100
    atparameter.timeMilliseconds = 2000
    at.SetPoints(4, atparameter)

    atparameter.acc = -100
    atparameter.timeMilliseconds = 2500
    at.SetPoints(5, atparameter)

    atparameter.acc = -100
    atparameter.timeMilliseconds = 3000
    at.SetPoints(6, atparameter)

    ret = Wmx3Lib_cm.motion.StartAT(at)
    if ret != 0:
        print('StartAT error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Wait until motion is finished
    ret = Wmx3Lib_cm.motion.Wait(0)
    if ret != 0:
        print('Wait error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return
    


#``



# Write python code to Execute a total time(1s) type cubic spline of Axis 0 and Axis 1 with 9 points: (0,0),(100,0),(50,50),(100,100),(100,150),(0,150),(0,100),(50,50),(0,0).
    # Axes = [0, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    ret = Wmx3Lib_adv.advMotion.FreeSplineBuffer(0)

    # Create the spline channel buffer
    ret = Wmx3Lib_adv.advMotion.CreateSplineBuffer(0, 100)
    if ret != 0:
        print('CreateSplineBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Set the spline command options
    spl = AdvMotion_TotalTimeSplineCommand()

    spl.dimensionCount = 2
    spl.SetAxis(0, 0)
    spl.SetAxis(1, 1)
    spl.totalTimeMilliseconds = 1000

    pt = []

    pt.append(AdvMotion_SplinePoint())
    pt[0].SetPos(0, 0)
    pt[0].SetPos(1, 0)

    pt.append(AdvMotion_SplinePoint())
    pt[1].SetPos(0, 100)
    pt[1].SetPos(1, 0)

    pt.append(AdvMotion_SplinePoint())
    pt[2].SetPos(0, 50)
    pt[2].SetPos(1, 50)

    pt.append(AdvMotion_SplinePoint())
    pt[3].SetPos(0, 100)
    pt[3].SetPos(1, 100)

    pt.append(AdvMotion_SplinePoint())
    pt[4].SetPos(0, 100)
    pt[4].SetPos(1, 150)

    pt.append(AdvMotion_SplinePoint())
    pt[5].SetPos(0, 0)
    pt[5].SetPos(1, 150)

    pt.append(AdvMotion_SplinePoint())
    pt[6].SetPos(0, 0)
    pt[6].SetPos(1, 100)

    pt.append(AdvMotion_SplinePoint())
    pt[7].SetPos(0, 50)
    pt[7].SetPos(1, 50)

    pt.append(AdvMotion_SplinePoint())
    pt[8].SetPos(0, 0)
    pt[8].SetPos(1, 0)

    # Execute the spline command
    ret = Wmx3Lib_adv.advMotion.StartCSplinePos_TotalTime(0, spl, 9, pt)
    if ret != 0:
        print('StartCSplinePos_TotalTime error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the spline motion to complete
    axes = AxisSelection()
    axes.axisCount = 2
    axes.SetAxis(0, 0)
    axes.SetAxis(1, 1)

    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axes)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Free the spline buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreeSplineBuffer(0)
    if ret != 0:
        print('FreeSplineBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return
    
    sleep(0.5)




#``



# Write python code to Execute a trapezoidal profile type cubic spline of Axis 0 and Axis 1 with 9 points and the velocity is 1000: (0,0),(100,0),(50,50),(100,100),(100,150),(0,150),(0,100),(50,50),(0,0).
    # Axes = [0, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)
    ret = Wmx3Lib_adv.advMotion.FreeSplineBuffer(0)
        
    # Create the spline channel buffer
    ret = Wmx3Lib_adv.advMotion.CreateSplineBuffer(0, 100)
    if ret != 0:
        print('CreateSplineBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    sleep(0.001)
    # Set the spline command options
    spl = AdvMotion_ProfileSplineCommand()
    spl.dimensionCount = 2
    spl.SetAxis(0, 0)
    spl.SetAxis(1, 1)
    spl.profile = Profile()
    spl.profile.type = ProfileType.Trapezoidal
    spl.profile.velocity = 1000
    spl.profile.acc = 10000
    spl.profile.dec = 10000

    pt = []

    pt.append(AdvMotion_SplinePoint())
    pt[0].SetPos(0, 0)
    pt[0].SetPos(1, 0)

    pt.append(AdvMotion_SplinePoint())
    pt[1].SetPos(0, 100)
    pt[1].SetPos(1, 0)

    pt.append(AdvMotion_SplinePoint())
    pt[2].SetPos(0, 50)
    pt[2].SetPos(1, 50)

    pt.append(AdvMotion_SplinePoint())
    pt[3].SetPos(0, 100)
    pt[3].SetPos(1, 100)

    pt.append(AdvMotion_SplinePoint())
    pt[4].SetPos(0, 100)
    pt[4].SetPos(1, 150)

    pt.append(AdvMotion_SplinePoint())
    pt[5].SetPos(0, 0)
    pt[5].SetPos(1, 150)

    pt.append(AdvMotion_SplinePoint())
    pt[6].SetPos(0, 0)
    pt[6].SetPos(1, 100)

    pt.append(AdvMotion_SplinePoint())
    pt[7].SetPos(0, 50)
    pt[7].SetPos(1, 50)

    pt.append(AdvMotion_SplinePoint())
    pt[8].SetPos(0, 0)
    pt[8].SetPos(1, 0)

    # Execute the spline command
    ret = Wmx3Lib_adv.advMotion.StartCSplinePos_Profile(0, spl, 9, pt)
    if ret != 0:
        print('StartCSplinePos_Profile error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the spline motion to complete
    axes = AxisSelection()
    axes.axisCount = 2
    axes.SetAxis(0, 0)
    axes.SetAxis(1, 1)

    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axes)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Free the spline buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreeSplineBuffer(0)
    if ret != 0:
        print('FreeSplineBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return
    
    sleep(0.5)


#``



# Write python code to Execute a velocity and acceleration limited cubic spline of Axis 0 and Axis 1 with 9 points and the velocity limit of Axis 0 and Axis 1 is 400 and 300, and the acceleration limit of Axis 0 and Axis 1 is 4000 and 3000, and the composite velocity and acceleration is 1000 and 10000: (0,0),(100,0),(50,50),(100,100),(100,150),(0,150),(0,100),(50,50),(0,0).
    # Axes = [0, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)
    ret = Wmx3Lib_adv.advMotion.FreeSplineBuffer(0)
        
    # Create the spline channel buffer
    ret = Wmx3Lib_adv.advMotion.CreateSplineBuffer(0, 200)
    if ret != 0:
        print('CreateSplineBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    sleep(0.001)
    # Set the spline command options
    spl = AdvMotion_VelAccLimitedSplineCommand()
    spl.dimensionCount = 2
    spl.SetAxis(0, 0)
    spl.SetAxis(1, 1)
    spl.SetVelLimit(0, 400)
    spl.SetVelLimit(1, 300)
    spl.SetAccLimit(0, 4000)
    spl.SetAccLimit(1, 3000)
    spl.compositeVel = 1000
    spl.compositeAcc = 10000
    # As with profile type splines, the sampleMultiplier parameter can be increased to improve the accuracy and granularity of the generated velocity and acceleration profile. The sampleMultiplier should be especially increased for point data with a relatively small number of points and a large distance between points. Increasing the sampleMultiplier will not change the shape of the spline trajectory.
    spl.sampleMultiplier = 20

    # Set the spline point data
    pt = []

    pt.append(AdvMotion_SplinePoint())
    pt[0].SetPos(0, 0)
    pt[0].SetPos(1, 0)

    pt.append(AdvMotion_SplinePoint())
    pt[1].SetPos(0, 100)
    pt[1].SetPos(1, 0)

    pt.append(AdvMotion_SplinePoint())
    pt[2].SetPos(0, 50)
    pt[2].SetPos(1, 50)

    pt.append(AdvMotion_SplinePoint())
    pt[3].SetPos(0, 100)
    pt[3].SetPos(1, 100)

    pt.append(AdvMotion_SplinePoint())
    pt[4].SetPos(0, 100)
    pt[4].SetPos(1, 150)

    pt.append(AdvMotion_SplinePoint())
    pt[5].SetPos(0, 0)
    pt[5].SetPos(1, 150)

    pt.append(AdvMotion_SplinePoint())
    pt[6].SetPos(0, 0)
    pt[6].SetPos(1, 100)

    pt.append(AdvMotion_SplinePoint())
    pt[7].SetPos(0, 50)
    pt[7].SetPos(1, 50)

    pt.append(AdvMotion_SplinePoint())
    pt[8].SetPos(0, 0)
    pt[8].SetPos(1, 0)

    # Execute the spline command
    ret = Wmx3Lib_adv.advMotion.StartCSplinePos_VelAccLimited(0, spl, 9, pt)

    if ret != 0:
        print('StartCSplinePos_PointTime error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the spline motion to complete
    axes = AxisSelection()
    axes.axisCount = 2
    axes.SetAxis(0, 0)
    axes.SetAxis(1, 1)
    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axes)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Free the spline buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreeSplineBuffer(0)
    if ret != 0:
        print('FreeSplineBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return
    
    sleep(0.5)



#``



# Write python code to Execute an absolute position path interpolation motion command of Axis 0 and 1 with velocity 1000. The 1st segment is a linear interpolation to position (100, 0), the 2nd segment is a clockwise circular interpolation to position (150, 50) with center point (100, 50), the 3rd segment is a linear interpolation to position (150, 100), the 4th segment is a clockwise circular interpolation to position (100, 150) with center point (100, 100), the 5th segment is a linear interpolation to position (0, 150), the 6th segment is a clockwise circular interpolation to position (-50, 100) with center point (0, 100), the 7th segment is a linear interpolation to position (-50, 50), the 8th segment is a clockwise circular interpolation to position (0, 0) with center point (0, 50).
    # Axes = [0, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplCommand()

    path.SetAxis(0, 0)
    path.SetAxis(1, 1)

    # Use single motion profile for entire path
    path.enableConstProfile = 1
    
    path.profile = Profile()
    path.profile.type = ProfileType.Trapezoidal
    path.profile.velocity = 1000
    path.profile.acc = 10000
    path.profile.dec = 10000

    # Define linear and circular segments
    path.numPoints = 8

    path.SetType(0, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 0, 100)
    path.SetTarget(1, 0, 0)

    path.SetType(1, AdvMotion_PathIntplSegmentType.Circular)
    path.SetTarget(0, 1, 150)
    path.SetTarget(1, 1, 50)
    path.SetCenterPos(0, 1, 100)
    path.SetCenterPos(1, 1, 50)
    path.SetDirection(1, 1)

    path.SetType(2, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 2, 150)
    path.SetTarget(1, 2, 100)

    path.SetType(3, AdvMotion_PathIntplSegmentType.Circular)
    path.SetTarget(0, 3, 100)
    path.SetTarget(1, 3, 150)
    path.SetCenterPos(0, 3, 100)
    path.SetCenterPos(1, 3, 100)
    path.SetDirection(3, 1)

    path.SetType(4, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 4, 0)
    path.SetTarget(1, 4, 150)

    path.SetType(5, AdvMotion_PathIntplSegmentType.Circular)
    path.SetTarget(0, 5, -50)
    path.SetTarget(1, 5, 100)
    path.SetCenterPos(0, 5, 0)
    path.SetCenterPos(1, 5, 100)
    path.SetDirection(5, 1)

    path.SetType(6, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 6, -50)
    path.SetTarget(1, 6, 50)

    path.SetType(7, AdvMotion_PathIntplSegmentType.Circular)
    path.SetTarget(0, 7, 0)
    path.SetTarget(1, 7, 0)
    path.SetCenterPos(0, 7, 0)
    path.SetCenterPos(1, 7, 50)
    path.SetDirection(7, 1)


    ret = Wmx3Lib_adv.advMotion.StartPathIntplPos(path)
    if ret != 0:
        print('StartPathIntplPos error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the spline motion to complete
    axes = AxisSelection()
    axes.axisCount = 2
    axes.SetAxis(0, 0)
    axes.SetAxis(1, 1)
    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axes)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return



#``



# Write python code to Execute an absolute position path interpolation motion command of Axis 0 and 1. The 1st segment is a linear interpolation to position (100, 0) with velocity 1000, the 2nd segment is a clockwise circular interpolation to position (150, 50) with center point (100, 50) with velocity 900, the 3rd segment is a linear interpolation to position (150, 100) with velocity 800, the 4th segment is a clockwise circular interpolation to position (100, 150) with center point (100, 100) with velocity 700, the 5th segment is a linear interpolation to position (0, 150) with velocity 600, the 6th segment is a clockwise circular interpolation to position (-50, 100) with center point (0, 100) with velocity 700, the 7th segment is a linear interpolation to position (-50, 50) with velocity 800, the 8th segment is a clockwise circular interpolation to position (0, 0) with center point (0, 50) with velocity 900. 
    # Axes = [0, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplCommand()

    path.SetAxis(0, 0)
    path.SetAxis(1, 1)

    # Specify motion profile for each segment
    path.enableConstProfile = 0

    # Define linear and circular segments
    path.numPoints = 8

    path.SetType(0, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 0, 100)
    path.SetTarget(1, 0, 0)

    profile = Profile()
    profile.type = ProfileType.Trapezoidal
    profile.velocity = 1000
    profile.acc = 10000
    profile.dec = 10000
    path.SetProfile(0, profile)

    path.SetType(1, AdvMotion_PathIntplSegmentType.Circular)
    path.SetTarget(0, 1, 150)
    path.SetTarget(1, 1, 50)
    path.SetCenterPos(0, 1, 100)
    path.SetCenterPos(1, 1, 50)
    path.SetDirection(1, 1)

    profile = Profile()
    profile.type = ProfileType.Trapezoidal
    profile.velocity = 900
    profile.acc = 10000
    profile.dec = 10000
    path.SetProfile(1, profile)

    path.SetType(2, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 2, 150)
    path.SetTarget(1, 2, 100)

    profile = Profile()
    profile.type = ProfileType.Trapezoidal
    profile.velocity = 800
    profile.acc = 10000
    profile.dec = 10000
    path.SetProfile(2, profile)

    path.SetType(3, AdvMotion_PathIntplSegmentType.Circular)
    path.SetTarget(0, 3, 100)
    path.SetTarget(1, 3, 150)
    path.SetCenterPos(0, 3, 100)
    path.SetCenterPos(1, 3, 100)
    path.SetDirection(3, 1)

    profile = Profile()
    profile.type = ProfileType.Trapezoidal
    profile.velocity = 700
    profile.acc = 10000
    profile.dec = 10000
    path.SetProfile(3, profile)

    path.SetType(4, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 4, 0)
    path.SetTarget(1, 4, 150)

    profile = Profile()
    profile.type = ProfileType.Trapezoidal
    profile.velocity = 600
    profile.acc = 10000
    profile.dec = 10000
    path.SetProfile(4, profile)

    path.SetType(5, AdvMotion_PathIntplSegmentType.Circular)
    path.SetTarget(0, 5, -50)
    path.SetTarget(1, 5, 100)
    path.SetCenterPos(0, 5, 0)
    path.SetCenterPos(1, 5, 100)
    path.SetDirection(5, 1)

    profile = Profile()
    profile.type = ProfileType.Trapezoidal
    profile.velocity = 700
    profile.acc = 10000
    profile.dec = 10000
    path.SetProfile(5, profile)

    path.SetType(6, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 6, -50)
    path.SetTarget(1, 6, 50)

    profile = Profile()
    profile.type = ProfileType.Trapezoidal
    profile.velocity = 800
    profile.acc = 10000
    profile.dec = 10000
    path.SetProfile(6, profile)

    path.SetType(7, AdvMotion_PathIntplSegmentType.Circular)
    path.SetTarget(0, 7, 0)
    path.SetTarget(1, 7, 0)
    path.SetCenterPos(0, 7, 0)
    path.SetCenterPos(1, 7, 50)
    path.SetDirection(5, 1)

    profile = Profile()
    profile.type = ProfileType.Trapezoidal
    profile.velocity = 900
    profile.acc = 10000
    profile.dec = 10000
    path.SetProfile(7, profile)

    ret = Wmx3Lib_adv.advMotion.StartPathIntplPos(path)
    if ret != 0:
        print('StartPathIntplPos error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the spline motion to complete
    axes = AxisSelection()
    axes.axisCount = 2
    axes.SetAxis(0, 0)
    axes.SetAxis(1, 1)
    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axes)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return




#``



# Write python code to Execute an absolute position path interpolation motion command of Axis 0 and 1 specifying the Motion Profile for Each Segment. The 1st segment is a linear interpolation to position (100, 0) with velocity and endvelocity 1000, the 2nd segment is a clockwise circular interpolation to position (150, 50) with center point (100, 50) with velocity and endvelocity 900, the 3rd segment is a linear interpolation to position (150, 100) with velocity and endvelocity 800, the 4th segment is a clockwise circular interpolation to position (100, 150) with center point (100, 100) with velocity and endvelocity 700, the 5th segment is a linear interpolation to position (0, 150) with velocity and endvelocity 600, the 6th segment is a clockwise circular interpolation to position (-50, 100) with center point (0, 100) with velocity and endvelocity 700, the 7th segment is a linear interpolation to position (-50, 50) with velocity and endvelocity 800, the 8th segment is a clockwise circular interpolation to position (0, 0) with center point (0, 50) with velocity 900. 
    # Axes = [0, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplCommand()

    path.SetAxis(0, 0)
    path.SetAxis(1, 1)

    # Specify motion profile for each segment
    path.enableConstProfile = 0

    # Define linear and circular segments
    path.numPoints = 8

    path.SetType(0, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 0, 100)
    path.SetTarget(1, 0, 0)

    profile = Profile()
    profile.type = ProfileType.Trapezoidal
    profile.velocity = 1000
    profile.acc = 10000
    profile.dec = 10000
    profile.endVelocity = 1000
    path.SetProfile(0, profile)

    path.SetType(1, AdvMotion_PathIntplSegmentType.Circular)
    path.SetTarget(0, 1, 150)
    path.SetTarget(1, 1, 50)
    path.SetCenterPos(0, 1, 100)
    path.SetCenterPos(1, 1, 50)
    path.SetDirection(1, 1)

    profile = Profile()
    profile.type = ProfileType.Trapezoidal
    profile.velocity = 900
    profile.acc = 10000
    profile.dec = 10000
    profile.endVelocity = 900
    path.SetProfile(1, profile)

    path.SetType(2, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 2, 150)
    path.SetTarget(1, 2, 100)

    profile = Profile()
    profile.type = ProfileType.Trapezoidal
    profile.velocity = 800
    profile.acc = 10000
    profile.dec = 10000
    profile.endVelocity = 800
    path.SetProfile(2, profile)

    path.SetType(3, AdvMotion_PathIntplSegmentType.Circular)
    path.SetTarget(0, 3, 100)
    path.SetTarget(1, 3, 150)
    path.SetCenterPos(0, 3, 100)
    path.SetCenterPos(1, 3, 100)
    path.SetDirection(3, 1)

    profile = Profile()
    profile.type = ProfileType.Trapezoidal
    profile.velocity = 700
    profile.acc = 10000
    profile.dec = 10000
    profile.endVelocity = 700
    path.SetProfile(3, profile)

    path.SetType(4, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 4, 0)
    path.SetTarget(1, 4, 150)

    profile = Profile()
    profile.type = ProfileType.Trapezoidal
    profile.velocity = 600
    profile.acc = 10000
    profile.dec = 10000
    profile.endVelocity = 600
    path.SetProfile(4, profile)

    path.SetType(5, AdvMotion_PathIntplSegmentType.Circular)
    path.SetTarget(0, 5, -50)
    path.SetTarget(1, 5, 100)
    path.SetCenterPos(0, 5, 0)
    path.SetCenterPos(1, 5, 100)
    path.SetDirection(5, 1)

    profile = Profile()
    profile.type = ProfileType.Trapezoidal
    profile.velocity = 700
    profile.acc = 10000
    profile.dec = 10000
    profile.endVelocity = 700
    path.SetProfile(5, profile)

    path.SetType(6, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 6, -50)
    path.SetTarget(1, 6, 50)

    profile = Profile()
    profile.type = ProfileType.Trapezoidal
    profile.velocity = 800
    profile.acc = 10000
    profile.dec = 10000
    profile.endVelocity = 800
    path.SetProfile(6, profile)

    path.SetType(7, AdvMotion_PathIntplSegmentType.Circular)
    path.SetTarget(0, 7, 0)
    path.SetTarget(1, 7, 0)
    path.SetCenterPos(0, 7, 0)
    path.SetCenterPos(1, 7, 50)
    path.SetDirection(5, 1)

    profile = Profile()
    profile.type = ProfileType.Trapezoidal
    profile.velocity = 900
    profile.acc = 10000
    profile.dec = 10000
    path.SetProfile(7, profile)

    ret = Wmx3Lib_adv.advMotion.StartPathIntplPos(path)
    if ret != 0:
        print('StartPathIntplPos error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the spline motion to complete
    axes = AxisSelection()
    axes.axisCount = 2
    axes.SetAxis(0, 0)
    axes.SetAxis(1, 1)
    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axes)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return




#``



# Write python code to Execute an absolute position path interpolation motion command of Axis 0 and 1 with auto smoothing and the velocity is 1000. The 1st segment is a linear interpolation to position (40, 100) with autoSmoothRadius 10, and the 2nd segment is a linear interpolation to position (80, 0) with autoSmoothRadius 20, and the 3rd segment is a linear interpolation to position (120, 100) with autoSmoothRadius 30, and the 4th segment is a linear interpolation to position (160, 0) with autoSmoothRadius 40, and the 5th segment is a linear interpolation to position (200, 100) with autoSmoothRadius 50, and the 6th segment is a linear interpolation to position (240, 0).
    # Axes = [0, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplCommand()

    path.SetAxis(0, 0)
    path.SetAxis(1, 1)

    # Use single motion profile for entire path
    path.enableConstProfile = 1
    profile = Profile()
    profile.type = ProfileType.Trapezoidal
    profile.velocity = 1000
    profile.acc = 10000
    profile.dec = 10000
    path.SetProfile(0, profile)

    # Auto smoothing
    path.enableAutoSmooth = 1

    # Define linear segments
    path.numPoints = 6

    path.SetType(0, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 0, 40)
    path.SetTarget(1, 0, 100)
    path.SetAutoSmoothRadius(0, 10)

    path.SetType(1, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 1, 80)
    path.SetTarget(1, 1, 0)
    path.SetAutoSmoothRadius(1, 20)

    path.SetType(2, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 2, 120)
    path.SetTarget(1, 2, 100)
    path.SetAutoSmoothRadius(2, 30)

    path.SetType(3, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 3, 160)
    path.SetTarget(1, 3, 0)
    path.SetAutoSmoothRadius(3, 40)

    path.SetType(4, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 4, 200)
    path.SetTarget(1, 4, 100)
    path.SetAutoSmoothRadius(4, 50)

    path.SetType(5, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 5, 240)
    path.SetTarget(1, 5, 0)

    ret = Wmx3Lib_adv.advMotion.StartPathIntplPos(path)
    if ret != 0:
        print('StartPathIntplPos error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the spline motion to complete
    axes = AxisSelection()
    axes.axisCount = 2
    axes.SetAxis(0, 0)
    axes.SetAxis(1, 1)
    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axes)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return



#``



# Write python code to Execute a 3D path interpolation of Axis 0, 1, and 2 with velocity 200. There are 21 segments. 1)Linear interpolation to (90,0,0); 2)Circular interpolation to (100,10,0) with center (97.071,10-7.071,0); 3)Linear interpolation to (100,90,0); 4)Circular interpolation to (90,100,0) with center (97.071,97.071,0); 5)Linear interpolation to (10,100,0); 6)Circular interpolation to (0,90,0) with center (10-7.071,97.071,0); 7)Linear interpolation to (0,0,0); 8)Linear interpolation to (90,0,0); 9)Circular interpolation to (100,0,-10) with center (97.071,0,-10+7.071); 10)Linear interpolation to (100,0,-90); 11)Circular interpolation to (90,0,-100) with center (97.071,0,-97.071); 12)Linear interpolation to (10,0,-100); 13)Circular interpolation to (0,0,-90) with center (10-7.071,0,-97.071); 14)Linear interpolation to (0,0,0); 15)Linear interpolation to (0,90,0);  16)Circular interpolation to (0,100,-10) with center (0,97.071,-10+7.071); 17)Linear interpolation to (0,100,-90); 18)Circular interpolation to (0,90,-100) with center (0,97.071,-97.071); 19)Linear interpolation to (0,10,-100); 20)Circular interpolation to (0,0,-90) with center (0,10-7.071,-97.071); 21)Linear interpolation to (0,0,0).
    # Axes = [0, 1, 2]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntpl3DCommand()

    path.SetAxis(0, 0)
    path.SetAxis(1, 1)
    path.SetAxis(2, 2)

    # Use single motion profile for entire path
    path.enableConstProfile = 1
    profile = Profile()
    profile.type = ProfileType.Trapezoidal
    profile.velocity = 200
    profile.acc = 2000
    profile.dec = 2000
    path.SetProfile(0, profile)

    # Define linear and circular segments
    path.numPoints = 21

    path.SetType(0, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 0, 90)
    path.SetTarget(1, 0, 0)
    path.SetTarget(2, 0, 0)

    path.SetType(1, AdvMotion_PathIntplSegmentType.Circular)
    path.SetTarget(0, 1, 100)
    path.SetTarget(1, 1, 10)
    path.SetTarget(2, 1, 0)
    path.SetCircleIntermediateTarget(0, 1, 97.071)
    path.SetCircleIntermediateTarget(1, 1, 10 - 7.071)
    path.SetCircleIntermediateTarget(2, 1, 0)

    path.SetType(2, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 2, 100)
    path.SetTarget(1, 2, 90)
    path.SetTarget(2, 2, 0)

    path.SetType(3, AdvMotion_PathIntplSegmentType.Circular)
    path.SetTarget(0, 3, 90)
    path.SetTarget(1, 3, 100)
    path.SetTarget(2, 3, 0)
    path.SetCircleIntermediateTarget(0, 3, 97.071)
    path.SetCircleIntermediateTarget(1, 3, 97.071)
    path.SetCircleIntermediateTarget(2, 3, 0)

    path.SetType(4, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 4, 10)
    path.SetTarget(1, 4, 100)
    path.SetTarget(2, 4, 0)

    path.SetType(5, AdvMotion_PathIntplSegmentType.Circular)
    path.SetTarget(0, 5, 0)
    path.SetTarget(1, 5, 90)
    path.SetTarget(2, 5, 0)
    path.SetCircleIntermediateTarget(0, 5, 10 - 7.071)
    path.SetCircleIntermediateTarget(1, 5, 97.071)
    path.SetCircleIntermediateTarget(2, 5, 0)

    path.SetType(6, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 6, 0)
    path.SetTarget(1, 6, 0)
    path.SetTarget(2, 6, 0)

    path.SetType(7, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 7, 90)
    path.SetTarget(1, 7, 0)
    path.SetTarget(2, 7, 0)

    path.SetType(8, AdvMotion_PathIntplSegmentType.Circular)
    path.SetTarget(0, 8, 100)
    path.SetTarget(1, 8, 0)
    path.SetTarget(2, 8, -10)
    path.SetCircleIntermediateTarget(0, 8, 97.071)
    path.SetCircleIntermediateTarget(1, 8, 0)
    path.SetCircleIntermediateTarget(2, 8, -(10 - 7.071))

    path.SetType(9, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 9, 100)
    path.SetTarget(1, 9, 0)
    path.SetTarget(2, 9, -90)

    path.SetType(10, AdvMotion_PathIntplSegmentType.Circular)
    path.SetTarget(0, 10, 90)
    path.SetTarget(1, 10, 0)
    path.SetTarget(2, 10, -100)
    path.SetCircleIntermediateTarget(0, 10, 97.071)
    path.SetCircleIntermediateTarget(1, 10, 0)
    path.SetCircleIntermediateTarget(2, 10, -97.071)

    path.SetType(11, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 11, 10)
    path.SetTarget(1, 11, 0)
    path.SetTarget(2, 11, -100)

    path.SetType(12, AdvMotion_PathIntplSegmentType.Circular)
    path.SetTarget(0, 12, 0)
    path.SetTarget(1, 12, 0)
    path.SetTarget(2, 12, -90)
    path.SetCircleIntermediateTarget(0, 12, 10 - 7.071)
    path.SetCircleIntermediateTarget(1, 12, 0)
    path.SetCircleIntermediateTarget(2, 12, -97.071)

    path.SetType(13, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 13, 0)
    path.SetTarget(1, 13, 0)
    path.SetTarget(2, 1, 0)

    path.SetType(14, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 14, 0)
    path.SetTarget(1, 14, 90)
    path.SetTarget(2, 14, 0)

    path.SetType(15, AdvMotion_PathIntplSegmentType.Circular)
    path.SetTarget(0, 15, 0)
    path.SetTarget(1, 15, 100)
    path.SetTarget(2, 15, -10)
    path.SetCircleIntermediateTarget(0, 15, 0)
    path.SetCircleIntermediateTarget(1, 15, 97.071)
    path.SetCircleIntermediateTarget(2, 15, -(10 - 7.071))

    path.SetType(16, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 16, 0)
    path.SetTarget(1, 16, 100)
    path.SetTarget(2, 16, -90)

    path.SetType(17, AdvMotion_PathIntplSegmentType.Circular)
    path.SetTarget(0, 17, 0)
    path.SetTarget(1, 17, 90)
    path.SetTarget(2, 17, -100)
    path.SetCircleIntermediateTarget(0, 17, 0)
    path.SetCircleIntermediateTarget(1, 17, 97.071)
    path.SetCircleIntermediateTarget(2, 17, -97.071)

    path.SetType(18, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 18, 0)
    path.SetTarget(1, 18, 10)
    path.SetTarget(2, 18, -100)

    path.SetType(19, AdvMotion_PathIntplSegmentType.Circular)
    path.SetTarget(0, 19, 0)
    path.SetTarget(1, 19, 0)
    path.SetTarget(2, 19, -90)
    path.SetCircleIntermediateTarget(0, 19, 0)
    path.SetCircleIntermediateTarget(1, 19, 10 - 7.071)
    path.SetCircleIntermediateTarget(2, 19, -97.071)

    path.SetType(20, AdvMotion_PathIntplSegmentType.Linear)
    path.SetTarget(0, 20, 0)
    path.SetTarget(1, 20, 0)
    path.SetTarget(2, 20, 0)

    ret = Wmx3Lib_adv.advMotion.StartPathIntpl3DPos(path)
    if ret != 0:
        print('StartPathIntpl3DPos error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return
    

    # Wait for the spline motion to complete
    axes = AxisSelection()
    axes.axisCount = 3
    axes.SetAxis(0, 0)
    axes.SetAxis(1, 1)
    axes.SetAxis(2, 2)
    ret = Wmx3Lib_cm.motion.Wait_AxisSel(axes)
    if ret != 0:
        print('Wait_AxisSel error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return




#``



# Write python code to Execute a path interpolation with rotation sequence consisting of four linear interpolations of Axis 0 and 1 with a rotation Axis 2, and the velocity is 1000. Disable rotating the X and Y axes around the center of rotation. The center of rotation is (50,50). The positions of four linear interpolations are: (100,0),(100,100),(0,100),(0,0).
    # Axes = [0, 1, 2]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplWithRotationCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplWithRotationBuffer(0)
    # Create the path interpolation with rotation buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplWithRotationBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplWithRotationBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with rotation channel
    conf = AdvMotion_PathIntplWithRotationConfiguration()

    conf.SetAxis(0, 0)  # X axis
    conf.SetAxis(1, 1)  # Y axis
    conf.rotationalAxis = 2  # Rotational axis
    conf.SetCenterOfRotation(0, 50)  # X axis center of rotation position
    conf.SetCenterOfRotation(1, 50)  # Y axis center of rotation position

    # Rotational axis angle correction motion profile parameters
    conf.angleCorrectionProfile.type = ProfileType.Trapezoidal
    conf.angleCorrectionProfile.velocity = 900
    conf.angleCorrectionProfile.acc = 1800
    conf.angleCorrectionProfile.dec = 1800

    # Disable rotating the X and Y axes around the center of rotation when the rotational axis moves
    conf.disableXYRotationalMotion = 1

    ret = Wmx3Lib_adv.advMotion.SetPathIntplWithRotationConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplWithRotationConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Set Axis 2 to single-turn mode, single-turn encoder count 360.
    ret=Wmx3Lib_cm.config.SetSingleTurn(2,True,360)
    if ret != 0:
        print('SetSingleTurn error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Add the path interpolation with rotation commands
    path.numPoints = 4

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    profile = Profile()
    point.profile.type = ProfileType.Trapezoidal
    point.profile.velocity = 1000
    point.profile.acc = 2000
    point.profile.dec = 2000
    point.SetTarget(0, 100)
    point.SetTarget(1, 0)
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    profile = Profile()
    point.profile.type = ProfileType.Trapezoidal
    point.profile.velocity = 1000
    point.profile.acc = 2000
    point.profile.dec = 2000
    point.SetTarget(0, 100)
    point.SetTarget(1, 100)
    path.SetPoint(1, point)

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    profile = Profile()
    point.profile.type = ProfileType.Trapezoidal
    point.profile.velocity = 1000
    point.profile.acc = 2000
    point.profile.dec = 2000
    point.SetTarget(0, 0)
    point.SetTarget(1, 100)
    path.SetPoint(2, point)

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    profile = Profile()
    point.profile.type = ProfileType.Trapezoidal
    point.profile.velocity = 1000
    point.profile.acc = 2000
    point.profile.dec = 2000
    point.SetTarget(0, 0)
    point.SetTarget(1, 0)
    path.SetPoint(3, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplWithRotationCommand(0, path)
    if ret != 0:
        print('AddPathIntplWithRotationCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Execute path interpolation with rotation
    ret = Wmx3Lib_adv.advMotion.StartPathIntplWithRotation(0)

    if ret != 0:
        print('StartPathIntplWithRotation error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return
    Wmx3Lib_cm.motion.Wait(0)
    timeoutCounter = 0
    # Wait until the path interpolation with rotation is in Idle state
    pathStatus = AdvMotion_PathIntplWithRotationState()
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplWithRotationStatus(0)
    while True:
        if (pathStatus.state == AdvMotion_PathIntplWithRotationState.Idle):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplWithRotationStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplWithRotation Runuing timeout.!')
        return
    # Free the path interpolation with rotation buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplWithRotationBuffer(0)
    if ret != 0:
        print('FreePathIntplWithRotationBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    sleep(1)
    #Turn off Axis 2 single-turn mode.
    AxisParam=Config_AxisParam()
    ret,AxisParam =Wmx3Lib_cm.config.GetAxisParam()
    AxisParam.SetSingleTurnMode(2,False)

    ret,AxisParamError=Wmx3Lib_cm.config.SetAxisParam(AxisParam)
    if ret != 0:
        print('Close SingleTurnMode error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return



#``



# Write python code to Executes a path interpolation of Axis 0 and 1 with a rotation Axis 2, and the velocity is 100.  Sequence consisting of four linear interpolations and enable rotating the X and Y axes around the center of rotation. The center of rotation is (50,50). The positions of four linear interpolations are: (100,0),(100,100),(0,100),(0,0).
    # Axes = [0, 1, 2]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplWithRotationCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplWithRotationBuffer(0)
    # Create the path interpolation with rotation buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplWithRotationBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplWithRotationBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with rotation channel
    conf = AdvMotion_PathIntplWithRotationConfiguration()
    
    conf.SetAxis(0, 0)  # X axis
    conf.SetAxis(1, 1)  # Y axis
    conf.rotationalAxis = 2  # Rotational axis
    conf.SetCenterOfRotation(0, 50)  # X axis center of rotation position
    conf.SetCenterOfRotation(1, 50)  # Y axis center of rotation position

    # Rotational axis angle correction motion profile parameters
    conf.angleCorrectionProfile.type = ProfileType.Trapezoidal
    conf.angleCorrectionProfile.velocity = 200
    conf.angleCorrectionProfile.acc = 1800
    conf.angleCorrectionProfile.dec = 1800

    ret = Wmx3Lib_adv.advMotion.SetPathIntplWithRotationConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplWithRotationConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    #Set Axis 2 to single-turn mode, single-turn encoder count 360.
    ret=Wmx3Lib_cm.config.SetSingleTurn(2,True,360)
    if ret != 0:
        print('SetSingleTurn error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Add the path interpolation with rotation commands
    path.numPoints = 4

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    profile = Profile()
    point.profile.type = ProfileType.Trapezoidal
    point.profile.velocity = 100
    point.profile.acc = 2000
    point.profile.dec = 2000
    point.SetTarget(0, 100)
    point.SetTarget(1, 0)
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    profile = Profile()
    point.profile.type = ProfileType.Trapezoidal
    point.profile.velocity = 100
    point.profile.acc = 2000
    point.profile.dec = 2000
    point.SetTarget(0, 100)
    point.SetTarget(1, 100)
    path.SetPoint(1, point)

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    profile = Profile()
    point.profile.type = ProfileType.Trapezoidal
    point.profile.velocity = 100
    point.profile.acc = 2000
    point.profile.dec = 2000
    point.SetTarget(0, 0)
    point.SetTarget(1, 100)
    path.SetPoint(2, point)

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    profile = Profile()
    point.profile.type = ProfileType.Trapezoidal
    point.profile.velocity = 100
    point.profile.acc = 2000
    point.profile.dec = 2000
    point.SetTarget(0, 0)
    point.SetTarget(1, 0)
    path.SetPoint(3, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplWithRotationCommand(0, path)
    if ret != 0:
        print('AddPathIntplWithRotationCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Execute path interpolation with rotation
    ret = Wmx3Lib_adv.advMotion.StartPathIntplWithRotation(0)
    if ret != 0:
        print('StartPathIntplWithRotation error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    sleep(1)
    #Wmx3Lib_cm.motion.Wait(0)
    timeoutCounter = 0
    
    # Wait until the path interpolation with rotation is in Idle state
    pathStatus = AdvMotion_PathIntplWithRotationState()
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplWithRotationStatus(0)
    while True:
        if (pathStatus.state == AdvMotion_PathIntplWithRotationState.Idle):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplWithRotationStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplWithRotation Runuing timeout.!')
        return
    
    # Free the path interpolation with rotation buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplWithRotationBuffer(0)
    if ret != 0:
        print('FreePathIntplWithRotationBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    #Turn off Axis 2 single-turn mode.
    AxisParam=Config_AxisParam()
    ret,AxisParam =Wmx3Lib_cm.config.GetAxisParam()
    AxisParam.SetSingleTurnMode(2,False)

    ret,AxisParamError=Wmx3Lib_cm.config.SetAxisParam(AxisParam)
    if ret != 0:
        print('Close SingleTurnMode error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return



#``



# Write python code to Executes a path interpolation of Axis 0 and 1 with a rotation Axis 2 without stopping after executing each segment, and the velocity is 100. Sequence consisting of four linear interpolations and enable rotating the X and Y axes around the center of rotation. The center of rotation is (50,50). The positions of four linear interpolations are: (100,0),(100,100),(0,100),(0,0). Auto smoothing radius after 1st, 2nd and 3rd segment are 30, 20, 10.
    # Axes = [0, 1, 2]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplWithRotationCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplWithRotationBuffer(0)
    # Create the path interpolation with rotation buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplWithRotationBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplWithRotationBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with rotation channel
    conf = AdvMotion_PathIntplWithRotationConfiguration()

    conf.SetAxis(0, 0)  # X axis
    conf.SetAxis(1, 1)  # Y axis
    conf.rotationalAxis = 2  # Rotational axis
    conf.SetCenterOfRotation(0, 50)  # X axis center of rotation position
    conf.SetCenterOfRotation(1, 50)  # Y axis center of rotation position

    # Rotational axis angle correction motion profile parameters
    conf.angleCorrectionProfile.type = ProfileType.Trapezoidal
    conf.angleCorrectionProfile.velocity = 200
    conf.angleCorrectionProfile.acc = 1800
    conf.angleCorrectionProfile.dec = 1800

    # Enable auto smoothing
    conf.enableAutoSmooth = 1

    # Do not stop the motion along the path at very small angles between two segments
    conf.angleCorrectionMinimumAngle = 0.01

    # Enable constant profile
    conf.enableConstProfile = 1

    ret = Wmx3Lib_adv.advMotion.SetPathIntplWithRotationConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplWithRotationConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    #Set Axis 2 to single-turn mode, single-turn encoder count .
    ret=Wmx3Lib_cm.config.SetSingleTurn(2,True,360)
    if ret != 0:
        print('SetSingleTurn error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Add the path interpolation with rotation commands
    path.numPoints = 4

    # Only specify the profile for the first point as constant profile is enabled
    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    profile = Profile()
    point.profile.type = ProfileType.Trapezoidal
    point.profile.velocity = 100
    point.profile.acc = 2000
    point.profile.dec = 2000
    point.SetTarget(0, 100)
    point.SetTarget(1, 0)
    point.autoSmoothRadius = 30  # Auto smoothing radius after first segment
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    point.SetTarget(0, 100)
    point.SetTarget(1, 100)
    point.autoSmoothRadius = 20  # Auto smoothing radius after second segment
    path.SetPoint(1, point)

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    point.SetTarget(0, 0)
    point.SetTarget(1, 100)
    point.autoSmoothRadius = 10  # Auto smoothing radius after third segment
    path.SetPoint(2, point)

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    point.SetTarget(0, 0)
    point.SetTarget(1, 0)
    path.SetPoint(3, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplWithRotationCommand(0, path)
    if ret != 0:
        print('AddPathIntplWithRotationCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Execute path interpolation with rotation
    ret = Wmx3Lib_adv.advMotion.StartPathIntplWithRotation(0)

    if ret != 0:
        print('StartPathIntplWithRotation error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return
    Wmx3Lib_cm.motion.Wait(0)
    timeoutCounter = 0
    # Wait until the path interpolation with rotation is in Idle state
    pathStatus = AdvMotion_PathIntplWithRotationState()
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplWithRotationStatus(0)
    while True:
        if (pathStatus.state == AdvMotion_PathIntplWithRotationState.Idle):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplWithRotationStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplWithRotation Runuing timeout.!')
        return
    # Free the path interpolation with rotation buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplWithRotationBuffer(0)
    if ret != 0:
        print('FreePathIntplWithRotationBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    #Turn off Axis 2 single-turn mode.
    AxisParam=Config_AxisParam()
    ret,AxisParam =Wmx3Lib_cm.config.GetAxisParam()
    AxisParam.SetSingleTurnMode(2,False)

    ret,AxisParamError=Wmx3Lib_cm.config.SetAxisParam(AxisParam)
    if ret != 0:
        print('Close SingleTurnMode error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return



#``



# Write python code to Executes a path interpolation of Axis 0 and 1 with a rotation Axis 2 with stopping after executing each segment, and the velocity is 100. Sequence consisting of four linear interpolations and enable rotating the X and Y axes around the center of rotation. The center of rotation is (50,50). The positions of four linear interpolations are: (100,0),(100,100),(0,100),(0,0). Auto smoothing radius after 1st, 2nd and 3rd segment are 30, 20, 10.
    # Axes = [0, 1, 2]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplWithRotationCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplWithRotationBuffer(0)
    # Create the path interpolation with rotation buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplWithRotationBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplWithRotationBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with rotation channel
    conf = AdvMotion_PathIntplWithRotationConfiguration()

    conf.SetAxis(0, 0)  # X axis
    conf.SetAxis(1, 1)  # Y axis
    conf.rotationalAxis = 2  # Rotational axis
    conf.SetCenterOfRotation(0, 50)  # X axis center of rotation position
    conf.SetCenterOfRotation(1, 50)  # Y axis center of rotation position

    # Rotational axis angle correction motion profile parameters
    conf.angleCorrectionProfile.type = ProfileType.Trapezoidal
    conf.angleCorrectionProfile.velocity = 200
    conf.angleCorrectionProfile.acc = 1800
    conf.angleCorrectionProfile.dec = 1800

    # Enable auto smoothing
    conf.enableAutoSmooth = 1

    # Do not stop the motion along the path at very small angles between two segments
    conf.angleCorrectionMinimumAngle = 0.01

    ret = Wmx3Lib_adv.advMotion.SetPathIntplWithRotationConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplWithRotationConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    #Set Axis 2 to single-turn mode, single-turn encoder count 360.
    ret=Wmx3Lib_cm.config.SetSingleTurn(2,True,360)
    if ret != 0:
        print('SetSingleTurn error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Add the path interpolation with rotation commands
    path.numPoints = 4

    # Only specify the profile for the first point as constant profile is enabled
    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    profile = Profile()
    point.profile.type = ProfileType.Trapezoidal
    point.profile.velocity = 100
    point.profile.acc = 2000
    point.profile.dec = 2000
    point.SetTarget(0, 100)
    point.SetTarget(1, 0)
    point.autoSmoothRadius = 30  # Auto smoothing radius after first segment
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    profile = Profile()
    point.profile.type = ProfileType.Trapezoidal
    point.profile.velocity = 100
    point.profile.acc = 2000
    point.profile.dec = 2000
    point.SetTarget(0, 100)
    point.SetTarget(1, 100)
    point.autoSmoothRadius = 20  # Auto smoothing radius after second segment
    path.SetPoint(1, point)

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    profile = Profile()
    point.profile.type = ProfileType.Trapezoidal
    point.profile.velocity = 100
    point.profile.acc = 2000
    point.profile.dec = 2000
    point.SetTarget(0, 0)
    point.SetTarget(1, 100)
    point.autoSmoothRadius = 10  # Auto smoothing radius after third segment
    path.SetPoint(2, point)

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    profile = Profile()
    point.profile.type = ProfileType.Trapezoidal
    point.profile.velocity = 100
    point.profile.acc = 2000
    point.profile.dec = 2000
    point.SetTarget(0, 0)
    point.SetTarget(1, 0)
    path.SetPoint(3, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplWithRotationCommand(0, path)
    if ret != 0:
        print('AddPathIntplWithRotationCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Execute path interpolation with rotation
    ret = Wmx3Lib_adv.advMotion.StartPathIntplWithRotation(0)
    if ret != 0:
        print('StartPathIntplWithRotation error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return
    Wmx3Lib_cm.motion.Wait(0)
    timeoutCounter = 0
    # Wait until the path interpolation with rotation is in Idle state
    pathStatus = AdvMotion_PathIntplWithRotationState()
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplWithRotationStatus(0)
    while True:
        if (pathStatus.state == AdvMotion_PathIntplWithRotationState.Idle):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplWithRotationStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplWithRotation Runuing timeout.!')
        return
    # Free the path interpolation with rotation buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplWithRotationBuffer(0)
    if ret != 0:
        print('FreePathIntplWithRotationBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    #Turn off Axis 2 single-turn mode.
    AxisParam=Config_AxisParam()
    ret,AxisParam =Wmx3Lib_cm.config.GetAxisParam()
    AxisParam.SetSingleTurnMode(2,False)

    ret,AxisParamError=Wmx3Lib_cm.config.SetAxisParam(AxisParam)
    if ret != 0:
        print('Close SingleTurnMode error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return



#``



# Write python code to Executes a path interpolation of Axis 0 and 1 with a rotation Axis 2 and the velocity is 100. Sequence consisting of four linear interpolations and enable rotating the X and Y axes around the center of rotation. The center of rotation is (50,50). The positions of four linear interpolations are: (100,0),(100,100),(0,100),(0,0). First linearly interpolate to Point 2, then sleep 0.2s, and linearly interpolate to the last point, then sleep 0.2s, and linearly interpolate to Point 0.
    # Axes = [0, 1, 2]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplWithRotationCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplWithRotationBuffer(0)
    # Create the path interpolation with rotation buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplWithRotationBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplWithRotationBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with rotation channel
    conf = AdvMotion_PathIntplWithRotationConfiguration()

    conf.SetAxis(0, 0)  # X axis
    conf.SetAxis(1, 1)  # Y axis
    conf.rotationalAxis = 2  # Rotational axis
    conf.SetCenterOfRotation(0, 50)  # X axis center of rotation position
    conf.SetCenterOfRotation(1, 50)  # Y axis center of rotation position

    # Rotational axis angle correction motion profile parameters
    conf.angleCorrectionProfile.type = ProfileType.Trapezoidal
    conf.angleCorrectionProfile.velocity = 200
    conf.angleCorrectionProfile.acc = 1800
    conf.angleCorrectionProfile.dec = 1800

    ret = Wmx3Lib_adv.advMotion.SetPathIntplWithRotationConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplWithRotationConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    #Set Axis 2 to single-turn mode, single-turn encoder count 360.
    ret=Wmx3Lib_cm.config.SetSingleTurn(2,True,360)
    if ret != 0:
        print('SetSingleTurn error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Add the path interpolation with rotation commands
    path.numPoints = 4

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    profile = Profile()
    point.profile.type = ProfileType.Trapezoidal
    point.profile.velocity = 100
    point.profile.acc = 2000
    point.profile.dec = 2000
    point.SetTarget(0, 100)
    point.SetTarget(1, 0)
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    profile = Profile()
    point.profile.type = ProfileType.Trapezoidal
    point.profile.velocity = 100
    point.profile.acc = 2000
    point.profile.dec = 2000
    point.SetTarget(0, 100)
    point.SetTarget(1, 100)
    path.SetPoint(1, point)

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    profile = Profile()
    point.profile.type = ProfileType.Trapezoidal
    point.profile.velocity = 100
    point.profile.acc = 2000
    point.profile.dec = 2000
    point.SetTarget(0, 0)
    point.SetTarget(1, 100)
    path.SetPoint(2, point)

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    profile = Profile()
    point.profile.type = ProfileType.Trapezoidal
    point.profile.velocity = 100
    point.profile.acc = 2000
    point.profile.dec = 2000
    point.SetTarget(0, 0)
    point.SetTarget(1, 0)
    path.SetPoint(3, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplWithRotationCommand(0, path)
    if ret != 0:
        print('AddPathIntplWithRotationCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Execute path interpolation with rotation
    ret = Wmx3Lib_adv.advMotion.StartPathIntplWithRotation_Pos(0, 2)  # Move to point 2
    if ret != 0:
        print('StartPathIntplWithRotation_Pos error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for axis 0 to finish motion
    ret = Wmx3Lib_cm.motion.Wait(0)
    # Sleep for 200ms after motion finishes
    sleep(0.2)

    # Move to end of path
    ret = Wmx3Lib_adv.advMotion.StartPathIntplWithRotation(0)  # Move to the last point
    if ret != 0:
        print('StartPathIntplWithRotation error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for axis 0 to finish motion
    ret = Wmx3Lib_cm.motion.Wait(0)
    # Sleep for 200ms after motion finishes
    sleep(0.2)
    # Move to point 0 (start of path)
    ret = Wmx3Lib_adv.advMotion.StartPathIntplWithRotation_Pos(0, 0)  # Move to point 0
    if ret != 0:
        print('StartPathIntplWithRotation_Pos error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return
    Wmx3Lib_cm.motion.Wait(0)
    timeoutCounter = 0
    # Wait until the path interpolation with rotation is in Idle state
    pathStatus = AdvMotion_PathIntplWithRotationState()
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplWithRotationStatus(0)
    while True:
        if (pathStatus.state == AdvMotion_PathIntplWithRotationState.Idle):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplWithRotationStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplWithRotation Runuing timeout.!')
        return
    # Free the path interpolation with rotation buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplWithRotationBuffer(0)
    if ret != 0:
        print('FreePathIntplWithRotationBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    #Turn off Axis 2 single-turn mode.
    AxisParam=Config_AxisParam()
    ret,AxisParam =Wmx3Lib_cm.config.GetAxisParam()
    AxisParam.SetSingleTurnMode(2,False)

    ret,AxisParamError=Wmx3Lib_cm.config.SetAxisParam(AxisParam)
    if ret != 0:
        print('Close SingleTurnMode error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return
    


#``



# Write python code to Executes a path interpolation of Axis 0 and 1 with a rotation Axis 2 and the velocity is 100. Sequence consisting of four linear interpolations and enable rotating the X and Y axes around the center of rotation of (50,50). The positions of four linear interpolations are: (100,0),(100,100),(0,100),(0,0). The local center rotation of each segment is respectively (50,40),(60,50),(50,60) and (40,50).
    # Axes = [0, 1, 2]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplWithRotationCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplWithRotationBuffer(0)
    # Create the path interpolation with rotation buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplWithRotationBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplWithRotationBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with rotation channel
    conf = AdvMotion_PathIntplWithRotationConfiguration()

    conf.SetAxis(0, 0)  # X axis
    conf.SetAxis(1, 1)  # Y axis
    conf.rotationalAxis = 2  # Rotational axis
    conf.SetCenterOfRotation(0, 50)  # X axis center of rotation position
    conf.SetCenterOfRotation(1, 50)  # Y axis center of rotation position

    # Rotational axis angle correction motion profile parameters
    conf.angleCorrectionProfile.type = ProfileType.Trapezoidal
    conf.angleCorrectionProfile.velocity = 200
    conf.angleCorrectionProfile.acc = 1800
    conf.angleCorrectionProfile.dec = 1800

    # Enable local center of rotation
    conf.enableLocalCenterOfRotation = 1

    ret = Wmx3Lib_adv.advMotion.SetPathIntplWithRotationConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplWithRotationConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    #Set Axis 2 to single-turn mode, single-turn encoder count 360.
    ret=Wmx3Lib_cm.config.SetSingleTurn(2,True,360)
    if ret != 0:
        print('SetSingleTurn error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Add the path interpolation with rotation commands
    path.numPoints = 4

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    profile = Profile()
    point.profile.type = ProfileType.Trapezoidal
    point.profile.velocity = 100
    point.profile.acc = 2000
    point.profile.dec = 2000
    point.SetTarget(0, 100)
    point.SetTarget(1, 0)
    point.useLocalCenterOfRotation = 1
    point.localCenterOfRotationDirection = 1
    point.SetLocalCenterOfRotation(0, 50)
    point.SetLocalCenterOfRotation(1, 40)
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    profile = Profile()
    point.profile.type = ProfileType.Trapezoidal
    point.profile.velocity = 100
    point.profile.acc = 2000
    point.profile.dec = 2000
    point.SetTarget(0, 100)
    point.SetTarget(1, 100)
    point.useLocalCenterOfRotation = 1
    point.localCenterOfRotationDirection = 1
    point.SetLocalCenterOfRotation(0, 60)
    point.SetLocalCenterOfRotation(1, 50)
    path.SetPoint(1, point)

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    profile = Profile()
    point.profile.type = ProfileType.Trapezoidal
    point.profile.velocity = 100
    point.profile.acc = 2000
    point.profile.dec = 2000
    point.SetTarget(0, 0)
    point.SetTarget(1, 100)
    point.useLocalCenterOfRotation = 1
    point.localCenterOfRotationDirection = 1
    point.SetLocalCenterOfRotation(0, 50)
    point.SetLocalCenterOfRotation(1, 60)
    path.SetPoint(2, point)

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    profile = Profile()
    point.profile.type = ProfileType.Trapezoidal
    point.profile.velocity = 100
    point.profile.acc = 2000
    point.profile.dec = 2000
    point.SetTarget(0, 0)
    point.SetTarget(1, 0)
    point.useLocalCenterOfRotation = 1
    point.localCenterOfRotationDirection = 1
    point.SetLocalCenterOfRotation(0, 40)
    point.SetLocalCenterOfRotation(1, 50)
    path.SetPoint(3, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplWithRotationCommand(0, path)
    if ret != 0:
        print('AddPathIntplWithRotationCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Execute path interpolation with rotation
    ret = Wmx3Lib_adv.advMotion.StartPathIntplWithRotation(0)  # Move to point 2
    if ret != 0:
        print('StartPathIntplWithRotation error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return
    Wmx3Lib_cm.motion.Wait(0)
    timeoutCounter = 0
    # Wait until the path interpolation with rotation is in Idle state
    pathStatus = AdvMotion_PathIntplWithRotationState()
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplWithRotationStatus(0)
    while True:
        if (pathStatus.state == AdvMotion_PathIntplWithRotationState.Idle):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplWithRotationStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplWithRotation Runuing timeout.!')
        return
    # Free the path interpolation with rotation buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplWithRotationBuffer(0)
    if ret != 0:
        print('FreePathIntplWithRotationBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    #Turn off Axis 2 single-turn mode.
    AxisParam=Config_AxisParam()
    ret,AxisParam =Wmx3Lib_cm.config.GetAxisParam()
    AxisParam.SetSingleTurnMode(2,False)

    ret,AxisParamError=Wmx3Lib_cm.config.SetAxisParam(AxisParam)
    if ret != 0:
        print('Close SingleTurnMode error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return
    



#``



# Write python code to Executes a path interpolation of Axis 0 and 1 with a rotation Axis 2 and with a Z axis 3, the center of rotation is (75,75) and the velocity is 1000. There are 7 segments. 1)Linear interpolation to (100,0) and Z axis to 25; 2)Circular interpolation to (150,50) with center (100,50) and Z axis to 50; 3)Linear interpolation to (150,100) and Z axis to 75; 4)Circular interpolation to (100,150) with center (100,100) and Z axis to 100; 5)Linear interpolation to (50,150) and Z axis to 125; 6)Circular interpolation to (100,150) with center (50,100) and Z axis to 150; 7)Linear interpolation to (0,0) and Z axis to 175.
    # Axes = [0, 1, 2, 3]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplWithRotationCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplWithRotationBuffer(0)
    # Create the path interpolation with rotation buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplWithRotationBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplWithRotationBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with rotation channel
    conf = AdvMotion_PathIntplWithRotationConfiguration()

    conf.SetAxis(0, 0)  # X axis
    conf.SetAxis(1, 1)  # Y axis
    conf.rotationalAxis = 2  # Rotational axis
    conf.SetCenterOfRotation(0, 75)  # X axis center of rotation position
    conf.SetCenterOfRotation(1, 75)  # Y axis center of rotation position

    # Enable constant profile
    conf.enableConstProfile = 1

    # Prevent stop from occurring at very small angles
    conf.angleCorrectionMinimumAngle = 0.01

    # Enable Z axis
    conf.enableZAxis = 1
    conf.zAxis = 3

    # Rotational axis angle correction motion profile parameters
    conf.angleCorrectionProfile.type = ProfileType.Trapezoidal
    conf.angleCorrectionProfile.velocity = 900
    conf.angleCorrectionProfile.acc = 1800
    conf.angleCorrectionProfile.dec = 1800

    ret = Wmx3Lib_adv.advMotion.SetPathIntplWithRotationConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplWithRotationConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    #Set Axis 2 to single-turn mode, single-turn encoder count 360.
    ret=Wmx3Lib_cm.config.SetSingleTurn(2,True,360)
    if ret != 0:
        print('SetSingleTurn error code is ' + str(ret) + ': ' + Wmx3Lib_cm.ErrorToString(ret))
        return

    # Add the path interpolation with rotation commands
    path.numPoints = 7

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    profile = Profile()
    point.profile.type = ProfileType.Trapezoidal
    point.profile.velocity = 1000
    point.profile.acc = 2000
    point.profile.dec = 2000
    point.SetTarget(0, 100)
    point.SetTarget(1, 0)
    point.zAxisTarget = 25
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Circular
    point.direction = 1
    point.SetCenterPos(0, 100)
    point.SetCenterPos(1, 50)
    point.SetTarget(0, 150)
    point.SetTarget(1, 50)
    point.zAxisTarget = 50
    path.SetPoint(1, point)

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    point.SetTarget(0, 150)
    point.SetTarget(1, 100)
    point.zAxisTarget = 75
    path.SetPoint(2, point)

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Circular
    point.direction = 1
    point.SetCenterPos(0, 100)
    point.SetCenterPos(1, 100)
    point.SetTarget(0, 150)
    point.SetTarget(1, 150)
    point.zAxisTarget = 100
    path.SetPoint(3, point)

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    point.SetTarget(0, 50)
    point.SetTarget(1, 150)
    point.zAxisTarget = 125
    path.SetPoint(4, point)

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Circular
    point.direction = 1
    point.SetCenterPos(0, 50)
    point.SetCenterPos(1, 100)
    point.SetTarget(0, 0)
    point.SetTarget(1, 100)
    point.zAxisTarget = 1500
    path.SetPoint(5, point)

    point = AdvMotion_PathIntplWithRotationCommandPoint()
    point.type = AdvMotion_PathIntplSegmentType.Linear
    point.SetTarget(0, 0)
    point.SetTarget(1, 0)
    point.zAxisTarget = 175
    path.SetPoint(6, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplWithRotationCommand(0, path)
    if ret != 0:
        print('AddPathIntplWithRotationCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Execute path interpolation with rotation
    ret = Wmx3Lib_adv.advMotion.StartPathIntplWithRotation(0)  # Move to point 2
    if ret != 0:
        print('StartPathIntplWithRotation error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return
    Wmx3Lib_cm.motion.Wait(0)
    timeoutCounter = 0
    # Wait until the path interpolation with rotation is in Idle state
    pathStatus = AdvMotion_PathIntplWithRotationState()
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplWithRotationStatus(0)
    while True:
        if (pathStatus.state == AdvMotion_PathIntplWithRotationState.Idle):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplWithRotationStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplWithRotation Runuing timeout.!')
        return
    # Free the path interpolation with rotation buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplWithRotationBuffer(0)
    if ret != 0:
        print('FreePathIntplWithRotationBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    #Turn off Axis 2 single-turn mode.
    AxisParam=Config_AxisParam()
    ret,AxisParam =Wmx3Lib_cm.config.GetAxisParam()
    AxisParam.SetSingleTurnMode(2,False)

    ret,AxisParamError=Wmx3Lib_cm.config.SetAxisParam(AxisParam)
    if ret != 0:
        print('Close SingleTurnMode error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return



#``



# Write python code to Execute path interpolation with look ahead of Axis 0 and Axis 1 with velocity 1000, consisting of four linear interpolations: (100,0),(100,100),(0,100),(0,0).
    # Axes = [0, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplLookaheadCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    # Create the path interpolation with look ahead buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplLookaheadBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with look ahead channel
    conf = AdvMotion_PathIntplLookaheadConfiguration()

    conf.axisCount = 2
    conf.SetAxis(0, 0)
    conf.SetAxis(1, 1)
    conf.compositeVel = 1000
    conf.compositeAcc = 2000
    #  The commanded axes will automatically change to Idle operation state after all interpolation commands in the path have been executed.
    conf.stopOnEmptyBuffer = True

    ret = Wmx3Lib_adv.advMotion.SetPathIntplLookaheadConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplLookaheadConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Add the path interpolation with look ahead commands
    path.numPoints = 4

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 100)
    point.linear.SetTarget(1, 0)
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 100)
    point.linear.SetTarget(1, 100)
    path.SetPoint(1, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 0)
    point.linear.SetTarget(1, 100)
    path.SetPoint(2, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 0)
    point.linear.SetTarget(1, 0)
    path.SetPoint(3, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplLookaheadCommand(0, path)
    if ret != 0:
        print('AddPathIntplLookaheadCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Execute path interpolation with look ahead
    ret = Wmx3Lib_adv.advMotion.StartPathIntplLookahead(0)
    if ret != 0:
        print('StartPathIntplLookahead error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the path interpolation with look ahead to complete
    Wmx3Lib_cm.motion.Wait(0)
    timeoutCounter = 0
    # Wait until the path interpolation with look ahead is in Stopped state
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    while True:
        if (pathStatus.state != AdvMotion_PathIntplLookaheadState.Stopped):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplLookahead Runuing timeout.!')
        return
    # Free the path interpolation with look ahead buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    if ret != 0:
        print('FreePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return



#``



# Write python code to Execute path interpolation with look ahead of Axis 0 and Axis 1 with velocity 1000, consisting of four linear interpolations: (100,0),(100,100),(0,100),(0,0). First start executing it for 0.5s, then stop and sleep for 1s, and then resume it.
    # Axes = [0, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplLookaheadCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    # Create the path interpolation with look ahead buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplLookaheadBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with look ahead channel
    conf = AdvMotion_PathIntplLookaheadConfiguration()

    conf.axisCount = 2
    conf.SetAxis(0, 0)
    conf.SetAxis(1, 1)
    conf.compositeVel = 1000
    conf.compositeAcc = 2000
    #  The commanded axes will automatically change to Idle operation state after all interpolation commands in the path have been executed.
    conf.stopOnEmptyBuffer = True

    ret = Wmx3Lib_adv.advMotion.SetPathIntplLookaheadConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplLookaheadConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Add the path interpolation with look ahead commands
    path.numPoints = 4

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 100)
    point.linear.SetTarget(1, 0)
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 100)
    point.linear.SetTarget(1, 100)
    path.SetPoint(1, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 0)
    point.linear.SetTarget(1, 100)
    path.SetPoint(2, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 0)
    point.linear.SetTarget(1, 0)
    path.SetPoint(3, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplLookaheadCommand(0, path)
    if ret != 0:
        print('AddPathIntplLookaheadCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Execute path interpolation with look ahead
    ret = Wmx3Lib_adv.advMotion.StartPathIntplLookahead(0)
    if ret != 0:
        print('StartPathIntplLookahead error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    sleep(0.5)
    # Stop path interpolation with look ahead
    ret = Wmx3Lib_adv.advMotion.StopPathIntplLookahead(0)
    if ret != 0:
        print('StopPathIntplLookahead error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return
    
    sleep(1)
    # Execute path interpolation with look ahead (Resume execution)
    ret = Wmx3Lib_adv.advMotion.StartPathIntplLookahead(0)
    if ret != 0:
        print('StartPathIntplLookahead error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the path interpolation with look ahead to complete
    Wmx3Lib_cm.motion.Wait(0)
    timeoutCounter = 0
    # Wait until the path interpolation with look ahead is in Stopped state
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    while True:
        if (pathStatus.state != AdvMotion_PathIntplLookaheadState.Stopped):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplLookahead Runuing timeout.!')
        return
    
    # Free the path interpolation with look ahead buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    if ret != 0:
        print('FreePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return




#``



# Write python code to Execute path interpolation with look ahead of Axis 0 and Axis 1 with velocity 1000, consisting of four linear interpolations: (100,0),(100,100),(0,100),(0,0).
    # Axes = [0, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplLookaheadCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    # Create the path interpolation with look ahead buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplLookaheadBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with look ahead channel
    conf = AdvMotion_PathIntplLookaheadConfiguration()

    conf.axisCount = 2
    conf.SetAxis(0, 0)
    conf.SetAxis(1, 1)
    conf.compositeVel = 1000
    conf.compositeAcc = 2000
    #  The commanded axes will automatically change to Idle operation state after all interpolation commands in the path have been executed.
    conf.stopOnEmptyBuffer = True
    # Sample the profile at every specified distance along the path, improving the granularity of the generated profile.
    conf.sampleDistance = 100

    ret = Wmx3Lib_adv.advMotion.SetPathIntplLookaheadConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplLookaheadConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Add the path interpolation with look ahead commands
    path.numPoints = 4

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 100)
    point.linear.SetTarget(1, 0)
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 100)
    point.linear.SetTarget(1, 100)
    path.SetPoint(1, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 0)
    point.linear.SetTarget(1, 100)
    path.SetPoint(2, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 0)
    point.linear.SetTarget(1, 0)
    path.SetPoint(3, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplLookaheadCommand(0, path)
    if ret != 0:
        print('AddPathIntplLookaheadCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Execute path interpolation with look ahead
    ret = Wmx3Lib_adv.advMotion.StartPathIntplLookahead(0)
    if ret != 0:
        print('StartPathIntplLookahead error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the path interpolation with look ahead to complete
    Wmx3Lib_cm.motion.Wait(0)
    timeoutCounter = 0
    # Wait until the path interpolation with look ahead is in Stopped state
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    while True:
        if (pathStatus.state != AdvMotion_PathIntplLookaheadState.Stopped):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplLookahead Runuing timeout.!')
        return
    # Free the path interpolation with look ahead buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    if ret != 0:
        print('FreePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return




#``



# Write python code to Execute path interpolation with look ahead of Axis 0 and Axis 1 with velocity 1000, with a sample distance 100, consisting of four linear interpolations: (100,0),(100,100),(0,100),(0,0), while the smoothRadius are 12.5, 25 and 50.
    # Axes = [0, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplLookaheadCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    # Create the path interpolation with look ahead buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplLookaheadBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with look ahead channel
    conf = AdvMotion_PathIntplLookaheadConfiguration()

    conf.axisCount = 2
    conf.SetAxis(0, 0)
    conf.SetAxis(1, 1)
    conf.compositeVel = 1000
    conf.compositeAcc = 2000
    #  The commanded axes will automatically change to Idle operation state after all interpolation commands in the path have been executed.
    conf.stopOnEmptyBuffer = True
    # Sample the profile at every specified distance along the path, improving the granularity of the generated profile.
    conf.sampleDistance = 100

    ret = Wmx3Lib_adv.advMotion.SetPathIntplLookaheadConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplLookaheadConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Add the path interpolation with look ahead commands
    path.numPoints = 4

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 100)
    point.linear.SetTarget(1, 0)
    point.linear.smoothRadius = 12.5
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 100)
    point.linear.SetTarget(1, 100)
    point.linear.smoothRadius = 25
    path.SetPoint(1, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 0)
    point.linear.SetTarget(1, 100)
    point.linear.smoothRadius = 50
    path.SetPoint(2, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 0)
    point.linear.SetTarget(1, 0)
    path.SetPoint(3, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplLookaheadCommand(0, path)
    if ret != 0:
        print('AddPathIntplLookaheadCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Execute path interpolation with look ahead
    ret = Wmx3Lib_adv.advMotion.StartPathIntplLookahead(0)
    if ret != 0:
        print('StartPathIntplLookahead error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the path interpolation with look ahead to complete
    Wmx3Lib_cm.motion.Wait(0)
    timeoutCounter = 0
    # Wait until the path interpolation with look ahead is in Stopped state
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    while True:
        if (pathStatus.state != AdvMotion_PathIntplLookaheadState.Stopped):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplLookahead Runuing timeout.!')
        return
    # Free the path interpolation with look ahead buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    if ret != 0:
        print('FreePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return




#``



# Write python code to Execute path interpolation with look ahead of Axis 0 and Axis 1 with velocity 1000, composite acceleration 2000, and the acceleration limit  for each axis is 1500, with a sample distance 100, consisting of four linear interpolations: (100,0),(100,100),(0,100),(0,0), while the smoothRadius are 12.5, 25 and 50.
    # Axes = [0, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplLookaheadCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    # Create the path interpolation with look ahead buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplLookaheadBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with look ahead channel
    conf = AdvMotion_PathIntplLookaheadConfiguration()

    conf.axisCount = 2
    conf.SetAxis(0, 0)
    conf.SetAxis(1, 1)
    conf.compositeVel = 1000
    conf.compositeAcc = 2000
    #  The commanded axes will automatically change to Idle operation state after all interpolation commands in the path have been executed.
    conf.stopOnEmptyBuffer = True
    # Sample the profile at every specified distance along the path, improving the granularity of the generated profile.
    conf.sampleDistance = 100
    conf.SetAccLimit(0, 1500)
    conf.SetAccLimit(1, 1500)

    ret = Wmx3Lib_adv.advMotion.SetPathIntplLookaheadConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplLookaheadConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Add the path interpolation with look ahead commands
    path.numPoints = 4

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 100)
    point.linear.SetTarget(1, 0)
    point.linear.smoothRadius = 12.5
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 100)
    point.linear.SetTarget(1, 100)
    point.linear.smoothRadius = 25
    path.SetPoint(1, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 0)
    point.linear.SetTarget(1, 100)
    point.linear.smoothRadius = 50
    path.SetPoint(2, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 0)
    point.linear.SetTarget(1, 0)
    path.SetPoint(3, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplLookaheadCommand(0, path)
    if ret != 0:
        print('AddPathIntplLookaheadCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Execute path interpolation with look ahead
    ret = Wmx3Lib_adv.advMotion.StartPathIntplLookahead(0)
    if ret != 0:
        print('StartPathIntplLookahead error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the path interpolation with look ahead to complete
    Wmx3Lib_cm.motion.Wait(0)
    timeoutCounter = 0
    # Wait until the path interpolation with look ahead is in Stopped state
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    while True:
        if (pathStatus.state != AdvMotion_PathIntplLookaheadState.Stopped):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplLookahead Runuing timeout.!')
        return
    # Free the path interpolation with look ahead buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    if ret != 0:
        print('FreePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return



#``



# Write python code to Execute path interpolation with look ahead of Axis 0 and Axis 1 with velocity 1000, composite acceleration 2000, and the acceleration limit for each axis is 1500, and the velocity limit for Axis 0 and 1 is 700 and 500,  with a sample distance 100, consisting of four linear interpolations: (100,0),(100,100),(0,100),(0,0), while the smoothRadius are 12.5, 25 and 50.
    # Axes = [0, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplLookaheadCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    # Create the path interpolation with look ahead buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplLookaheadBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with look ahead channel
    conf = AdvMotion_PathIntplLookaheadConfiguration()

    conf.axisCount = 2
    conf.SetAxis(0, 0)
    conf.SetAxis(1, 1)
    conf.compositeVel = 1000
    conf.compositeAcc = 2000
    #  The commanded axes will automatically change to Idle operation state after all interpolation commands in the path have been executed.
    conf.stopOnEmptyBuffer = True
    # Sample the profile at every specified distance along the path, improving the granularity of the generated profile.
    conf.sampleDistance = 100
    conf.SetAccLimit(0, 1500)
    conf.SetAccLimit(1, 1500)
    conf.SetVelocityLimit(0, 700)
    conf.SetVelocityLimit(1, 500)

    ret = Wmx3Lib_adv.advMotion.SetPathIntplLookaheadConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplLookaheadConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Add the path interpolation with look ahead commands
    path.numPoints = 4

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 100)
    point.linear.SetTarget(1, 0)
    point.linear.smoothRadius = 12.5
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 100)
    point.linear.SetTarget(1, 100)
    point.linear.smoothRadius = 25
    path.SetPoint(1, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 0)
    point.linear.SetTarget(1, 100)
    point.linear.smoothRadius = 50
    path.SetPoint(2, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 0)
    point.linear.SetTarget(1, 0)
    path.SetPoint(3, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplLookaheadCommand(0, path)
    if ret != 0:
        print('AddPathIntplLookaheadCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Execute path interpolation with look ahead
    ret = Wmx3Lib_adv.advMotion.StartPathIntplLookahead(0)
    if ret != 0:
        print('StartPathIntplLookahead error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the path interpolation with look ahead to complete
    Wmx3Lib_cm.motion.Wait(0)
    timeoutCounter = 0
    # Wait until the path interpolation with look ahead is in Stopped state
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    while True:
        if (pathStatus.state != AdvMotion_PathIntplLookaheadState.Stopped):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplLookahead Runuing timeout.!')
        return
    # Free the path interpolation with look ahead buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    if ret != 0:
        print('FreePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return



#``



# Write python code to Execute path interpolation with look ahead of Axis 0 and Axis 1 with velocity 1000, with a sample distance 50 and angle tolerance 11, consisting of 36 linear interpolations to comprise a counterclockwise circle which starts from (0,0) and the radius is 200.
    # Axes = [0, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplLookaheadCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    
    # Create the path interpolation with look ahead buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplLookaheadBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with look ahead channel
    conf = AdvMotion_PathIntplLookaheadConfiguration()

    conf.axisCount = 2
    conf.SetAxis(0, 0)
    conf.SetAxis(1, 1)
    conf.compositeVel = 1000
    conf.compositeAcc = 4000
    conf.sampleDistance = 50
    conf.stopOnEmptyBuffer = True
    conf.setAngleTolerance = True
    conf.angleToleranceDegrees = 11

    ret = Wmx3Lib_adv.advMotion.SetPathIntplLookaheadConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplLookaheadConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Add the path interpolation with look ahead commands
    path.numPoints = 36

    PI = float(3.141592653589793238)

    for i in range(0, 36):
        Point = AdvMotion_PathIntplLookaheadCommandPoint()
        Point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
        Point.linear.axisCount = 2
        Point.linear.SetAxis(0, 0)
        Point.linear.SetAxis(1, 1)
        Point.linear.SetTarget(0, -200 + 200 * math.cos((i + 1) / 36.0 * (2 * PI)))
        Point.linear.SetTarget(1, 0 + 200 * math.sin((i + 1) / 36.0 * (2 * PI)))
        path.SetPoint(i, Point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplLookaheadCommand(0, path)
    if ret != 0:
        print('AddPathIntplLookaheadCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Execute path interpolation with look ahead
    ret = Wmx3Lib_adv.advMotion.StartPathIntplLookahead(0)
    if ret != 0:
        print('StartPathIntplLookahead error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the path interpolation with look ahead to complete
    Wmx3Lib_cm.motion.Wait(0)
    timeoutCounter = 0
    # Wait until the path interpolation with look ahead is in Stopped state
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    while True:
        if (pathStatus.state != AdvMotion_PathIntplLookaheadState.Stopped):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplLookahead Runuing timeout.!')
        return
    # Free the path interpolation with look ahead buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    if ret != 0:
        print('FreePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return



#``



# Write python code to Execute path interpolation with look ahead of Axis 0 and Axis 1 with velocity 1000, with a sample distance 50 and angle tolerance 11, consisting of 36 linear interpolations to comprise a counterclockwise circle which starts from (0,0) and the radius is 200.
    # Axes = [0, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplLookaheadCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    
    # Create the path interpolation with look ahead buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplLookaheadBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with look ahead channel
    conf = AdvMotion_PathIntplLookaheadConfiguration()

    conf.axisCount = 2
    conf.SetAxis(0, 0)
    conf.SetAxis(1, 1)
    conf.compositeVel = 1000
    conf.compositeAcc = 4000
    conf.sampleDistance = 50
    conf.stopOnEmptyBuffer = True

    ret = Wmx3Lib_adv.advMotion.SetPathIntplLookaheadConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplLookaheadConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Add the path interpolation with look ahead commands
    path.numPoints = 36

    PI = float(3.141592653589793238)

    for i in range(0, 36):
        Point = AdvMotion_PathIntplLookaheadCommandPoint()
        Point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
        Point.linear.axisCount = 2
        Point.linear.SetAxis(0, 0)
        Point.linear.SetAxis(1, 1)
        Point.linear.SetTarget(0, -200 + 200 * math.cos((i + 1) / 36.0 * (2 * PI)))
        Point.linear.SetTarget(1, 0 + 200 * math.sin((i + 1) / 36.0 * (2 * PI)))
        Point.smoothRadius = 20
        path.SetPoint(i, Point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplLookaheadCommand(0, path)
    if ret != 0:
        print('AddPathIntplLookaheadCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Execute path interpolation with look ahead
    ret = Wmx3Lib_adv.advMotion.StartPathIntplLookahead(0)
    if ret != 0:
        print('StartPathIntplLookahead error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the path interpolation with look ahead to complete
    Wmx3Lib_cm.motion.Wait(0)
    timeoutCounter = 0
    # Wait until the path interpolation with look ahead is in Stopped state
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    while True:
        if (pathStatus.state != AdvMotion_PathIntplLookaheadState.Stopped):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplLookahead Runuing timeout.!')
        return
    # Free the path interpolation with look ahead buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    if ret != 0:
        print('FreePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return



#``



# Write python code to Execute path interpolation with look ahead of Axis 0 and Axis 1 with velocity 1000, with a sample distance 50, consisting of four circular interpolations defined as (throughPos0,throughPos1,endPos0,endPos1): (50,50,100,0),(50,-50,0,0),(-50,50,-100,0),(-50,-50,0,0).
    # Axes = [0, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplLookaheadCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    # Create the path interpolation with look ahead buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplLookaheadBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with look ahead channel
    conf = AdvMotion_PathIntplLookaheadConfiguration()

    conf.axisCount = 2
    conf.SetAxis(0, 0)
    conf.SetAxis(1, 1)
    conf.compositeVel = 1000
    conf.compositeAcc = 4000
    conf.sampleDistance = 50
    conf.stopOnEmptyBuffer = True

    ret = Wmx3Lib_adv.advMotion.SetPathIntplLookaheadConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplLookaheadConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Add the path interpolation with look ahead commands
    point = AdvMotion_PathIntplLookaheadCommand()
    path.numPoints = 4

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.ThroughAndEndCircular
    point.throughAndEndCircular.SetAxis(0, 0)
    point.throughAndEndCircular.SetAxis(1, 1)
    point.throughAndEndCircular.SetThroughPos(0, 50)
    point.throughAndEndCircular.SetThroughPos(1, 50)
    point.throughAndEndCircular.SetEndPos(0, 100)
    point.throughAndEndCircular.SetEndPos(1, 0)
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.ThroughAndEndCircular
    point.throughAndEndCircular.SetAxis(0, 0)
    point.throughAndEndCircular.SetAxis(1, 1)
    point.throughAndEndCircular.SetThroughPos(0, 50)
    point.throughAndEndCircular.SetThroughPos(1, -50)
    point.throughAndEndCircular.SetEndPos(0, 0)
    point.throughAndEndCircular.SetEndPos(1, 0)
    path.SetPoint(1, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.ThroughAndEndCircular
    point.throughAndEndCircular.SetAxis(0, 0)
    point.throughAndEndCircular.SetAxis(1, 1)
    point.throughAndEndCircular.SetThroughPos(0, -50)
    point.throughAndEndCircular.SetThroughPos(1, 50)
    point.throughAndEndCircular.SetEndPos(0, -100)
    point.throughAndEndCircular.SetEndPos(1, 0)
    path.SetPoint(2, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.ThroughAndEndCircular
    point.throughAndEndCircular.SetAxis(0, 0)
    point.throughAndEndCircular.SetAxis(1, 1)
    point.throughAndEndCircular.SetThroughPos(0, -50)
    point.throughAndEndCircular.SetThroughPos(1, -50)
    point.throughAndEndCircular.SetEndPos(0, 0)
    point.throughAndEndCircular.SetEndPos(1, 0)
    path.SetPoint(3, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplLookaheadCommand(0, path)
    if ret != 0:
        print('AddPathIntplLookaheadCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Execute path interpolation with look ahead
    ret = Wmx3Lib_adv.advMotion.StartPathIntplLookahead(0)
    if ret != 0:
        print('StartPathIntplLookahead error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the path interpolation with look ahead to complete
    Wmx3Lib_cm.motion.Wait(0)
    timeoutCounter = 0
    # Wait until the path interpolation with look ahead is in Stopped state
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    while True:
        if (pathStatus.state != AdvMotion_PathIntplLookaheadState.Stopped):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplLookahead Runuing timeout.!')
        return
    # Free the path interpolation with look ahead buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    if ret != 0:
        print('FreePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return


#``



# Write python code to Execute path interpolation with look ahead of Axis 0 and Axis 1 with velocity 1000, with a sample distance 50, and with the velocityLimit of axis 1 set to 500, consisting of four circular interpolations defined as (throughPos0,throughPos1,endPos0,endPos1): (50,50,100,0),(50,-50,0,0),(-50,50,-100,0),(-50,-50,0,0).
    # Axes = [0, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplLookaheadCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    # Create the path interpolation with look ahead buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplLookaheadBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with look ahead channel
    conf = AdvMotion_PathIntplLookaheadConfiguration()

    conf.axisCount = 2
    conf.SetAxis(0, 0)
    conf.SetAxis(1, 1)
    conf.compositeVel = 1000
    conf.compositeAcc = 4000
    conf.sampleDistance = 50
    conf.stopOnEmptyBuffer = True
    conf.SetVelocityLimit(1, 500)

    ret = Wmx3Lib_adv.advMotion.SetPathIntplLookaheadConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplLookaheadConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Add the path interpolation with look ahead commands
    point = AdvMotion_PathIntplLookaheadCommand()
    path.numPoints = 4

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.ThroughAndEndCircular
    point.throughAndEndCircular.SetAxis(0, 0)
    point.throughAndEndCircular.SetAxis(1, 1)
    point.throughAndEndCircular.SetThroughPos(0, 50)
    point.throughAndEndCircular.SetThroughPos(1, 50)
    point.throughAndEndCircular.SetEndPos(0, 100)
    point.throughAndEndCircular.SetEndPos(1, 0)
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.ThroughAndEndCircular
    point.throughAndEndCircular.SetAxis(0, 0)
    point.throughAndEndCircular.SetAxis(1, 1)
    point.throughAndEndCircular.SetThroughPos(0, 50)
    point.throughAndEndCircular.SetThroughPos(1, -50)
    point.throughAndEndCircular.SetEndPos(0, 0)
    point.throughAndEndCircular.SetEndPos(1, 0)
    path.SetPoint(1, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.ThroughAndEndCircular
    point.throughAndEndCircular.SetAxis(0, 0)
    point.throughAndEndCircular.SetAxis(1, 1)
    point.throughAndEndCircular.SetThroughPos(0, -50)
    point.throughAndEndCircular.SetThroughPos(1, 50)
    point.throughAndEndCircular.SetEndPos(0, -100)
    point.throughAndEndCircular.SetEndPos(1, 0)
    path.SetPoint(2, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.ThroughAndEndCircular
    point.throughAndEndCircular.SetAxis(0, 0)
    point.throughAndEndCircular.SetAxis(1, 1)
    point.throughAndEndCircular.SetThroughPos(0, -50)
    point.throughAndEndCircular.SetThroughPos(1, -50)
    point.throughAndEndCircular.SetEndPos(0, 0)
    point.throughAndEndCircular.SetEndPos(1, 0)
    path.SetPoint(3, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplLookaheadCommand(0, path)
    if ret != 0:
        print('AddPathIntplLookaheadCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Execute path interpolation with look ahead
    ret = Wmx3Lib_adv.advMotion.StartPathIntplLookahead(0)
    if ret != 0:
        print('StartPathIntplLookahead error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the path interpolation with look ahead to complete
    Wmx3Lib_cm.motion.Wait(0)
    timeoutCounter = 0
    # Wait until the path interpolation with look ahead is in Stopped state
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    while True:
        if (pathStatus.state != AdvMotion_PathIntplLookaheadState.Stopped):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplLookahead Runuing timeout.!')
        return
    # Free the path interpolation with look ahead buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    if ret != 0:
        print('FreePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return




#``



# Write python code to Execute path interpolation with look ahead of Axis 0 and Axis 1 with velocity 1000, with a sample distance 2, consisting of two linear interpolations: (50,0),(50,50). After executing 0.1s, dynamically add two linear interpolations: (50,100),(100,100).
    # Axes = [0, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplLookaheadCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    # Create the path interpolation with look ahead buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplLookaheadBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with look ahead channel
    conf = AdvMotion_PathIntplLookaheadConfiguration()

    conf.axisCount = 2
    conf.SetAxis(0, 0)
    conf.SetAxis(1, 1)
    conf.compositeVel = 1000
    conf.compositeAcc = 2000
    #  The commanded axes will automatically change to Idle operation state after all interpolation commands in the path have been executed.
    conf.stopOnEmptyBuffer = True
    # Sample the profile at every specified distance along the path, improving the granularity of the generated profile.
    conf.sampleDistance = 2

    ret = Wmx3Lib_adv.advMotion.SetPathIntplLookaheadConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplLookaheadConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Add the path interpolation with look ahead commands
    path.numPoints = 2

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 50)
    point.linear.SetTarget(1, 0)
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 50)
    point.linear.SetTarget(1, 50)
    path.SetPoint(1, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplLookaheadCommand(0, path)
    if ret != 0:
        print('AddPathIntplLookaheadCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Execute path interpolation with look ahead
    ret = Wmx3Lib_adv.advMotion.StartPathIntplLookahead(0)
    if ret != 0:
        print('StartPathIntplLookahead error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return
    
    sleep(0.1)

    point.linear.SetTarget(0, 50)
    point.linear.SetTarget(1, 100)
    path.SetPoint(0, point)
    point.linear.SetTarget(0, 100)
    point.linear.SetTarget(1, 100)
    path.SetPoint(1, point)       

    ret = Wmx3Lib_adv.advMotion.AddPathIntplLookaheadCommand(0, path)
    if ret != 0:
        print('AddPathIntplLookaheadCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the path interpolation with look ahead to complete
    Wmx3Lib_cm.motion.Wait(0)
    timeoutCounter = 0
    # Wait until the path interpolation with look ahead is in Stopped state
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    while True:
        if (pathStatus.state != AdvMotion_PathIntplLookaheadState.Stopped):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplLookahead Runuing timeout.!')
        return
    # Free the path interpolation with look ahead buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    if ret != 0:
        print('FreePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return



#``



# Write python code to Execute path interpolation with look ahead of Axis 0 and Axis 1 with velocity 1000, with a sample distance 100, consisting of four sequences: linear interpolations to (100,0), linear interpolations to (100,100), sleep 0.5s, linear interpolations to (0,0), while the smoothRadius is 30.
    # Axes = [0, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplLookaheadCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    # Create the path interpolation with look ahead buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplLookaheadBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with look ahead channel
    conf = AdvMotion_PathIntplLookaheadConfiguration()

    conf.axisCount = 2
    conf.SetAxis(0, 0)
    conf.SetAxis(1, 1)
    conf.compositeVel = 1000
    conf.compositeAcc = 2000
    #  The commanded axes will automatically change to Idle operation state after all interpolation commands in the path have been executed.
    conf.stopOnEmptyBuffer = True
    # Sample the profile at every specified distance along the path, improving the granularity of the generated profile.
    conf.sampleDistance = 100

    ret = Wmx3Lib_adv.advMotion.SetPathIntplLookaheadConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplLookaheadConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Add the path interpolation with look ahead commands
    path.numPoints = 4

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 100)
    point.linear.SetTarget(1, 0)
    point.linear.smoothRadius = 30
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 100)
    point.linear.SetTarget(1, 100)
    point.linear.smoothRadius = 30
    path.SetPoint(1, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Sleep
    point.sleep.milliseconds = 500
    path.SetPoint(2, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 0)
    point.linear.SetTarget(1, 0)
    path.SetPoint(3, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplLookaheadCommand(0, path)
    if ret != 0:
        print('AddPathIntplLookaheadCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Execute path interpolation with look ahead
    ret = Wmx3Lib_adv.advMotion.StartPathIntplLookahead(0)
    if ret != 0:
        print('StartPathIntplLookahead error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the path interpolation with look ahead to complete
    Wmx3Lib_cm.motion.Wait(0)
    timeoutCounter = 0
    # Wait until the path interpolation with look ahead is in Stopped state
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    while True:
        if (pathStatus.state != AdvMotion_PathIntplLookaheadState.Stopped):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplLookahead Runuing timeout.!')
        return
    # Free the path interpolation with look ahead buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    if ret != 0:
        print('FreePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return




#``



# Write python code to Execute path interpolation with look ahead of Axis 0 and Axis 1 with velocity 1000, with a sample distance 100, consisting of eight sequences: linear interpolations to (100,0), linear interpolations to (100,100), linear interpolations to (60,100), set output 0.0 to 1, linear interpolations to (40,100),  set output 0.0 to 0, linear interpolations to (0,100), linear interpolations to (10,20), while the smoothRadius is 30.
    # Axes = [0, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplLookaheadCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    # Create the path interpolation with look ahead buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplLookaheadBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with look ahead channel
    conf = AdvMotion_PathIntplLookaheadConfiguration()

    conf.axisCount = 2
    conf.SetAxis(0, 0)
    conf.SetAxis(1, 1)
    conf.compositeVel = 1000
    conf.compositeAcc = 2000
    #  The commanded axes will automatically change to Idle operation state after all interpolation commands in the path have been executed.
    conf.stopOnEmptyBuffer = True
    # Sample the profile at every specified distance along the path, improving the granularity of the generated profile.
    conf.sampleDistance = 100

    ret = Wmx3Lib_adv.advMotion.SetPathIntplLookaheadConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplLookaheadConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Add the path interpolation with look ahead commands
    point = AdvMotion_PathIntplLookaheadCommand()
    path.numPoints = 8

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 100)
    point.linear.SetTarget(1, 0)
    point.linear.smoothRadius = 30
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 100)
    point.linear.SetTarget(1, 100)
    point.linear.smoothRadius = 30
    path.SetPoint(1, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 60)
    point.linear.SetTarget(1, 100)
    point.linear.smoothRadius = 30
    path.SetPoint(2, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.SetOutputBit
    point.setOutputBit.byteAddress = 0
    point.setOutputBit.bitAddress = 0
    point.setOutputBit.value = 1
    point.setOutputBit.type = AdvMotion_PathIntplOutputType.Immediate
    point.setOutputBit.source = AdvMotion_PathIntplOutputSource.IOOutput
    path.SetPoint(3, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 40)
    point.linear.SetTarget(1, 100)
    point.linear.smoothRadius = 30
    path.SetPoint(4, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.SetOutputBit
    point.setOutputBit.byteAddress = 0
    point.setOutputBit.bitAddress = 0
    point.setOutputBit.value = 0
    point.setOutputBit.type = AdvMotion_PathIntplOutputType.Immediate
    point.setOutputBit.source = AdvMotion_PathIntplOutputSource.IOOutput
    path.SetPoint(5, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 0)
    point.linear.SetTarget(1, 100)
    point.linear.smoothRadius = 30
    path.SetPoint(6, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 10)
    point.linear.SetTarget(1, 20)
    path.SetPoint(7, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplLookaheadCommand(0, path)
    if ret != 0:
        print('AddPathIntplLookaheadCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Execute path interpolation with look ahead
    ret = Wmx3Lib_adv.advMotion.StartPathIntplLookahead(0)
    if ret != 0:
        print('StartPathIntplLookahead error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the path interpolation with look ahead to complete
    Wmx3Lib_cm.motion.Wait(0)
    timeoutCounter = 0
    # Wait until the path interpolation with look ahead is in Stopped state
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    while True:
        if (pathStatus.state != AdvMotion_PathIntplLookaheadState.Stopped):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplLookahead Runuing timeout.!')
        return
    # Free the path interpolation with look ahead buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    if ret != 0:
        print('FreePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return




#``



# Write python code to Execute path interpolation with look ahead of Axis 0 and Axis 1 with velocity 1000, with a sample distance 100, consisting of two sequences: set output 0.0 to 1 when completed distance is 20, linear interpolations to (40,0).
    # Axes = [0, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplLookaheadCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    # Create the path interpolation with look ahead buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplLookaheadBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with look ahead channel
    conf = AdvMotion_PathIntplLookaheadConfiguration()

    conf.axisCount = 2
    conf.SetAxis(0, 0)
    conf.SetAxis(1, 1)
    conf.compositeVel = 1000
    conf.compositeAcc = 2000
    conf.sampleDistance = 100
    conf.stopOnEmptyBuffer = True

    ret = Wmx3Lib_adv.advMotion.SetPathIntplLookaheadConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplLookaheadConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Add the path interpolation with look ahead commands
    point = AdvMotion_PathIntplLookaheadCommand()
    path.numPoints = 2

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.SetOutputBit
    point.setOutputBit.byteAddress = 0
    point.setOutputBit.bitAddress = 0
    point.setOutputBit.value = 1
    point.setOutputBit.triggerValue = 20
    point.setOutputBit.type = AdvMotion_PathIntplOutputType.CompletedDist
    point.setOutputBit.source = AdvMotion_PathIntplOutputSource.IOOutput
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 40)
    point.linear.SetTarget(1, 0)
    path.SetPoint(1, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplLookaheadCommand(0, path)
    if ret != 0:
        print('AddPathIntplLookaheadCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Start path interpolation with look ahead
    ret = Wmx3Lib_adv.advMotion.StartPathIntplLookahead(0)
    if ret != 0:
        print('StartPathIntplLookahead error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the path interpolation with look ahead to complete
    Wmx3Lib_cm.motion.Wait(0)
    timeoutCounter = 0
    # Wait until the path interpolation with look ahead is in Stopped state
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    while True:
        if (pathStatus.state != AdvMotion_PathIntplLookaheadState.Stopped):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplLookahead Runuing timeout.!')
        return
    # Free the path interpolation with look ahead buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    if ret != 0:
        print('FreePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return



#``



# Write python code to Execute path interpolation with look ahead of Axis 0 and Axis 1 with velocity 1000, with a sample distance 100, consisting of three sequences: set output 0.0 to 1 when completed distance is 20, set output 0.0 to 1 when remaining distance is 10, linear interpolations to (40,0).
    # Axes = [0, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplLookaheadCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    # Create the path interpolation with look ahead buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplLookaheadBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with look ahead channel
    conf = AdvMotion_PathIntplLookaheadConfiguration()

    conf.axisCount = 2
    conf.SetAxis(0, 0)
    conf.SetAxis(1, 1)
    conf.compositeVel = 1000
    conf.compositeAcc = 2000
    conf.sampleDistance = 100
    conf.stopOnEmptyBuffer = True

    ret = Wmx3Lib_adv.advMotion.SetPathIntplLookaheadConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplLookaheadConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Add the path interpolation with look ahead commands
    point = AdvMotion_PathIntplLookaheadCommand()
    path.numPoints = 3

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.SetOutputBit
    point.setOutputBit.byteAddress = 0
    point.setOutputBit.bitAddress = 0
    point.setOutputBit.value = 1
    point.setOutputBit.triggerValue = 20
    point.setOutputBit.type = AdvMotion_PathIntplOutputType.CompletedDist
    point.setOutputBit.source = AdvMotion_PathIntplOutputSource.IOOutput
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.SetOutputBit
    point.setOutputBit.byteAddress = 0
    point.setOutputBit.bitAddress = 1
    point.setOutputBit.value = 1
    point.setOutputBit.triggerValue = 10
    point.setOutputBit.type = AdvMotion_PathIntplOutputType.RemainingDist
    point.setOutputBit.source = AdvMotion_PathIntplOutputSource.IOOutput
    path.SetPoint(1, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 40)
    point.linear.SetTarget(1, 0)
    path.SetPoint(2, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplLookaheadCommand(0, path)
    if ret != 0:
        print('AddPathIntplLookaheadCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Start path interpolation with look ahead
    ret = Wmx3Lib_adv.advMotion.StartPathIntplLookahead(0)
    if ret != 0:
        print('StartPathIntplLookahead error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the path interpolation with look ahead to complete
    Wmx3Lib_cm.motion.Wait(0)
    timeoutCounter = 0
    # Wait until the path interpolation with look ahead is in Stopped state
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    while True:
        if (pathStatus.state != AdvMotion_PathIntplLookaheadState.Stopped):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplLookahead Runuing timeout.!')
        return
    # Free the path interpolation with look ahead buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    if ret != 0:
        print('FreePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return



#``



# Write python code to Execute path interpolation with look ahead of Axis 0 and Axis 1 with velocity 1000, with a sample distance 100, consisting of three sequences: set output 0.0 to 1 when completed distance is 20, set output 0.0 to 1 when remaining distance is 10, linear interpolations to (40,0).
    # Axes = [0, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplLookaheadCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    # Create the path interpolation with look ahead buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplLookaheadBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with look ahead channel
    conf = AdvMotion_PathIntplLookaheadConfiguration()

    conf.axisCount = 2
    conf.SetAxis(0, 0)
    conf.SetAxis(1, 1)
    conf.compositeVel = 1000
    conf.compositeAcc = 2000
    conf.sampleDistance = 100
    conf.stopOnEmptyBuffer = True

    ret = Wmx3Lib_adv.advMotion.SetPathIntplLookaheadConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplLookaheadConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Add the path interpolation with look ahead commands
    point = AdvMotion_PathIntplLookaheadCommand()
    path.numPoints = 3

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.SetOutputBit
    point.setOutputBit.byteAddress = 0
    point.setOutputBit.bitAddress = 0
    point.setOutputBit.value = 1
    point.setOutputBit.triggerValue = 30
    point.setOutputBit.type = AdvMotion_PathIntplOutputType.CompletedDist
    point.setOutputBit.source = AdvMotion_PathIntplOutputSource.IOOutput
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.SetOutputBit
    point.setOutputBit.byteAddress = 0
    point.setOutputBit.bitAddress = 1
    point.setOutputBit.value = 1
    point.setOutputBit.triggerValue = 20
    point.setOutputBit.type = AdvMotion_PathIntplOutputType.CompletedDist
    point.setOutputBit.source = AdvMotion_PathIntplOutputSource.IOOutput
    path.SetPoint(1, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 40)
    point.linear.SetTarget(1, 0)
    path.SetPoint(2, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplLookaheadCommand(0, path)
    if ret != 0:
        print('AddPathIntplLookaheadCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Start path interpolation with look ahead
    ret = Wmx3Lib_adv.advMotion.StartPathIntplLookahead(0)
    if ret != 0:
        print('StartPathIntplLookahead error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the path interpolation with look ahead to complete
    Wmx3Lib_cm.motion.Wait(0)
    timeoutCounter = 0
    # Wait until the path interpolation with look ahead is in Stopped state
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    while True:
        if (pathStatus.state != AdvMotion_PathIntplLookaheadState.Stopped):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplLookahead Runuing timeout.!')
        return
    # Free the path interpolation with look ahead buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    if ret != 0:
        print('FreePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return



#``



# Write python code to Execute path interpolation with look ahead of Axis 0 and Axis 1 with velocity 1000, with a sample distance 10, consisting of four linear interpolations: (100,0) with velocity 900,(100,100) with velocity 700,(0,100) with velocity 500,(0,0) with velocity 300, while the smoothRadius is 30.
    # Axes = [0, 1]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplLookaheadCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    # Create the path interpolation with look ahead buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplLookaheadBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with look ahead channel
    conf = AdvMotion_PathIntplLookaheadConfiguration()

    conf.axisCount = 2
    conf.SetAxis(0, 0)
    conf.SetAxis(1, 1)
    conf.compositeVel = 1000
    conf.compositeAcc = 2000
    #  The commanded axes will automatically change to Idle operation state after all interpolation commands in the path have been executed.
    conf.stopOnEmptyBuffer = True
    # Sample the profile at every specified distance along the path, improving the granularity of the generated profile.
    conf.sampleDistance = 10

    ret = Wmx3Lib_adv.advMotion.SetPathIntplLookaheadConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplLookaheadConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Add the path interpolation with look ahead commands
    path.numPoints = 4

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 100)
    point.linear.SetTarget(1, 0)
    point.linear.smoothRadius = 30
    point.linear.setSegmentCompositeVel = 1
    point.linear.segmentCompositeVel = 900
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 100)
    point.linear.SetTarget(1, 100)
    point.linear.smoothRadius = 30
    point.linear.setSegmentCompositeVel = 1
    point.linear.segmentCompositeVel = 700
    path.SetPoint(1, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 0)
    point.linear.SetTarget(1, 100)
    point.linear.smoothRadius = 30
    point.linear.setSegmentCompositeVel = 1
    point.linear.segmentCompositeVel = 500
    path.SetPoint(2, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 2
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetTarget(0, 0)
    point.linear.SetTarget(1, 0)
    point.linear.setSegmentCompositeVel = 1
    point.linear.segmentCompositeVel = 300
    path.SetPoint(3, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplLookaheadCommand(0, path)
    if ret != 0:
        print('AddPathIntplLookaheadCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Execute path interpolation with look ahead
    ret = Wmx3Lib_adv.advMotion.StartPathIntplLookahead(0)
    if ret != 0:
        print('StartPathIntplLookahead error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the path interpolation with look ahead to complete
    Wmx3Lib_cm.motion.Wait(0)
    timeoutCounter = 0
    # Wait until the path interpolation with look ahead is in Stopped state
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    while True:
        if (pathStatus.state != AdvMotion_PathIntplLookaheadState.Stopped):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplLookahead Runuing timeout.!')
        return
    # Free the path interpolation with look ahead buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    if ret != 0:
        print('FreePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return




#``



# Write python code to Execute path interpolation with look ahead of Axis 0, 1 and 2 with velocity 100, composite acceleration 1000, and the acceleration limit for Axis 0, 1 and 2 is 300, 600 and 900, with a sample distance 100, consisting of three linear interpolations: (40,60,70),(30,20,120),(0,0,0), while the smoothRadius is 5.
    # Axes = [0, 1, 2]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplLookaheadCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    # Create the path interpolation with look ahead buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplLookaheadBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with look ahead channel
    conf = AdvMotion_PathIntplLookaheadConfiguration()

    conf.axisCount = 3
    conf.SetAxis(0, 0)
    conf.SetAxis(1, 1)
    conf.SetAxis(2, 2)
    conf.compositeVel = 100
    conf.compositeAcc = 1000
    conf.sampleDistance = 10
    conf.stopOnEmptyBuffer = True
    conf.SetAccLimit(0, 300)
    conf.SetAccLimit(1, 600)
    conf.SetAccLimit(2, 900)

    ret = Wmx3Lib_adv.advMotion.SetPathIntplLookaheadConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplLookaheadConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Add the path interpolation with look ahead commands
    point = AdvMotion_PathIntplLookaheadCommand()
    path.numPoints = 3

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 3
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetAxis(2, 2)
    point.linear.SetTarget(0, 40)
    point.linear.SetTarget(1, 60)
    point.linear.SetTarget(2, 70)
    point.linear.smoothRadius = 5
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 3
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetAxis(2, 2)
    point.linear.SetTarget(0, 30)
    point.linear.SetTarget(1, 20)
    point.linear.SetTarget(2, 120)
    point.linear.smoothRadius = 5
    path.SetPoint(1, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.Linear
    point.linear.axisCount = 3
    point.linear.SetAxis(0, 0)
    point.linear.SetAxis(1, 1)
    point.linear.SetAxis(2, 2)
    point.linear.SetTarget(0, 0)
    point.linear.SetTarget(1, 0)
    point.linear.SetTarget(2, 0)
    path.SetPoint(2, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplLookaheadCommand(0, path)
    if ret != 0:
        print('AddPathIntplLookaheadCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Start path interpolation with look ahead
    ret = Wmx3Lib_adv.advMotion.StartPathIntplLookahead(0)
    if ret != 0:
        print('StartPathIntplLookahead error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the path interpolation with look ahead to complete
    Wmx3Lib_cm.motion.Wait(0)
    timeoutCounter = 0
    # Wait until the path interpolation with look ahead is in Stopped state
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    while True:
        if (pathStatus.state != AdvMotion_PathIntplLookaheadState.Stopped):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplLookahead Runuing timeout.!')
        return
    # Free the path interpolation with look ahead buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    if ret != 0:
        print('FreePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return
    


#``



# Write python code to Execute path interpolation with look ahead of Axis 0, 1 and 2 with velocity 1000, and Axis 3 as the auxiliary axis, consisting of two circular interpolations defined as (throughPos0,throughPos1,throughPos2,endPos0,endPos1,endPos2,auxiliaryTarget): (70.71,29.29,0,100,100,0,50),(29.29,70.71,0,0,0,0,100).
    # Axes = [0, 1, 2 ,3]

    Wmx3Lib_adv = AdvancedMotion(Wmx3Lib)

    path = AdvMotion_PathIntplLookaheadCommand()
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    # Create the path interpolation with look ahead buffer
    ret = Wmx3Lib_adv.advMotion.CreatePathIntplLookaheadBuffer(0, 1000)
    if ret != 0:
        print('CreatePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Configure the path interpolation with look ahead channel
    conf = AdvMotion_PathIntplLookaheadConfiguration()

    conf.axisCount = 4
    conf.SetAxis(0, 0)
    conf.SetAxis(1, 1)
    conf.SetAxis(2, 2)
    conf.SetAxis(3, 3)
    conf.compositeVel = 1000
    conf.compositeAcc = 4000
    conf.stopOnEmptyBuffer = True

    ret = Wmx3Lib_adv.advMotion.SetPathIntplLookaheadConfiguration(0, conf)
    if ret != 0:
        print('SetPathIntplLookaheadConfiguration error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Add the path interpolation with look ahead commands
    point = AdvMotion_PathIntplLookaheadCommand()
    path.numPoints = 2

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.ThroughAndEnd3DCircular
    point.throughAndEnd3DCircular.axisCount = 3
    point.throughAndEnd3DCircular.SetAxis(0, 0)
    point.throughAndEnd3DCircular.SetAxis(1, 1)
    point.throughAndEnd3DCircular.SetAxis(2, 2)
    point.throughAndEnd3DCircular.SetThroughPos(0, 70.71)
    point.throughAndEnd3DCircular.SetThroughPos(1, 29.29)
    point.throughAndEnd3DCircular.SetThroughPos(2, 0)
    point.throughAndEnd3DCircular.SetEndPos(0, 100)
    point.throughAndEnd3DCircular.SetEndPos(1, 100)
    point.throughAndEnd3DCircular.SetEndPos(2, 0)
    point.throughAndEnd3DCircular.auxiliaryAxisCount = 1
    point.throughAndEnd3DCircular.SetAuxiliaryAxis(0, 3)
    point.throughAndEnd3DCircular.SetAuxiliaryTarget(0, 50)
    path.SetPoint(0, point)

    point = AdvMotion_PathIntplLookaheadCommandPoint()
    point.type = AdvMotion_PathIntplLookaheadSegmentType.ThroughAndEnd3DCircular
    point.throughAndEnd3DCircular.axisCount = 3
    point.throughAndEnd3DCircular.SetAxis(0, 0)
    point.throughAndEnd3DCircular.SetAxis(1, 1)
    point.throughAndEnd3DCircular.SetAxis(2, 2)
    point.throughAndEnd3DCircular.SetThroughPos(0, 29.29)
    point.throughAndEnd3DCircular.SetThroughPos(1, 70.71)
    point.throughAndEnd3DCircular.SetThroughPos(2, 0)
    point.throughAndEnd3DCircular.SetEndPos(0, 0)
    point.throughAndEnd3DCircular.SetEndPos(1, 0)
    point.throughAndEnd3DCircular.SetEndPos(2, 0)
    point.throughAndEnd3DCircular.auxiliaryAxisCount = 1
    point.throughAndEnd3DCircular.SetAuxiliaryAxis(0, 3)
    point.throughAndEnd3DCircular.SetAuxiliaryTarget(0, 100)
    path.SetPoint(1, point)

    ret = Wmx3Lib_adv.advMotion.AddPathIntplLookaheadCommand(0, path)
    if ret != 0:
        print('AddPathIntplLookaheadCommand error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Start path interpolation with look ahead
    ret = Wmx3Lib_adv.advMotion.StartPathIntplLookahead(0)
    if ret != 0:
        print('StartPathIntplLookahead error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return

    # Wait for the path interpolation with look ahead to complete
    Wmx3Lib_cm.motion.Wait(0)
    timeoutCounter = 0
    # Wait until the path interpolation with look ahead is in Stopped state
    ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    while True:
        if (pathStatus.state != AdvMotion_PathIntplLookaheadState.Stopped):
            break
        sleep(0.1)
        timeoutCounter = timeoutCounter + 1
        if (timeoutCounter > 500):
            break
        ret, pathStatus = Wmx3Lib_adv.advMotion.GetPathIntplLookaheadStatus(0)
    if (timeoutCounter > 500):
        print('PathIntplLookahead Runuing timeout.!')
        return
    # Free the path interpolation with look ahead buffer (normally, the buffer should only be freed at the end of the application)
    ret = Wmx3Lib_adv.advMotion.FreePathIntplLookaheadBuffer(0)
    if ret != 0:
        print('FreePathIntplLookaheadBuffer error code is ' + str(ret) + ': ' + Wmx3Lib_adv.ErrorToString(ret))
        return
    


#``



